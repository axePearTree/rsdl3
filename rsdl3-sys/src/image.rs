/* automatically generated by rust-bindgen 0.71.1 */

use crate::*;

pub const SDL_PLATFORM_LINUX: u32 = 1;
pub const SDL_PLATFORM_UNIX: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const SDL_SIZE_MAX: i32 = -1;
pub const SDL_PRIs64: &[u8; 3] = b"ld\0";
pub const SDL_PRIu64: &[u8; 3] = b"lu\0";
pub const SDL_PRIx64: &[u8; 3] = b"lx\0";
pub const SDL_PRIX64: &[u8; 3] = b"lX\0";
pub const SDL_PRIs32: &[u8; 2] = b"d\0";
pub const SDL_PRIu32: &[u8; 2] = b"u\0";
pub const SDL_PRIx32: &[u8; 2] = b"x\0";
pub const SDL_PRIX32: &[u8; 2] = b"X\0";
pub const SDL_PRILL_PREFIX: &[u8; 3] = b"ll\0";
pub const SDL_PRILLd: &[u8; 4] = b"lld\0";
pub const SDL_PRILLu: &[u8; 4] = b"llu\0";
pub const SDL_PRILLx: &[u8; 4] = b"llx\0";
pub const SDL_PRILLX: &[u8; 4] = b"llX\0";
pub const SDL_INVALID_UNICODE_CODEPOINT: u32 = 65533;
pub const SDL_PI_D: f64 = 3.141592653589793;
pub const SDL_PI_F: f64 = 3.141592653589793;
pub const SDL_ASSERT_LEVEL: u32 = 2;
pub const SDL_NULL_WHILE_LOOP_CONDITION: u32 = 0;
pub const SDL_LIL_ENDIAN: u32 = 1234;
pub const SDL_BIG_ENDIAN: u32 = 4321;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const SDL_BYTEORDER: u32 = 1234;
pub const SDL_FLOATWORDORDER: u32 = 1234;
pub const SDL_PROP_THREAD_CREATE_ENTRY_FUNCTION_POINTER: &[u8; 33] =
    b"SDL.thread.create.entry_function\0";
pub const SDL_PROP_THREAD_CREATE_NAME_STRING: &[u8; 23] = b"SDL.thread.create.name\0";
pub const SDL_PROP_THREAD_CREATE_USERDATA_POINTER: &[u8; 27] = b"SDL.thread.create.userdata\0";
pub const SDL_PROP_THREAD_CREATE_STACKSIZE_NUMBER: &[u8; 28] = b"SDL.thread.create.stacksize\0";
pub const SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER: &[u8; 28] = b"SDL.iostream.windows.handle\0";
pub const SDL_PROP_IOSTREAM_STDIO_FILE_POINTER: &[u8; 24] = b"SDL.iostream.stdio.file\0";
pub const SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER: &[u8; 29] = b"SDL.iostream.file_descriptor\0";
pub const SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER: &[u8; 28] = b"SDL.iostream.android.aasset\0";
pub const SDL_PROP_IOSTREAM_MEMORY_POINTER: &[u8; 25] = b"SDL.iostream.memory.base\0";
pub const SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER: &[u8; 25] = b"SDL.iostream.memory.size\0";
pub const SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER: &[u8; 28] = b"SDL.iostream.dynamic.memory\0";
pub const SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER: &[u8; 31] =
    b"SDL.iostream.dynamic.chunksize\0";
pub const SDL_AUDIO_MASK_BITSIZE: u32 = 255;
pub const SDL_AUDIO_MASK_FLOAT: u32 = 256;
pub const SDL_AUDIO_MASK_BIG_ENDIAN: u32 = 4096;
pub const SDL_AUDIO_MASK_SIGNED: u32 = 32768;
pub const SDL_BLENDMODE_NONE: u32 = 0;
pub const SDL_BLENDMODE_BLEND: u32 = 1;
pub const SDL_BLENDMODE_BLEND_PREMULTIPLIED: u32 = 16;
pub const SDL_BLENDMODE_ADD: u32 = 2;
pub const SDL_BLENDMODE_ADD_PREMULTIPLIED: u32 = 32;
pub const SDL_BLENDMODE_MOD: u32 = 4;
pub const SDL_BLENDMODE_MUL: u32 = 8;
pub const SDL_BLENDMODE_INVALID: u32 = 2147483647;
pub const SDL_ALPHA_OPAQUE: u32 = 255;
pub const SDL_ALPHA_OPAQUE_FLOAT: f64 = 1.0;
pub const SDL_ALPHA_TRANSPARENT: u32 = 0;
pub const SDL_ALPHA_TRANSPARENT_FLOAT: f64 = 0.0;
pub const SDL_SURFACE_PREALLOCATED: u32 = 1;
pub const SDL_SURFACE_LOCK_NEEDED: u32 = 2;
pub const SDL_SURFACE_LOCKED: u32 = 4;
pub const SDL_SURFACE_SIMD_ALIGNED: u32 = 8;
pub const SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT: &[u8; 28] = b"SDL.surface.SDR_white_point\0";
pub const SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT: &[u8; 25] = b"SDL.surface.HDR_headroom\0";
pub const SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING: &[u8; 20] = b"SDL.surface.tonemap\0";
pub const SDL_CACHELINE_SIZE: u32 = 128;
pub const SDL_PROP_GLOBAL_VIDEO_WAYLAND_WL_DISPLAY_POINTER: &[u8; 29] =
    b"SDL.video.wayland.wl_display\0";
pub const SDL_WINDOWPOS_UNDEFINED_MASK: u32 = 536805376;
pub const SDL_WINDOWPOS_CENTERED_MASK: u32 = 805240832;
pub const SDL_GL_CONTEXT_PROFILE_CORE: u32 = 1;
pub const SDL_GL_CONTEXT_PROFILE_COMPATIBILITY: u32 = 2;
pub const SDL_GL_CONTEXT_PROFILE_ES: u32 = 4;
pub const SDL_GL_CONTEXT_DEBUG_FLAG: u32 = 1;
pub const SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG: u32 = 2;
pub const SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG: u32 = 4;
pub const SDL_GL_CONTEXT_RESET_ISOLATION_FLAG: u32 = 8;
pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE: u32 = 0;
pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: u32 = 1;
pub const SDL_GL_CONTEXT_RESET_NO_NOTIFICATION: u32 = 0;
pub const SDL_GL_CONTEXT_RESET_LOSE_CONTEXT: u32 = 1;
pub const SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN: &[u8; 24] = b"SDL.display.HDR_enabled\0";
pub const SDL_PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER: &[u8; 37] =
    b"SDL.display.KMSDRM.panel_orientation\0";
pub const SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN: &[u8; 32] =
    b"SDL.window.create.always_on_top\0";
pub const SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN: &[u8; 29] = b"SDL.window.create.borderless\0";
pub const SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN: &[u8; 28] = b"SDL.window.create.focusable\0";
pub const SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN: &[u8; 44] =
    b"SDL.window.create.external_graphics_context\0";
pub const SDL_PROP_WINDOW_CREATE_FLAGS_NUMBER: &[u8; 24] = b"SDL.window.create.flags\0";
pub const SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN: &[u8; 29] = b"SDL.window.create.fullscreen\0";
pub const SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER: &[u8; 25] = b"SDL.window.create.height\0";
pub const SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN: &[u8; 25] = b"SDL.window.create.hidden\0";
pub const SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN: &[u8; 37] =
    b"SDL.window.create.high_pixel_density\0";
pub const SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN: &[u8; 28] = b"SDL.window.create.maximized\0";
pub const SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN: &[u8; 23] = b"SDL.window.create.menu\0";
pub const SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN: &[u8; 24] = b"SDL.window.create.metal\0";
pub const SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN: &[u8; 28] = b"SDL.window.create.minimized\0";
pub const SDL_PROP_WINDOW_CREATE_MODAL_BOOLEAN: &[u8; 24] = b"SDL.window.create.modal\0";
pub const SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN: &[u8; 32] =
    b"SDL.window.create.mouse_grabbed\0";
pub const SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN: &[u8; 25] = b"SDL.window.create.opengl\0";
pub const SDL_PROP_WINDOW_CREATE_PARENT_POINTER: &[u8; 25] = b"SDL.window.create.parent\0";
pub const SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN: &[u8; 28] = b"SDL.window.create.resizable\0";
pub const SDL_PROP_WINDOW_CREATE_TITLE_STRING: &[u8; 24] = b"SDL.window.create.title\0";
pub const SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN: &[u8; 30] =
    b"SDL.window.create.transparent\0";
pub const SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN: &[u8; 26] = b"SDL.window.create.tooltip\0";
pub const SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN: &[u8; 26] = b"SDL.window.create.utility\0";
pub const SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN: &[u8; 25] = b"SDL.window.create.vulkan\0";
pub const SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER: &[u8; 24] = b"SDL.window.create.width\0";
pub const SDL_PROP_WINDOW_CREATE_X_NUMBER: &[u8; 20] = b"SDL.window.create.x\0";
pub const SDL_PROP_WINDOW_CREATE_Y_NUMBER: &[u8; 20] = b"SDL.window.create.y\0";
pub const SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER: &[u8; 31] =
    b"SDL.window.create.cocoa.window\0";
pub const SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER: &[u8; 29] = b"SDL.window.create.cocoa.view\0";
pub const SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN: &[u8; 46] =
    b"SDL.window.create.wayland.surface_role_custom\0";
pub const SDL_PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN: &[u8; 44] =
    b"SDL.window.create.wayland.create_egl_window\0";
pub const SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER: &[u8; 37] =
    b"SDL.window.create.wayland.wl_surface\0";
pub const SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER: &[u8; 29] = b"SDL.window.create.win32.hwnd\0";
pub const SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER: &[u8; 42] =
    b"SDL.window.create.win32.pixel_format_hwnd\0";
pub const SDL_PROP_WINDOW_CREATE_X11_WINDOW_NUMBER: &[u8; 29] = b"SDL.window.create.x11.window\0";
pub const SDL_PROP_WINDOW_SHAPE_POINTER: &[u8; 17] = b"SDL.window.shape\0";
pub const SDL_PROP_WINDOW_HDR_ENABLED_BOOLEAN: &[u8; 23] = b"SDL.window.HDR_enabled\0";
pub const SDL_PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT: &[u8; 27] = b"SDL.window.SDR_white_level\0";
pub const SDL_PROP_WINDOW_HDR_HEADROOM_FLOAT: &[u8; 24] = b"SDL.window.HDR_headroom\0";
pub const SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER: &[u8; 26] = b"SDL.window.android.window\0";
pub const SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER: &[u8; 27] = b"SDL.window.android.surface\0";
pub const SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER: &[u8; 24] = b"SDL.window.uikit.window\0";
pub const SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER: &[u8; 32] =
    b"SDL.window.uikit.metal_view_tag\0";
pub const SDL_PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER: &[u8; 36] =
    b"SDL.window.uikit.opengl.framebuffer\0";
pub const SDL_PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER: &[u8; 37] =
    b"SDL.window.uikit.opengl.renderbuffer\0";
pub const SDL_PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER: &[u8; 44] =
    b"SDL.window.uikit.opengl.resolve_framebuffer\0";
pub const SDL_PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER: &[u8; 28] = b"SDL.window.kmsdrm.dev_index\0";
pub const SDL_PROP_WINDOW_KMSDRM_DRM_FD_NUMBER: &[u8; 25] = b"SDL.window.kmsdrm.drm_fd\0";
pub const SDL_PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER: &[u8; 26] = b"SDL.window.kmsdrm.gbm_dev\0";
pub const SDL_PROP_WINDOW_COCOA_WINDOW_POINTER: &[u8; 24] = b"SDL.window.cocoa.window\0";
pub const SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER: &[u8; 32] =
    b"SDL.window.cocoa.metal_view_tag\0";
pub const SDL_PROP_WINDOW_OPENVR_OVERLAY_ID: &[u8; 29] = b"SDL.window.openvr.overlay_id\0";
pub const SDL_PROP_WINDOW_VIVANTE_DISPLAY_POINTER: &[u8; 27] = b"SDL.window.vivante.display\0";
pub const SDL_PROP_WINDOW_VIVANTE_WINDOW_POINTER: &[u8; 26] = b"SDL.window.vivante.window\0";
pub const SDL_PROP_WINDOW_VIVANTE_SURFACE_POINTER: &[u8; 27] = b"SDL.window.vivante.surface\0";
pub const SDL_PROP_WINDOW_WIN32_HWND_POINTER: &[u8; 22] = b"SDL.window.win32.hwnd\0";
pub const SDL_PROP_WINDOW_WIN32_HDC_POINTER: &[u8; 21] = b"SDL.window.win32.hdc\0";
pub const SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER: &[u8; 26] = b"SDL.window.win32.instance\0";
pub const SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER: &[u8; 27] = b"SDL.window.wayland.display\0";
pub const SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER: &[u8; 27] = b"SDL.window.wayland.surface\0";
pub const SDL_PROP_WINDOW_WAYLAND_VIEWPORT_POINTER: &[u8; 28] = b"SDL.window.wayland.viewport\0";
pub const SDL_PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER: &[u8; 30] =
    b"SDL.window.wayland.egl_window\0";
pub const SDL_PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER: &[u8; 31] =
    b"SDL.window.wayland.xdg_surface\0";
pub const SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER: &[u8; 32] =
    b"SDL.window.wayland.xdg_toplevel\0";
pub const SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING: &[u8; 46] =
    b"SDL.window.wayland.xdg_toplevel_export_handle\0";
pub const SDL_PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER: &[u8; 29] = b"SDL.window.wayland.xdg_popup\0";
pub const SDL_PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER: &[u8; 34] =
    b"SDL.window.wayland.xdg_positioner\0";
pub const SDL_PROP_WINDOW_X11_DISPLAY_POINTER: &[u8; 23] = b"SDL.window.x11.display\0";
pub const SDL_PROP_WINDOW_X11_SCREEN_NUMBER: &[u8; 22] = b"SDL.window.x11.screen\0";
pub const SDL_PROP_WINDOW_X11_WINDOW_NUMBER: &[u8; 22] = b"SDL.window.x11.window\0";
pub const SDL_WINDOW_SURFACE_VSYNC_DISABLED: u32 = 0;
pub const SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE: i32 = -1;
pub const SDL_PROP_FILE_DIALOG_FILTERS_POINTER: &[u8; 23] = b"SDL.filedialog.filters\0";
pub const SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER: &[u8; 24] = b"SDL.filedialog.nfilters\0";
pub const SDL_PROP_FILE_DIALOG_WINDOW_POINTER: &[u8; 22] = b"SDL.filedialog.window\0";
pub const SDL_PROP_FILE_DIALOG_LOCATION_STRING: &[u8; 24] = b"SDL.filedialog.location\0";
pub const SDL_PROP_FILE_DIALOG_MANY_BOOLEAN: &[u8; 20] = b"SDL.filedialog.many\0";
pub const SDL_PROP_FILE_DIALOG_TITLE_STRING: &[u8; 21] = b"SDL.filedialog.title\0";
pub const SDL_PROP_FILE_DIALOG_ACCEPT_STRING: &[u8; 22] = b"SDL.filedialog.accept\0";
pub const SDL_PROP_FILE_DIALOG_CANCEL_STRING: &[u8; 22] = b"SDL.filedialog.cancel\0";
pub const SDL_STANDARD_GRAVITY: f64 = 9.80665;
pub const SDL_JOYSTICK_AXIS_MAX: u32 = 32767;
pub const SDL_JOYSTICK_AXIS_MIN: i32 = -32768;
pub const SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN: &[u8; 26] = b"SDL.joystick.cap.mono_led\0";
pub const SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN: &[u8; 25] = b"SDL.joystick.cap.rgb_led\0";
pub const SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN: &[u8; 28] = b"SDL.joystick.cap.player_led\0";
pub const SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN: &[u8; 24] = b"SDL.joystick.cap.rumble\0";
pub const SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN: &[u8; 32] =
    b"SDL.joystick.cap.trigger_rumble\0";
pub const SDL_HAT_CENTERED: u32 = 0;
pub const SDL_HAT_UP: u32 = 1;
pub const SDL_HAT_RIGHT: u32 = 2;
pub const SDL_HAT_DOWN: u32 = 4;
pub const SDL_HAT_LEFT: u32 = 8;
pub const SDL_HAT_RIGHTUP: u32 = 3;
pub const SDL_HAT_RIGHTDOWN: u32 = 6;
pub const SDL_HAT_LEFTUP: u32 = 9;
pub const SDL_HAT_LEFTDOWN: u32 = 12;
pub const SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN: &[u8; 26] = b"SDL.joystick.cap.mono_led\0";
pub const SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN: &[u8; 25] = b"SDL.joystick.cap.rgb_led\0";
pub const SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN: &[u8; 28] = b"SDL.joystick.cap.player_led\0";
pub const SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN: &[u8; 24] = b"SDL.joystick.cap.rumble\0";
pub const SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN: &[u8; 32] =
    b"SDL.joystick.cap.trigger_rumble\0";
pub const SDLK_EXTENDED_MASK: u32 = 536870912;
pub const SDLK_SCANCODE_MASK: u32 = 1073741824;
pub const SDLK_UNKNOWN: u32 = 0;
pub const SDLK_RETURN: u32 = 13;
pub const SDLK_ESCAPE: u32 = 27;
pub const SDLK_BACKSPACE: u32 = 8;
pub const SDLK_TAB: u32 = 9;
pub const SDLK_SPACE: u32 = 32;
pub const SDLK_EXCLAIM: u32 = 33;
pub const SDLK_DBLAPOSTROPHE: u32 = 34;
pub const SDLK_HASH: u32 = 35;
pub const SDLK_DOLLAR: u32 = 36;
pub const SDLK_PERCENT: u32 = 37;
pub const SDLK_AMPERSAND: u32 = 38;
pub const SDLK_APOSTROPHE: u32 = 39;
pub const SDLK_LEFTPAREN: u32 = 40;
pub const SDLK_RIGHTPAREN: u32 = 41;
pub const SDLK_ASTERISK: u32 = 42;
pub const SDLK_PLUS: u32 = 43;
pub const SDLK_COMMA: u32 = 44;
pub const SDLK_MINUS: u32 = 45;
pub const SDLK_PERIOD: u32 = 46;
pub const SDLK_SLASH: u32 = 47;
pub const SDLK_0: u32 = 48;
pub const SDLK_1: u32 = 49;
pub const SDLK_2: u32 = 50;
pub const SDLK_3: u32 = 51;
pub const SDLK_4: u32 = 52;
pub const SDLK_5: u32 = 53;
pub const SDLK_6: u32 = 54;
pub const SDLK_7: u32 = 55;
pub const SDLK_8: u32 = 56;
pub const SDLK_9: u32 = 57;
pub const SDLK_COLON: u32 = 58;
pub const SDLK_SEMICOLON: u32 = 59;
pub const SDLK_LESS: u32 = 60;
pub const SDLK_EQUALS: u32 = 61;
pub const SDLK_GREATER: u32 = 62;
pub const SDLK_QUESTION: u32 = 63;
pub const SDLK_AT: u32 = 64;
pub const SDLK_LEFTBRACKET: u32 = 91;
pub const SDLK_BACKSLASH: u32 = 92;
pub const SDLK_RIGHTBRACKET: u32 = 93;
pub const SDLK_CARET: u32 = 94;
pub const SDLK_UNDERSCORE: u32 = 95;
pub const SDLK_GRAVE: u32 = 96;
pub const SDLK_A: u32 = 97;
pub const SDLK_B: u32 = 98;
pub const SDLK_C: u32 = 99;
pub const SDLK_D: u32 = 100;
pub const SDLK_E: u32 = 101;
pub const SDLK_F: u32 = 102;
pub const SDLK_G: u32 = 103;
pub const SDLK_H: u32 = 104;
pub const SDLK_I: u32 = 105;
pub const SDLK_J: u32 = 106;
pub const SDLK_K: u32 = 107;
pub const SDLK_L: u32 = 108;
pub const SDLK_M: u32 = 109;
pub const SDLK_N: u32 = 110;
pub const SDLK_O: u32 = 111;
pub const SDLK_P: u32 = 112;
pub const SDLK_Q: u32 = 113;
pub const SDLK_R: u32 = 114;
pub const SDLK_S: u32 = 115;
pub const SDLK_T: u32 = 116;
pub const SDLK_U: u32 = 117;
pub const SDLK_V: u32 = 118;
pub const SDLK_W: u32 = 119;
pub const SDLK_X: u32 = 120;
pub const SDLK_Y: u32 = 121;
pub const SDLK_Z: u32 = 122;
pub const SDLK_LEFTBRACE: u32 = 123;
pub const SDLK_PIPE: u32 = 124;
pub const SDLK_RIGHTBRACE: u32 = 125;
pub const SDLK_TILDE: u32 = 126;
pub const SDLK_DELETE: u32 = 127;
pub const SDLK_PLUSMINUS: u32 = 177;
pub const SDLK_CAPSLOCK: u32 = 1073741881;
pub const SDLK_F1: u32 = 1073741882;
pub const SDLK_F2: u32 = 1073741883;
pub const SDLK_F3: u32 = 1073741884;
pub const SDLK_F4: u32 = 1073741885;
pub const SDLK_F5: u32 = 1073741886;
pub const SDLK_F6: u32 = 1073741887;
pub const SDLK_F7: u32 = 1073741888;
pub const SDLK_F8: u32 = 1073741889;
pub const SDLK_F9: u32 = 1073741890;
pub const SDLK_F10: u32 = 1073741891;
pub const SDLK_F11: u32 = 1073741892;
pub const SDLK_F12: u32 = 1073741893;
pub const SDLK_PRINTSCREEN: u32 = 1073741894;
pub const SDLK_SCROLLLOCK: u32 = 1073741895;
pub const SDLK_PAUSE: u32 = 1073741896;
pub const SDLK_INSERT: u32 = 1073741897;
pub const SDLK_HOME: u32 = 1073741898;
pub const SDLK_PAGEUP: u32 = 1073741899;
pub const SDLK_END: u32 = 1073741901;
pub const SDLK_PAGEDOWN: u32 = 1073741902;
pub const SDLK_RIGHT: u32 = 1073741903;
pub const SDLK_LEFT: u32 = 1073741904;
pub const SDLK_DOWN: u32 = 1073741905;
pub const SDLK_UP: u32 = 1073741906;
pub const SDLK_NUMLOCKCLEAR: u32 = 1073741907;
pub const SDLK_KP_DIVIDE: u32 = 1073741908;
pub const SDLK_KP_MULTIPLY: u32 = 1073741909;
pub const SDLK_KP_MINUS: u32 = 1073741910;
pub const SDLK_KP_PLUS: u32 = 1073741911;
pub const SDLK_KP_ENTER: u32 = 1073741912;
pub const SDLK_KP_1: u32 = 1073741913;
pub const SDLK_KP_2: u32 = 1073741914;
pub const SDLK_KP_3: u32 = 1073741915;
pub const SDLK_KP_4: u32 = 1073741916;
pub const SDLK_KP_5: u32 = 1073741917;
pub const SDLK_KP_6: u32 = 1073741918;
pub const SDLK_KP_7: u32 = 1073741919;
pub const SDLK_KP_8: u32 = 1073741920;
pub const SDLK_KP_9: u32 = 1073741921;
pub const SDLK_KP_0: u32 = 1073741922;
pub const SDLK_KP_PERIOD: u32 = 1073741923;
pub const SDLK_APPLICATION: u32 = 1073741925;
pub const SDLK_POWER: u32 = 1073741926;
pub const SDLK_KP_EQUALS: u32 = 1073741927;
pub const SDLK_F13: u32 = 1073741928;
pub const SDLK_F14: u32 = 1073741929;
pub const SDLK_F15: u32 = 1073741930;
pub const SDLK_F16: u32 = 1073741931;
pub const SDLK_F17: u32 = 1073741932;
pub const SDLK_F18: u32 = 1073741933;
pub const SDLK_F19: u32 = 1073741934;
pub const SDLK_F20: u32 = 1073741935;
pub const SDLK_F21: u32 = 1073741936;
pub const SDLK_F22: u32 = 1073741937;
pub const SDLK_F23: u32 = 1073741938;
pub const SDLK_F24: u32 = 1073741939;
pub const SDLK_EXECUTE: u32 = 1073741940;
pub const SDLK_HELP: u32 = 1073741941;
pub const SDLK_MENU: u32 = 1073741942;
pub const SDLK_SELECT: u32 = 1073741943;
pub const SDLK_STOP: u32 = 1073741944;
pub const SDLK_AGAIN: u32 = 1073741945;
pub const SDLK_UNDO: u32 = 1073741946;
pub const SDLK_CUT: u32 = 1073741947;
pub const SDLK_COPY: u32 = 1073741948;
pub const SDLK_PASTE: u32 = 1073741949;
pub const SDLK_FIND: u32 = 1073741950;
pub const SDLK_MUTE: u32 = 1073741951;
pub const SDLK_VOLUMEUP: u32 = 1073741952;
pub const SDLK_VOLUMEDOWN: u32 = 1073741953;
pub const SDLK_KP_COMMA: u32 = 1073741957;
pub const SDLK_KP_EQUALSAS400: u32 = 1073741958;
pub const SDLK_ALTERASE: u32 = 1073741977;
pub const SDLK_SYSREQ: u32 = 1073741978;
pub const SDLK_CANCEL: u32 = 1073741979;
pub const SDLK_CLEAR: u32 = 1073741980;
pub const SDLK_PRIOR: u32 = 1073741981;
pub const SDLK_RETURN2: u32 = 1073741982;
pub const SDLK_SEPARATOR: u32 = 1073741983;
pub const SDLK_OUT: u32 = 1073741984;
pub const SDLK_OPER: u32 = 1073741985;
pub const SDLK_CLEARAGAIN: u32 = 1073741986;
pub const SDLK_CRSEL: u32 = 1073741987;
pub const SDLK_EXSEL: u32 = 1073741988;
pub const SDLK_KP_00: u32 = 1073742000;
pub const SDLK_KP_000: u32 = 1073742001;
pub const SDLK_THOUSANDSSEPARATOR: u32 = 1073742002;
pub const SDLK_DECIMALSEPARATOR: u32 = 1073742003;
pub const SDLK_CURRENCYUNIT: u32 = 1073742004;
pub const SDLK_CURRENCYSUBUNIT: u32 = 1073742005;
pub const SDLK_KP_LEFTPAREN: u32 = 1073742006;
pub const SDLK_KP_RIGHTPAREN: u32 = 1073742007;
pub const SDLK_KP_LEFTBRACE: u32 = 1073742008;
pub const SDLK_KP_RIGHTBRACE: u32 = 1073742009;
pub const SDLK_KP_TAB: u32 = 1073742010;
pub const SDLK_KP_BACKSPACE: u32 = 1073742011;
pub const SDLK_KP_A: u32 = 1073742012;
pub const SDLK_KP_B: u32 = 1073742013;
pub const SDLK_KP_C: u32 = 1073742014;
pub const SDLK_KP_D: u32 = 1073742015;
pub const SDLK_KP_E: u32 = 1073742016;
pub const SDLK_KP_F: u32 = 1073742017;
pub const SDLK_KP_XOR: u32 = 1073742018;
pub const SDLK_KP_POWER: u32 = 1073742019;
pub const SDLK_KP_PERCENT: u32 = 1073742020;
pub const SDLK_KP_LESS: u32 = 1073742021;
pub const SDLK_KP_GREATER: u32 = 1073742022;
pub const SDLK_KP_AMPERSAND: u32 = 1073742023;
pub const SDLK_KP_DBLAMPERSAND: u32 = 1073742024;
pub const SDLK_KP_VERTICALBAR: u32 = 1073742025;
pub const SDLK_KP_DBLVERTICALBAR: u32 = 1073742026;
pub const SDLK_KP_COLON: u32 = 1073742027;
pub const SDLK_KP_HASH: u32 = 1073742028;
pub const SDLK_KP_SPACE: u32 = 1073742029;
pub const SDLK_KP_AT: u32 = 1073742030;
pub const SDLK_KP_EXCLAM: u32 = 1073742031;
pub const SDLK_KP_MEMSTORE: u32 = 1073742032;
pub const SDLK_KP_MEMRECALL: u32 = 1073742033;
pub const SDLK_KP_MEMCLEAR: u32 = 1073742034;
pub const SDLK_KP_MEMADD: u32 = 1073742035;
pub const SDLK_KP_MEMSUBTRACT: u32 = 1073742036;
pub const SDLK_KP_MEMMULTIPLY: u32 = 1073742037;
pub const SDLK_KP_MEMDIVIDE: u32 = 1073742038;
pub const SDLK_KP_PLUSMINUS: u32 = 1073742039;
pub const SDLK_KP_CLEAR: u32 = 1073742040;
pub const SDLK_KP_CLEARENTRY: u32 = 1073742041;
pub const SDLK_KP_BINARY: u32 = 1073742042;
pub const SDLK_KP_OCTAL: u32 = 1073742043;
pub const SDLK_KP_DECIMAL: u32 = 1073742044;
pub const SDLK_KP_HEXADECIMAL: u32 = 1073742045;
pub const SDLK_LCTRL: u32 = 1073742048;
pub const SDLK_LSHIFT: u32 = 1073742049;
pub const SDLK_LALT: u32 = 1073742050;
pub const SDLK_LGUI: u32 = 1073742051;
pub const SDLK_RCTRL: u32 = 1073742052;
pub const SDLK_RSHIFT: u32 = 1073742053;
pub const SDLK_RALT: u32 = 1073742054;
pub const SDLK_RGUI: u32 = 1073742055;
pub const SDLK_MODE: u32 = 1073742081;
pub const SDLK_SLEEP: u32 = 1073742082;
pub const SDLK_WAKE: u32 = 1073742083;
pub const SDLK_CHANNEL_INCREMENT: u32 = 1073742084;
pub const SDLK_CHANNEL_DECREMENT: u32 = 1073742085;
pub const SDLK_MEDIA_PLAY: u32 = 1073742086;
pub const SDLK_MEDIA_PAUSE: u32 = 1073742087;
pub const SDLK_MEDIA_RECORD: u32 = 1073742088;
pub const SDLK_MEDIA_FAST_FORWARD: u32 = 1073742089;
pub const SDLK_MEDIA_REWIND: u32 = 1073742090;
pub const SDLK_MEDIA_NEXT_TRACK: u32 = 1073742091;
pub const SDLK_MEDIA_PREVIOUS_TRACK: u32 = 1073742092;
pub const SDLK_MEDIA_STOP: u32 = 1073742093;
pub const SDLK_MEDIA_EJECT: u32 = 1073742094;
pub const SDLK_MEDIA_PLAY_PAUSE: u32 = 1073742095;
pub const SDLK_MEDIA_SELECT: u32 = 1073742096;
pub const SDLK_AC_NEW: u32 = 1073742097;
pub const SDLK_AC_OPEN: u32 = 1073742098;
pub const SDLK_AC_CLOSE: u32 = 1073742099;
pub const SDLK_AC_EXIT: u32 = 1073742100;
pub const SDLK_AC_SAVE: u32 = 1073742101;
pub const SDLK_AC_PRINT: u32 = 1073742102;
pub const SDLK_AC_PROPERTIES: u32 = 1073742103;
pub const SDLK_AC_SEARCH: u32 = 1073742104;
pub const SDLK_AC_HOME: u32 = 1073742105;
pub const SDLK_AC_BACK: u32 = 1073742106;
pub const SDLK_AC_FORWARD: u32 = 1073742107;
pub const SDLK_AC_STOP: u32 = 1073742108;
pub const SDLK_AC_REFRESH: u32 = 1073742109;
pub const SDLK_AC_BOOKMARKS: u32 = 1073742110;
pub const SDLK_SOFTLEFT: u32 = 1073742111;
pub const SDLK_SOFTRIGHT: u32 = 1073742112;
pub const SDLK_CALL: u32 = 1073742113;
pub const SDLK_ENDCALL: u32 = 1073742114;
pub const SDLK_LEFT_TAB: u32 = 536870913;
pub const SDLK_LEVEL5_SHIFT: u32 = 536870914;
pub const SDLK_MULTI_KEY_COMPOSE: u32 = 536870915;
pub const SDLK_LMETA: u32 = 536870916;
pub const SDLK_RMETA: u32 = 536870917;
pub const SDLK_LHYPER: u32 = 536870918;
pub const SDLK_RHYPER: u32 = 536870919;
pub const SDL_KMOD_NONE: u32 = 0;
pub const SDL_KMOD_LSHIFT: u32 = 1;
pub const SDL_KMOD_RSHIFT: u32 = 2;
pub const SDL_KMOD_LEVEL5: u32 = 4;
pub const SDL_KMOD_LCTRL: u32 = 64;
pub const SDL_KMOD_RCTRL: u32 = 128;
pub const SDL_KMOD_LALT: u32 = 256;
pub const SDL_KMOD_RALT: u32 = 512;
pub const SDL_KMOD_LGUI: u32 = 1024;
pub const SDL_KMOD_RGUI: u32 = 2048;
pub const SDL_KMOD_NUM: u32 = 4096;
pub const SDL_KMOD_CAPS: u32 = 8192;
pub const SDL_KMOD_MODE: u32 = 16384;
pub const SDL_KMOD_SCROLL: u32 = 32768;
pub const SDL_KMOD_CTRL: u32 = 192;
pub const SDL_KMOD_SHIFT: u32 = 3;
pub const SDL_KMOD_ALT: u32 = 768;
pub const SDL_KMOD_GUI: u32 = 3072;
pub const SDL_PROP_TEXTINPUT_TYPE_NUMBER: &[u8; 19] = b"SDL.textinput.type\0";
pub const SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER: &[u8; 29] = b"SDL.textinput.capitalization\0";
pub const SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN: &[u8; 26] = b"SDL.textinput.autocorrect\0";
pub const SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN: &[u8; 24] = b"SDL.textinput.multiline\0";
pub const SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER: &[u8; 32] =
    b"SDL.textinput.android.inputtype\0";
pub const SDL_BUTTON_LEFT: u32 = 1;
pub const SDL_BUTTON_MIDDLE: u32 = 2;
pub const SDL_BUTTON_RIGHT: u32 = 3;
pub const SDL_BUTTON_X1: u32 = 4;
pub const SDL_BUTTON_X2: u32 = 5;
pub const SDL_PEN_INPUT_DOWN: u32 = 1;
pub const SDL_PEN_INPUT_BUTTON_1: u32 = 2;
pub const SDL_PEN_INPUT_BUTTON_2: u32 = 4;
pub const SDL_PEN_INPUT_BUTTON_3: u32 = 8;
pub const SDL_PEN_INPUT_BUTTON_4: u32 = 16;
pub const SDL_PEN_INPUT_BUTTON_5: u32 = 32;
pub const SDL_PEN_INPUT_ERASER_TIP: u32 = 1073741824;
pub const SDL_GLOB_CASEINSENSITIVE: u32 = 1;
pub const SDL_GPU_TEXTUREUSAGE_SAMPLER: u32 = 1;
pub const SDL_GPU_TEXTUREUSAGE_COLOR_TARGET: u32 = 2;
pub const SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET: u32 = 4;
pub const SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ: u32 = 8;
pub const SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ: u32 = 16;
pub const SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE: u32 = 32;
pub const SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE: u32 = 64;
pub const SDL_GPU_BUFFERUSAGE_VERTEX: u32 = 1;
pub const SDL_GPU_BUFFERUSAGE_INDEX: u32 = 2;
pub const SDL_GPU_BUFFERUSAGE_INDIRECT: u32 = 4;
pub const SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ: u32 = 8;
pub const SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ: u32 = 16;
pub const SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE: u32 = 32;
pub const SDL_GPU_SHADERFORMAT_INVALID: u32 = 0;
pub const SDL_GPU_SHADERFORMAT_PRIVATE: u32 = 1;
pub const SDL_GPU_SHADERFORMAT_SPIRV: u32 = 2;
pub const SDL_GPU_SHADERFORMAT_DXBC: u32 = 4;
pub const SDL_GPU_SHADERFORMAT_DXIL: u32 = 8;
pub const SDL_GPU_SHADERFORMAT_MSL: u32 = 16;
pub const SDL_GPU_SHADERFORMAT_METALLIB: u32 = 32;
pub const SDL_GPU_COLORCOMPONENT_R: u32 = 1;
pub const SDL_GPU_COLORCOMPONENT_G: u32 = 2;
pub const SDL_GPU_COLORCOMPONENT_B: u32 = 4;
pub const SDL_GPU_COLORCOMPONENT_A: u32 = 8;
pub const SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN: &[u8; 32] =
    b"SDL.gpu.device.create.debugmode\0";
pub const SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN: &[u8; 37] =
    b"SDL.gpu.device.create.preferlowpower\0";
pub const SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING: &[u8; 27] = b"SDL.gpu.device.create.name\0";
pub const SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN: &[u8; 38] =
    b"SDL.gpu.device.create.shaders.private\0";
pub const SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN: &[u8; 36] =
    b"SDL.gpu.device.create.shaders.spirv\0";
pub const SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN: &[u8; 35] =
    b"SDL.gpu.device.create.shaders.dxbc\0";
pub const SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN: &[u8; 35] =
    b"SDL.gpu.device.create.shaders.dxil\0";
pub const SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN: &[u8; 34] =
    b"SDL.gpu.device.create.shaders.msl\0";
pub const SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN: &[u8; 39] =
    b"SDL.gpu.device.create.shaders.metallib\0";
pub const SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING: &[u8; 37] =
    b"SDL.gpu.device.create.d3d12.semantic\0";
pub const SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING: &[u8; 36] =
    b"SDL.gpu.computepipeline.create.name\0";
pub const SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING: &[u8; 37] =
    b"SDL.gpu.graphicspipeline.create.name\0";
pub const SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING: &[u8; 28] = b"SDL.gpu.sampler.create.name\0";
pub const SDL_PROP_GPU_SHADER_CREATE_NAME_STRING: &[u8; 27] = b"SDL.gpu.shader.create.name\0";
pub const SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT: &[u8; 37] =
    b"SDL.gpu.texture.create.d3d12.clear.r\0";
pub const SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT: &[u8; 37] =
    b"SDL.gpu.texture.create.d3d12.clear.g\0";
pub const SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT: &[u8; 37] =
    b"SDL.gpu.texture.create.d3d12.clear.b\0";
pub const SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT: &[u8; 37] =
    b"SDL.gpu.texture.create.d3d12.clear.a\0";
pub const SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT: &[u8; 41] =
    b"SDL.gpu.texture.create.d3d12.clear.depth\0";
pub const SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_UINT8: &[u8; 43] =
    b"SDL.gpu.texture.create.d3d12.clear.stencil\0";
pub const SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING: &[u8; 28] = b"SDL.gpu.texture.create.name\0";
pub const SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING: &[u8; 27] = b"SDL.gpu.buffer.create.name\0";
pub const SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING: &[u8; 35] =
    b"SDL.gpu.transferbuffer.create.name\0";
pub const SDL_HAPTIC_CONSTANT: u32 = 1;
pub const SDL_HAPTIC_SINE: u32 = 2;
pub const SDL_HAPTIC_SQUARE: u32 = 4;
pub const SDL_HAPTIC_TRIANGLE: u32 = 8;
pub const SDL_HAPTIC_SAWTOOTHUP: u32 = 16;
pub const SDL_HAPTIC_SAWTOOTHDOWN: u32 = 32;
pub const SDL_HAPTIC_RAMP: u32 = 64;
pub const SDL_HAPTIC_SPRING: u32 = 128;
pub const SDL_HAPTIC_DAMPER: u32 = 256;
pub const SDL_HAPTIC_INERTIA: u32 = 512;
pub const SDL_HAPTIC_FRICTION: u32 = 1024;
pub const SDL_HAPTIC_LEFTRIGHT: u32 = 2048;
pub const SDL_HAPTIC_RESERVED1: u32 = 4096;
pub const SDL_HAPTIC_RESERVED2: u32 = 8192;
pub const SDL_HAPTIC_RESERVED3: u32 = 16384;
pub const SDL_HAPTIC_CUSTOM: u32 = 32768;
pub const SDL_HAPTIC_GAIN: u32 = 65536;
pub const SDL_HAPTIC_AUTOCENTER: u32 = 131072;
pub const SDL_HAPTIC_STATUS: u32 = 262144;
pub const SDL_HAPTIC_PAUSE: u32 = 524288;
pub const SDL_HAPTIC_POLAR: u32 = 0;
pub const SDL_HAPTIC_CARTESIAN: u32 = 1;
pub const SDL_HAPTIC_SPHERICAL: u32 = 2;
pub const SDL_HAPTIC_STEERING_AXIS: u32 = 3;
pub const SDL_HAPTIC_INFINITY: u32 = 4294967295;
pub const SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED: &[u8; 32] = b"SDL_ALLOW_ALT_TAB_WHILE_GRABBED\0";
pub const SDL_HINT_ANDROID_ALLOW_RECREATE_ACTIVITY: &[u8; 36] =
    b"SDL_ANDROID_ALLOW_RECREATE_ACTIVITY\0";
pub const SDL_HINT_ANDROID_BLOCK_ON_PAUSE: &[u8; 27] = b"SDL_ANDROID_BLOCK_ON_PAUSE\0";
pub const SDL_HINT_ANDROID_LOW_LATENCY_AUDIO: &[u8; 30] = b"SDL_ANDROID_LOW_LATENCY_AUDIO\0";
pub const SDL_HINT_ANDROID_TRAP_BACK_BUTTON: &[u8; 29] = b"SDL_ANDROID_TRAP_BACK_BUTTON\0";
pub const SDL_HINT_APP_ID: &[u8; 11] = b"SDL_APP_ID\0";
pub const SDL_HINT_APP_NAME: &[u8; 13] = b"SDL_APP_NAME\0";
pub const SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS: &[u8; 34] =
    b"SDL_APPLE_TV_CONTROLLER_UI_EVENTS\0";
pub const SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION: &[u8; 35] =
    b"SDL_APPLE_TV_REMOTE_ALLOW_ROTATION\0";
pub const SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE: &[u8; 30] = b"SDL_AUDIO_ALSA_DEFAULT_DEVICE\0";
pub const SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE: &[u8; 39] =
    b"SDL_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE\0";
pub const SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE: &[u8; 40] =
    b"SDL_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE\0";
pub const SDL_HINT_AUDIO_CATEGORY: &[u8; 19] = b"SDL_AUDIO_CATEGORY\0";
pub const SDL_HINT_AUDIO_CHANNELS: &[u8; 19] = b"SDL_AUDIO_CHANNELS\0";
pub const SDL_HINT_AUDIO_DEVICE_APP_ICON_NAME: &[u8; 31] = b"SDL_AUDIO_DEVICE_APP_ICON_NAME\0";
pub const SDL_HINT_AUDIO_DEVICE_SAMPLE_FRAMES: &[u8; 31] = b"SDL_AUDIO_DEVICE_SAMPLE_FRAMES\0";
pub const SDL_HINT_AUDIO_DEVICE_STREAM_NAME: &[u8; 29] = b"SDL_AUDIO_DEVICE_STREAM_NAME\0";
pub const SDL_HINT_AUDIO_DEVICE_STREAM_ROLE: &[u8; 29] = b"SDL_AUDIO_DEVICE_STREAM_ROLE\0";
pub const SDL_HINT_AUDIO_DISK_INPUT_FILE: &[u8; 26] = b"SDL_AUDIO_DISK_INPUT_FILE\0";
pub const SDL_HINT_AUDIO_DISK_OUTPUT_FILE: &[u8; 27] = b"SDL_AUDIO_DISK_OUTPUT_FILE\0";
pub const SDL_HINT_AUDIO_DISK_TIMESCALE: &[u8; 25] = b"SDL_AUDIO_DISK_TIMESCALE\0";
pub const SDL_HINT_AUDIO_DRIVER: &[u8; 17] = b"SDL_AUDIO_DRIVER\0";
pub const SDL_HINT_AUDIO_DUMMY_TIMESCALE: &[u8; 26] = b"SDL_AUDIO_DUMMY_TIMESCALE\0";
pub const SDL_HINT_AUDIO_FORMAT: &[u8; 17] = b"SDL_AUDIO_FORMAT\0";
pub const SDL_HINT_AUDIO_FREQUENCY: &[u8; 20] = b"SDL_AUDIO_FREQUENCY\0";
pub const SDL_HINT_AUDIO_INCLUDE_MONITORS: &[u8; 27] = b"SDL_AUDIO_INCLUDE_MONITORS\0";
pub const SDL_HINT_AUTO_UPDATE_JOYSTICKS: &[u8; 26] = b"SDL_AUTO_UPDATE_JOYSTICKS\0";
pub const SDL_HINT_AUTO_UPDATE_SENSORS: &[u8; 24] = b"SDL_AUTO_UPDATE_SENSORS\0";
pub const SDL_HINT_BMP_SAVE_LEGACY_FORMAT: &[u8; 27] = b"SDL_BMP_SAVE_LEGACY_FORMAT\0";
pub const SDL_HINT_CAMERA_DRIVER: &[u8; 18] = b"SDL_CAMERA_DRIVER\0";
pub const SDL_HINT_CPU_FEATURE_MASK: &[u8; 21] = b"SDL_CPU_FEATURE_MASK\0";
pub const SDL_HINT_JOYSTICK_DIRECTINPUT: &[u8; 25] = b"SDL_JOYSTICK_DIRECTINPUT\0";
pub const SDL_HINT_FILE_DIALOG_DRIVER: &[u8; 23] = b"SDL_FILE_DIALOG_DRIVER\0";
pub const SDL_HINT_DISPLAY_USABLE_BOUNDS: &[u8; 26] = b"SDL_DISPLAY_USABLE_BOUNDS\0";
pub const SDL_HINT_EMSCRIPTEN_ASYNCIFY: &[u8; 24] = b"SDL_EMSCRIPTEN_ASYNCIFY\0";
pub const SDL_HINT_EMSCRIPTEN_CANVAS_SELECTOR: &[u8; 31] = b"SDL_EMSCRIPTEN_CANVAS_SELECTOR\0";
pub const SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT: &[u8; 32] = b"SDL_EMSCRIPTEN_KEYBOARD_ELEMENT\0";
pub const SDL_HINT_ENABLE_SCREEN_KEYBOARD: &[u8; 27] = b"SDL_ENABLE_SCREEN_KEYBOARD\0";
pub const SDL_HINT_EVDEV_DEVICES: &[u8; 18] = b"SDL_EVDEV_DEVICES\0";
pub const SDL_HINT_EVENT_LOGGING: &[u8; 18] = b"SDL_EVENT_LOGGING\0";
pub const SDL_HINT_FORCE_RAISEWINDOW: &[u8; 22] = b"SDL_FORCE_RAISEWINDOW\0";
pub const SDL_HINT_FRAMEBUFFER_ACCELERATION: &[u8; 29] = b"SDL_FRAMEBUFFER_ACCELERATION\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG: &[u8; 25] = b"SDL_GAMECONTROLLERCONFIG\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG_FILE: &[u8; 30] = b"SDL_GAMECONTROLLERCONFIG_FILE\0";
pub const SDL_HINT_GAMECONTROLLERTYPE: &[u8; 23] = b"SDL_GAMECONTROLLERTYPE\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES: &[u8; 34] =
    b"SDL_GAMECONTROLLER_IGNORE_DEVICES\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT: &[u8; 41] =
    b"SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT\0";
pub const SDL_HINT_GAMECONTROLLER_SENSOR_FUSION: &[u8; 33] = b"SDL_GAMECONTROLLER_SENSOR_FUSION\0";
pub const SDL_HINT_GDK_TEXTINPUT_DEFAULT_TEXT: &[u8; 31] = b"SDL_GDK_TEXTINPUT_DEFAULT_TEXT\0";
pub const SDL_HINT_GDK_TEXTINPUT_DESCRIPTION: &[u8; 30] = b"SDL_GDK_TEXTINPUT_DESCRIPTION\0";
pub const SDL_HINT_GDK_TEXTINPUT_MAX_LENGTH: &[u8; 29] = b"SDL_GDK_TEXTINPUT_MAX_LENGTH\0";
pub const SDL_HINT_GDK_TEXTINPUT_SCOPE: &[u8; 24] = b"SDL_GDK_TEXTINPUT_SCOPE\0";
pub const SDL_HINT_GDK_TEXTINPUT_TITLE: &[u8; 24] = b"SDL_GDK_TEXTINPUT_TITLE\0";
pub const SDL_HINT_HIDAPI_LIBUSB: &[u8; 18] = b"SDL_HIDAPI_LIBUSB\0";
pub const SDL_HINT_HIDAPI_LIBUSB_WHITELIST: &[u8; 28] = b"SDL_HIDAPI_LIBUSB_WHITELIST\0";
pub const SDL_HINT_HIDAPI_UDEV: &[u8; 16] = b"SDL_HIDAPI_UDEV\0";
pub const SDL_HINT_GPU_DRIVER: &[u8; 15] = b"SDL_GPU_DRIVER\0";
pub const SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS: &[u8; 38] =
    b"SDL_HIDAPI_ENUMERATE_ONLY_CONTROLLERS\0";
pub const SDL_HINT_HIDAPI_IGNORE_DEVICES: &[u8; 26] = b"SDL_HIDAPI_IGNORE_DEVICES\0";
pub const SDL_HINT_IME_IMPLEMENTED_UI: &[u8; 23] = b"SDL_IME_IMPLEMENTED_UI\0";
pub const SDL_HINT_IOS_HIDE_HOME_INDICATOR: &[u8; 28] = b"SDL_IOS_HIDE_HOME_INDICATOR\0";
pub const SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS: &[u8; 37] =
    b"SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS\0";
pub const SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES: &[u8; 33] = b"SDL_JOYSTICK_ARCADESTICK_DEVICES\0";
pub const SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED: &[u8; 42] =
    b"SDL_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED\0";
pub const SDL_HINT_JOYSTICK_BLACKLIST_DEVICES: &[u8; 31] = b"SDL_JOYSTICK_BLACKLIST_DEVICES\0";
pub const SDL_HINT_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED: &[u8; 40] =
    b"SDL_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED\0";
pub const SDL_HINT_JOYSTICK_DEVICE: &[u8; 20] = b"SDL_JOYSTICK_DEVICE\0";
pub const SDL_HINT_JOYSTICK_ENHANCED_REPORTS: &[u8; 30] = b"SDL_JOYSTICK_ENHANCED_REPORTS\0";
pub const SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES: &[u8; 33] = b"SDL_JOYSTICK_FLIGHTSTICK_DEVICES\0";
pub const SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED: &[u8; 42] =
    b"SDL_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED\0";
pub const SDL_HINT_JOYSTICK_GAMEINPUT: &[u8; 23] = b"SDL_JOYSTICK_GAMEINPUT\0";
pub const SDL_HINT_JOYSTICK_GAMECUBE_DEVICES: &[u8; 30] = b"SDL_JOYSTICK_GAMECUBE_DEVICES\0";
pub const SDL_HINT_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED: &[u8; 39] =
    b"SDL_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI: &[u8; 20] = b"SDL_JOYSTICK_HIDAPI\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_COMBINE_JOY_CONS: &[u8; 37] =
    b"SDL_JOYSTICK_HIDAPI_COMBINE_JOY_CONS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE: &[u8; 29] = b"SDL_JOYSTICK_HIDAPI_GAMECUBE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE: &[u8; 42] =
    b"SDL_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS: &[u8; 29] = b"SDL_JOYSTICK_HIDAPI_JOY_CONS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_JOYCON_HOME_LED: &[u8; 36] =
    b"SDL_JOYSTICK_HIDAPI_JOYCON_HOME_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_LUNA: &[u8; 25] = b"SDL_JOYSTICK_HIDAPI_LUNA\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_NINTENDO_CLASSIC: &[u8; 37] =
    b"SDL_JOYSTICK_HIDAPI_NINTENDO_CLASSIC\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS3: &[u8; 24] = b"SDL_JOYSTICK_HIDAPI_PS3\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER: &[u8; 39] =
    b"SDL_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4: &[u8; 24] = b"SDL_JOYSTICK_HIDAPI_PS4\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL: &[u8; 40] =
    b"SDL_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS5: &[u8; 24] = b"SDL_JOYSTICK_HIDAPI_PS5\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS5_PLAYER_LED: &[u8; 35] =
    b"SDL_JOYSTICK_HIDAPI_PS5_PLAYER_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SHIELD: &[u8; 27] = b"SDL_JOYSTICK_HIDAPI_SHIELD\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STADIA: &[u8; 27] = b"SDL_JOYSTICK_HIDAPI_STADIA\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STEAM: &[u8; 26] = b"SDL_JOYSTICK_HIDAPI_STEAM\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STEAM_HOME_LED: &[u8; 35] =
    b"SDL_JOYSTICK_HIDAPI_STEAM_HOME_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STEAMDECK: &[u8; 30] = b"SDL_JOYSTICK_HIDAPI_STEAMDECK\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STEAM_HORI: &[u8; 31] = b"SDL_JOYSTICK_HIDAPI_STEAM_HORI\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH: &[u8; 27] = b"SDL_JOYSTICK_HIDAPI_SWITCH\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH_HOME_LED: &[u8; 36] =
    b"SDL_JOYSTICK_HIDAPI_SWITCH_HOME_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED: &[u8; 38] =
    b"SDL_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS: &[u8; 38] =
    b"SDL_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_WII: &[u8; 24] = b"SDL_JOYSTICK_HIDAPI_WII\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_WII_PLAYER_LED: &[u8; 35] =
    b"SDL_JOYSTICK_HIDAPI_WII_PLAYER_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX: &[u8; 25] = b"SDL_JOYSTICK_HIDAPI_XBOX\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX_360: &[u8; 29] = b"SDL_JOYSTICK_HIDAPI_XBOX_360\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED: &[u8; 40] =
    b"SDL_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_WIRELESS: &[u8; 38] =
    b"SDL_JOYSTICK_HIDAPI_XBOX_360_WIRELESS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE: &[u8; 29] = b"SDL_JOYSTICK_HIDAPI_XBOX_ONE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED: &[u8; 38] =
    b"SDL_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED\0";
pub const SDL_HINT_JOYSTICK_IOKIT: &[u8; 19] = b"SDL_JOYSTICK_IOKIT\0";
pub const SDL_HINT_JOYSTICK_LINUX_CLASSIC: &[u8; 27] = b"SDL_JOYSTICK_LINUX_CLASSIC\0";
pub const SDL_HINT_JOYSTICK_LINUX_DEADZONES: &[u8; 29] = b"SDL_JOYSTICK_LINUX_DEADZONES\0";
pub const SDL_HINT_JOYSTICK_LINUX_DIGITAL_HATS: &[u8; 32] = b"SDL_JOYSTICK_LINUX_DIGITAL_HATS\0";
pub const SDL_HINT_JOYSTICK_LINUX_HAT_DEADZONES: &[u8; 33] = b"SDL_JOYSTICK_LINUX_HAT_DEADZONES\0";
pub const SDL_HINT_JOYSTICK_MFI: &[u8; 17] = b"SDL_JOYSTICK_MFI\0";
pub const SDL_HINT_JOYSTICK_RAWINPUT: &[u8; 22] = b"SDL_JOYSTICK_RAWINPUT\0";
pub const SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT: &[u8; 39] =
    b"SDL_JOYSTICK_RAWINPUT_CORRELATE_XINPUT\0";
pub const SDL_HINT_JOYSTICK_ROG_CHAKRAM: &[u8; 25] = b"SDL_JOYSTICK_ROG_CHAKRAM\0";
pub const SDL_HINT_JOYSTICK_THREAD: &[u8; 20] = b"SDL_JOYSTICK_THREAD\0";
pub const SDL_HINT_JOYSTICK_THROTTLE_DEVICES: &[u8; 30] = b"SDL_JOYSTICK_THROTTLE_DEVICES\0";
pub const SDL_HINT_JOYSTICK_THROTTLE_DEVICES_EXCLUDED: &[u8; 39] =
    b"SDL_JOYSTICK_THROTTLE_DEVICES_EXCLUDED\0";
pub const SDL_HINT_JOYSTICK_WGI: &[u8; 17] = b"SDL_JOYSTICK_WGI\0";
pub const SDL_HINT_JOYSTICK_WHEEL_DEVICES: &[u8; 27] = b"SDL_JOYSTICK_WHEEL_DEVICES\0";
pub const SDL_HINT_JOYSTICK_WHEEL_DEVICES_EXCLUDED: &[u8; 36] =
    b"SDL_JOYSTICK_WHEEL_DEVICES_EXCLUDED\0";
pub const SDL_HINT_JOYSTICK_ZERO_CENTERED_DEVICES: &[u8; 35] =
    b"SDL_JOYSTICK_ZERO_CENTERED_DEVICES\0";
pub const SDL_HINT_KEYCODE_OPTIONS: &[u8; 20] = b"SDL_KEYCODE_OPTIONS\0";
pub const SDL_HINT_KMSDRM_DEVICE_INDEX: &[u8; 24] = b"SDL_KMSDRM_DEVICE_INDEX\0";
pub const SDL_HINT_KMSDRM_REQUIRE_DRM_MASTER: &[u8; 30] = b"SDL_KMSDRM_REQUIRE_DRM_MASTER\0";
pub const SDL_HINT_LOGGING: &[u8; 12] = b"SDL_LOGGING\0";
pub const SDL_HINT_MAC_BACKGROUND_APP: &[u8; 23] = b"SDL_MAC_BACKGROUND_APP\0";
pub const SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK: &[u8; 39] =
    b"SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK\0";
pub const SDL_HINT_MAC_OPENGL_ASYNC_DISPATCH: &[u8; 30] = b"SDL_MAC_OPENGL_ASYNC_DISPATCH\0";
pub const SDL_HINT_MAC_OPTION_AS_ALT: &[u8; 22] = b"SDL_MAC_OPTION_AS_ALT\0";
pub const SDL_HINT_MAC_SCROLL_MOMENTUM: &[u8; 24] = b"SDL_MAC_SCROLL_MOMENTUM\0";
pub const SDL_HINT_MAIN_CALLBACK_RATE: &[u8; 23] = b"SDL_MAIN_CALLBACK_RATE\0";
pub const SDL_HINT_MOUSE_AUTO_CAPTURE: &[u8; 23] = b"SDL_MOUSE_AUTO_CAPTURE\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS: &[u8; 30] = b"SDL_MOUSE_DOUBLE_CLICK_RADIUS\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_TIME: &[u8; 28] = b"SDL_MOUSE_DOUBLE_CLICK_TIME\0";
pub const SDL_HINT_MOUSE_DEFAULT_SYSTEM_CURSOR: &[u8; 32] = b"SDL_MOUSE_DEFAULT_SYSTEM_CURSOR\0";
pub const SDL_HINT_MOUSE_EMULATE_WARP_WITH_RELATIVE: &[u8; 37] =
    b"SDL_MOUSE_EMULATE_WARP_WITH_RELATIVE\0";
pub const SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH: &[u8; 29] = b"SDL_MOUSE_FOCUS_CLICKTHROUGH\0";
pub const SDL_HINT_MOUSE_NORMAL_SPEED_SCALE: &[u8; 29] = b"SDL_MOUSE_NORMAL_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_MODE_CENTER: &[u8; 31] = b"SDL_MOUSE_RELATIVE_MODE_CENTER\0";
pub const SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE: &[u8; 31] = b"SDL_MOUSE_RELATIVE_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_SYSTEM_SCALE: &[u8; 32] = b"SDL_MOUSE_RELATIVE_SYSTEM_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_WARP_MOTION: &[u8; 31] = b"SDL_MOUSE_RELATIVE_WARP_MOTION\0";
pub const SDL_HINT_MOUSE_RELATIVE_CURSOR_VISIBLE: &[u8; 34] =
    b"SDL_MOUSE_RELATIVE_CURSOR_VISIBLE\0";
pub const SDL_HINT_MOUSE_TOUCH_EVENTS: &[u8; 23] = b"SDL_MOUSE_TOUCH_EVENTS\0";
pub const SDL_HINT_MUTE_CONSOLE_KEYBOARD: &[u8; 26] = b"SDL_MUTE_CONSOLE_KEYBOARD\0";
pub const SDL_HINT_NO_SIGNAL_HANDLERS: &[u8; 23] = b"SDL_NO_SIGNAL_HANDLERS\0";
pub const SDL_HINT_OPENGL_LIBRARY: &[u8; 19] = b"SDL_OPENGL_LIBRARY\0";
pub const SDL_HINT_EGL_LIBRARY: &[u8; 16] = b"SDL_EGL_LIBRARY\0";
pub const SDL_HINT_OPENGL_ES_DRIVER: &[u8; 21] = b"SDL_OPENGL_ES_DRIVER\0";
pub const SDL_HINT_OPENVR_LIBRARY: &[u8; 19] = b"SDL_OPENVR_LIBRARY\0";
pub const SDL_HINT_ORIENTATIONS: &[u8; 17] = b"SDL_ORIENTATIONS\0";
pub const SDL_HINT_POLL_SENTINEL: &[u8; 18] = b"SDL_POLL_SENTINEL\0";
pub const SDL_HINT_PREFERRED_LOCALES: &[u8; 22] = b"SDL_PREFERRED_LOCALES\0";
pub const SDL_HINT_QUIT_ON_LAST_WINDOW_CLOSE: &[u8; 30] = b"SDL_QUIT_ON_LAST_WINDOW_CLOSE\0";
pub const SDL_HINT_RENDER_DIRECT3D_THREADSAFE: &[u8; 31] = b"SDL_RENDER_DIRECT3D_THREADSAFE\0";
pub const SDL_HINT_RENDER_DIRECT3D11_DEBUG: &[u8; 28] = b"SDL_RENDER_DIRECT3D11_DEBUG\0";
pub const SDL_HINT_RENDER_VULKAN_DEBUG: &[u8; 24] = b"SDL_RENDER_VULKAN_DEBUG\0";
pub const SDL_HINT_RENDER_GPU_DEBUG: &[u8; 21] = b"SDL_RENDER_GPU_DEBUG\0";
pub const SDL_HINT_RENDER_GPU_LOW_POWER: &[u8; 25] = b"SDL_RENDER_GPU_LOW_POWER\0";
pub const SDL_HINT_RENDER_DRIVER: &[u8; 18] = b"SDL_RENDER_DRIVER\0";
pub const SDL_HINT_RENDER_LINE_METHOD: &[u8; 23] = b"SDL_RENDER_LINE_METHOD\0";
pub const SDL_HINT_RENDER_METAL_PREFER_LOW_POWER_DEVICE: &[u8; 41] =
    b"SDL_RENDER_METAL_PREFER_LOW_POWER_DEVICE\0";
pub const SDL_HINT_RENDER_VSYNC: &[u8; 17] = b"SDL_RENDER_VSYNC\0";
pub const SDL_HINT_RETURN_KEY_HIDES_IME: &[u8; 25] = b"SDL_RETURN_KEY_HIDES_IME\0";
pub const SDL_HINT_ROG_GAMEPAD_MICE: &[u8; 21] = b"SDL_ROG_GAMEPAD_MICE\0";
pub const SDL_HINT_ROG_GAMEPAD_MICE_EXCLUDED: &[u8; 30] = b"SDL_ROG_GAMEPAD_MICE_EXCLUDED\0";
pub const SDL_HINT_RPI_VIDEO_LAYER: &[u8; 20] = b"SDL_RPI_VIDEO_LAYER\0";
pub const SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME: &[u8; 38] =
    b"SDL_SCREENSAVER_INHIBIT_ACTIVITY_NAME\0";
pub const SDL_HINT_SHUTDOWN_DBUS_ON_QUIT: &[u8; 26] = b"SDL_SHUTDOWN_DBUS_ON_QUIT\0";
pub const SDL_HINT_STORAGE_TITLE_DRIVER: &[u8; 25] = b"SDL_STORAGE_TITLE_DRIVER\0";
pub const SDL_HINT_STORAGE_USER_DRIVER: &[u8; 24] = b"SDL_STORAGE_USER_DRIVER\0";
pub const SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL: &[u8; 40] =
    b"SDL_THREAD_FORCE_REALTIME_TIME_CRITICAL\0";
pub const SDL_HINT_THREAD_PRIORITY_POLICY: &[u8; 27] = b"SDL_THREAD_PRIORITY_POLICY\0";
pub const SDL_HINT_TIMER_RESOLUTION: &[u8; 21] = b"SDL_TIMER_RESOLUTION\0";
pub const SDL_HINT_TOUCH_MOUSE_EVENTS: &[u8; 23] = b"SDL_TOUCH_MOUSE_EVENTS\0";
pub const SDL_HINT_TRACKPAD_IS_TOUCH_ONLY: &[u8; 27] = b"SDL_TRACKPAD_IS_TOUCH_ONLY\0";
pub const SDL_HINT_TV_REMOTE_AS_JOYSTICK: &[u8; 26] = b"SDL_TV_REMOTE_AS_JOYSTICK\0";
pub const SDL_HINT_VIDEO_ALLOW_SCREENSAVER: &[u8; 28] = b"SDL_VIDEO_ALLOW_SCREENSAVER\0";
pub const SDL_HINT_VIDEO_DISPLAY_PRIORITY: &[u8; 27] = b"SDL_VIDEO_DISPLAY_PRIORITY\0";
pub const SDL_HINT_VIDEO_DOUBLE_BUFFER: &[u8; 24] = b"SDL_VIDEO_DOUBLE_BUFFER\0";
pub const SDL_HINT_VIDEO_DRIVER: &[u8; 17] = b"SDL_VIDEO_DRIVER\0";
pub const SDL_HINT_VIDEO_DUMMY_SAVE_FRAMES: &[u8; 28] = b"SDL_VIDEO_DUMMY_SAVE_FRAMES\0";
pub const SDL_HINT_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK: &[u8; 40] =
    b"SDL_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK\0";
pub const SDL_HINT_VIDEO_FORCE_EGL: &[u8; 20] = b"SDL_VIDEO_FORCE_EGL\0";
pub const SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES: &[u8; 32] = b"SDL_VIDEO_MAC_FULLSCREEN_SPACES\0";
pub const SDL_HINT_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY: &[u8; 41] =
    b"SDL_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY\0";
pub const SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS: &[u8; 33] = b"SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS\0";
pub const SDL_HINT_VIDEO_OFFSCREEN_SAVE_FRAMES: &[u8; 32] = b"SDL_VIDEO_OFFSCREEN_SAVE_FRAMES\0";
pub const SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS: &[u8; 33] = b"SDL_VIDEO_SYNC_WINDOW_OPERATIONS\0";
pub const SDL_HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR: &[u8; 33] = b"SDL_VIDEO_WAYLAND_ALLOW_LIBDECOR\0";
pub const SDL_HINT_VIDEO_WAYLAND_MODE_EMULATION: &[u8; 33] = b"SDL_VIDEO_WAYLAND_MODE_EMULATION\0";
pub const SDL_HINT_VIDEO_WAYLAND_MODE_SCALING: &[u8; 31] = b"SDL_VIDEO_WAYLAND_MODE_SCALING\0";
pub const SDL_HINT_VIDEO_WAYLAND_PREFER_LIBDECOR: &[u8; 34] =
    b"SDL_VIDEO_WAYLAND_PREFER_LIBDECOR\0";
pub const SDL_HINT_VIDEO_WAYLAND_SCALE_TO_DISPLAY: &[u8; 35] =
    b"SDL_VIDEO_WAYLAND_SCALE_TO_DISPLAY\0";
pub const SDL_HINT_VIDEO_WIN_D3DCOMPILER: &[u8; 26] = b"SDL_VIDEO_WIN_D3DCOMPILER\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR: &[u8; 39] =
    b"SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_PING: &[u8; 26] = b"SDL_VIDEO_X11_NET_WM_PING\0";
pub const SDL_HINT_VIDEO_X11_NODIRECTCOLOR: &[u8; 28] = b"SDL_VIDEO_X11_NODIRECTCOLOR\0";
pub const SDL_HINT_VIDEO_X11_SCALING_FACTOR: &[u8; 29] = b"SDL_VIDEO_X11_SCALING_FACTOR\0";
pub const SDL_HINT_VIDEO_X11_VISUALID: &[u8; 23] = b"SDL_VIDEO_X11_VISUALID\0";
pub const SDL_HINT_VIDEO_X11_WINDOW_VISUALID: &[u8; 30] = b"SDL_VIDEO_X11_WINDOW_VISUALID\0";
pub const SDL_HINT_VIDEO_X11_XRANDR: &[u8; 21] = b"SDL_VIDEO_X11_XRANDR\0";
pub const SDL_HINT_VITA_ENABLE_BACK_TOUCH: &[u8; 27] = b"SDL_VITA_ENABLE_BACK_TOUCH\0";
pub const SDL_HINT_VITA_ENABLE_FRONT_TOUCH: &[u8; 28] = b"SDL_VITA_ENABLE_FRONT_TOUCH\0";
pub const SDL_HINT_VITA_MODULE_PATH: &[u8; 21] = b"SDL_VITA_MODULE_PATH\0";
pub const SDL_HINT_VITA_PVR_INIT: &[u8; 18] = b"SDL_VITA_PVR_INIT\0";
pub const SDL_HINT_VITA_RESOLUTION: &[u8; 20] = b"SDL_VITA_RESOLUTION\0";
pub const SDL_HINT_VITA_PVR_OPENGL: &[u8; 20] = b"SDL_VITA_PVR_OPENGL\0";
pub const SDL_HINT_VITA_TOUCH_MOUSE_DEVICE: &[u8; 28] = b"SDL_VITA_TOUCH_MOUSE_DEVICE\0";
pub const SDL_HINT_VULKAN_DISPLAY: &[u8; 19] = b"SDL_VULKAN_DISPLAY\0";
pub const SDL_HINT_VULKAN_LIBRARY: &[u8; 19] = b"SDL_VULKAN_LIBRARY\0";
pub const SDL_HINT_WAVE_FACT_CHUNK: &[u8; 20] = b"SDL_WAVE_FACT_CHUNK\0";
pub const SDL_HINT_WAVE_CHUNK_LIMIT: &[u8; 21] = b"SDL_WAVE_CHUNK_LIMIT\0";
pub const SDL_HINT_WAVE_RIFF_CHUNK_SIZE: &[u8; 25] = b"SDL_WAVE_RIFF_CHUNK_SIZE\0";
pub const SDL_HINT_WAVE_TRUNCATION: &[u8; 20] = b"SDL_WAVE_TRUNCATION\0";
pub const SDL_HINT_WINDOW_ACTIVATE_WHEN_RAISED: &[u8; 32] = b"SDL_WINDOW_ACTIVATE_WHEN_RAISED\0";
pub const SDL_HINT_WINDOW_ACTIVATE_WHEN_SHOWN: &[u8; 31] = b"SDL_WINDOW_ACTIVATE_WHEN_SHOWN\0";
pub const SDL_HINT_WINDOW_ALLOW_TOPMOST: &[u8; 25] = b"SDL_WINDOW_ALLOW_TOPMOST\0";
pub const SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN: &[u8; 44] =
    b"SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN\0";
pub const SDL_HINT_WINDOWS_CLOSE_ON_ALT_F4: &[u8; 28] = b"SDL_WINDOWS_CLOSE_ON_ALT_F4\0";
pub const SDL_HINT_WINDOWS_ENABLE_MENU_MNEMONICS: &[u8; 34] =
    b"SDL_WINDOWS_ENABLE_MENU_MNEMONICS\0";
pub const SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP: &[u8; 31] = b"SDL_WINDOWS_ENABLE_MESSAGELOOP\0";
pub const SDL_HINT_WINDOWS_GAMEINPUT: &[u8; 22] = b"SDL_WINDOWS_GAMEINPUT\0";
pub const SDL_HINT_WINDOWS_RAW_KEYBOARD: &[u8; 25] = b"SDL_WINDOWS_RAW_KEYBOARD\0";
pub const SDL_HINT_WINDOWS_FORCE_SEMAPHORE_KERNEL: &[u8; 35] =
    b"SDL_WINDOWS_FORCE_SEMAPHORE_KERNEL\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON: &[u8; 29] = b"SDL_WINDOWS_INTRESOURCE_ICON\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL: &[u8; 35] =
    b"SDL_WINDOWS_INTRESOURCE_ICON_SMALL\0";
pub const SDL_HINT_WINDOWS_USE_D3D9EX: &[u8; 23] = b"SDL_WINDOWS_USE_D3D9EX\0";
pub const SDL_HINT_WINDOWS_ERASE_BACKGROUND_MODE: &[u8; 34] =
    b"SDL_WINDOWS_ERASE_BACKGROUND_MODE\0";
pub const SDL_HINT_X11_FORCE_OVERRIDE_REDIRECT: &[u8; 32] = b"SDL_X11_FORCE_OVERRIDE_REDIRECT\0";
pub const SDL_HINT_X11_WINDOW_TYPE: &[u8; 20] = b"SDL_X11_WINDOW_TYPE\0";
pub const SDL_HINT_X11_XCB_LIBRARY: &[u8; 20] = b"SDL_X11_XCB_LIBRARY\0";
pub const SDL_HINT_XINPUT_ENABLED: &[u8; 19] = b"SDL_XINPUT_ENABLED\0";
pub const SDL_HINT_ASSERT: &[u8; 11] = b"SDL_ASSERT\0";
pub const SDL_HINT_PEN_MOUSE_EVENTS: &[u8; 21] = b"SDL_PEN_MOUSE_EVENTS\0";
pub const SDL_HINT_PEN_TOUCH_EVENTS: &[u8; 21] = b"SDL_PEN_TOUCH_EVENTS\0";
pub const SDL_INIT_AUDIO: u32 = 16;
pub const SDL_INIT_VIDEO: u32 = 32;
pub const SDL_INIT_JOYSTICK: u32 = 512;
pub const SDL_INIT_HAPTIC: u32 = 4096;
pub const SDL_INIT_GAMEPAD: u32 = 8192;
pub const SDL_INIT_EVENTS: u32 = 16384;
pub const SDL_INIT_SENSOR: u32 = 32768;
pub const SDL_INIT_CAMERA: u32 = 65536;
pub const SDL_PROP_APP_METADATA_NAME_STRING: &[u8; 22] = b"SDL.app.metadata.name\0";
pub const SDL_PROP_APP_METADATA_VERSION_STRING: &[u8; 25] = b"SDL.app.metadata.version\0";
pub const SDL_PROP_APP_METADATA_IDENTIFIER_STRING: &[u8; 28] = b"SDL.app.metadata.identifier\0";
pub const SDL_PROP_APP_METADATA_CREATOR_STRING: &[u8; 25] = b"SDL.app.metadata.creator\0";
pub const SDL_PROP_APP_METADATA_COPYRIGHT_STRING: &[u8; 27] = b"SDL.app.metadata.copyright\0";
pub const SDL_PROP_APP_METADATA_URL_STRING: &[u8; 21] = b"SDL.app.metadata.url\0";
pub const SDL_PROP_APP_METADATA_TYPE_STRING: &[u8; 22] = b"SDL.app.metadata.type\0";
pub const SDL_MESSAGEBOX_ERROR: u32 = 16;
pub const SDL_MESSAGEBOX_WARNING: u32 = 32;
pub const SDL_MESSAGEBOX_INFORMATION: u32 = 64;
pub const SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT: u32 = 128;
pub const SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT: u32 = 256;
pub const SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT: u32 = 1;
pub const SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT: u32 = 2;
pub const SDL_PROP_PROCESS_CREATE_ARGS_POINTER: &[u8; 24] = b"SDL.process.create.args\0";
pub const SDL_PROP_PROCESS_CREATE_ENVIRONMENT_POINTER: &[u8; 31] =
    b"SDL.process.create.environment\0";
pub const SDL_PROP_PROCESS_CREATE_STDIN_NUMBER: &[u8; 32] = b"SDL.process.create.stdin_option\0";
pub const SDL_PROP_PROCESS_CREATE_STDIN_POINTER: &[u8; 32] = b"SDL.process.create.stdin_source\0";
pub const SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER: &[u8; 33] = b"SDL.process.create.stdout_option\0";
pub const SDL_PROP_PROCESS_CREATE_STDOUT_POINTER: &[u8; 33] = b"SDL.process.create.stdout_source\0";
pub const SDL_PROP_PROCESS_CREATE_STDERR_NUMBER: &[u8; 33] = b"SDL.process.create.stderr_option\0";
pub const SDL_PROP_PROCESS_CREATE_STDERR_POINTER: &[u8; 33] = b"SDL.process.create.stderr_source\0";
pub const SDL_PROP_PROCESS_CREATE_STDERR_TO_STDOUT_BOOLEAN: &[u8; 36] =
    b"SDL.process.create.stderr_to_stdout\0";
pub const SDL_PROP_PROCESS_CREATE_BACKGROUND_BOOLEAN: &[u8; 30] =
    b"SDL.process.create.background\0";
pub const SDL_PROP_PROCESS_PID_NUMBER: &[u8; 16] = b"SDL.process.pid\0";
pub const SDL_PROP_PROCESS_STDIN_POINTER: &[u8; 18] = b"SDL.process.stdin\0";
pub const SDL_PROP_PROCESS_STDOUT_POINTER: &[u8; 19] = b"SDL.process.stdout\0";
pub const SDL_PROP_PROCESS_STDERR_POINTER: &[u8; 19] = b"SDL.process.stderr\0";
pub const SDL_PROP_PROCESS_BACKGROUND_BOOLEAN: &[u8; 23] = b"SDL.process.background\0";
pub const SDL_SOFTWARE_RENDERER: &[u8; 9] = b"software\0";
pub const SDL_PROP_RENDERER_CREATE_NAME_STRING: &[u8; 25] = b"SDL.renderer.create.name\0";
pub const SDL_PROP_RENDERER_CREATE_WINDOW_POINTER: &[u8; 27] = b"SDL.renderer.create.window\0";
pub const SDL_PROP_RENDERER_CREATE_SURFACE_POINTER: &[u8; 28] = b"SDL.renderer.create.surface\0";
pub const SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER: &[u8; 38] =
    b"SDL.renderer.create.output_colorspace\0";
pub const SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER: &[u8; 34] =
    b"SDL.renderer.create.present_vsync\0";
pub const SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER: &[u8; 36] =
    b"SDL.renderer.create.vulkan.instance\0";
pub const SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER: &[u8; 35] =
    b"SDL.renderer.create.vulkan.surface\0";
pub const SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER: &[u8; 43] =
    b"SDL.renderer.create.vulkan.physical_device\0";
pub const SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER: &[u8; 34] =
    b"SDL.renderer.create.vulkan.device\0";
pub const SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER: &[u8; 55] =
    b"SDL.renderer.create.vulkan.graphics_queue_family_index\0";
pub const SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER: &[u8; 54] =
    b"SDL.renderer.create.vulkan.present_queue_family_index\0";
pub const SDL_PROP_RENDERER_NAME_STRING: &[u8; 18] = b"SDL.renderer.name\0";
pub const SDL_PROP_RENDERER_WINDOW_POINTER: &[u8; 20] = b"SDL.renderer.window\0";
pub const SDL_PROP_RENDERER_SURFACE_POINTER: &[u8; 21] = b"SDL.renderer.surface\0";
pub const SDL_PROP_RENDERER_VSYNC_NUMBER: &[u8; 19] = b"SDL.renderer.vsync\0";
pub const SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER: &[u8; 30] = b"SDL.renderer.max_texture_size\0";
pub const SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER: &[u8; 29] = b"SDL.renderer.texture_formats\0";
pub const SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER: &[u8; 31] =
    b"SDL.renderer.output_colorspace\0";
pub const SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN: &[u8; 25] = b"SDL.renderer.HDR_enabled\0";
pub const SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT: &[u8; 29] = b"SDL.renderer.SDR_white_point\0";
pub const SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT: &[u8; 26] = b"SDL.renderer.HDR_headroom\0";
pub const SDL_PROP_RENDERER_D3D9_DEVICE_POINTER: &[u8; 25] = b"SDL.renderer.d3d9.device\0";
pub const SDL_PROP_RENDERER_D3D11_DEVICE_POINTER: &[u8; 26] = b"SDL.renderer.d3d11.device\0";
pub const SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER: &[u8; 30] = b"SDL.renderer.d3d11.swap_chain\0";
pub const SDL_PROP_RENDERER_D3D12_DEVICE_POINTER: &[u8; 26] = b"SDL.renderer.d3d12.device\0";
pub const SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER: &[u8; 30] = b"SDL.renderer.d3d12.swap_chain\0";
pub const SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER: &[u8; 33] =
    b"SDL.renderer.d3d12.command_queue\0";
pub const SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER: &[u8; 29] = b"SDL.renderer.vulkan.instance\0";
pub const SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER: &[u8; 28] = b"SDL.renderer.vulkan.surface\0";
pub const SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER: &[u8; 36] =
    b"SDL.renderer.vulkan.physical_device\0";
pub const SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER: &[u8; 27] = b"SDL.renderer.vulkan.device\0";
pub const SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER: &[u8; 48] =
    b"SDL.renderer.vulkan.graphics_queue_family_index\0";
pub const SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER: &[u8; 47] =
    b"SDL.renderer.vulkan.present_queue_family_index\0";
pub const SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER: &[u8; 42] =
    b"SDL.renderer.vulkan.swapchain_image_count\0";
pub const SDL_PROP_RENDERER_GPU_DEVICE_POINTER: &[u8; 24] = b"SDL.renderer.gpu.device\0";
pub const SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER: &[u8; 30] = b"SDL.texture.create.colorspace\0";
pub const SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER: &[u8; 26] = b"SDL.texture.create.format\0";
pub const SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER: &[u8; 26] = b"SDL.texture.create.access\0";
pub const SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER: &[u8; 25] = b"SDL.texture.create.width\0";
pub const SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER: &[u8; 26] = b"SDL.texture.create.height\0";
pub const SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT: &[u8; 35] =
    b"SDL.texture.create.SDR_white_point\0";
pub const SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT: &[u8; 32] =
    b"SDL.texture.create.HDR_headroom\0";
pub const SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER: &[u8; 33] =
    b"SDL.texture.create.d3d11.texture\0";
pub const SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER: &[u8; 35] =
    b"SDL.texture.create.d3d11.texture_u\0";
pub const SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER: &[u8; 35] =
    b"SDL.texture.create.d3d11.texture_v\0";
pub const SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER: &[u8; 33] =
    b"SDL.texture.create.d3d12.texture\0";
pub const SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER: &[u8; 35] =
    b"SDL.texture.create.d3d12.texture_u\0";
pub const SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER: &[u8; 35] =
    b"SDL.texture.create.d3d12.texture_v\0";
pub const SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER: &[u8; 37] =
    b"SDL.texture.create.metal.pixelbuffer\0";
pub const SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER: &[u8; 34] =
    b"SDL.texture.create.opengl.texture\0";
pub const SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER: &[u8; 37] =
    b"SDL.texture.create.opengl.texture_uv\0";
pub const SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER: &[u8; 36] =
    b"SDL.texture.create.opengl.texture_u\0";
pub const SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER: &[u8; 36] =
    b"SDL.texture.create.opengl.texture_v\0";
pub const SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER: &[u8; 37] =
    b"SDL.texture.create.opengles2.texture\0";
pub const SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER: &[u8; 40] =
    b"SDL.texture.create.opengles2.texture_uv\0";
pub const SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER: &[u8; 39] =
    b"SDL.texture.create.opengles2.texture_u\0";
pub const SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER: &[u8; 39] =
    b"SDL.texture.create.opengles2.texture_v\0";
pub const SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER: &[u8; 34] =
    b"SDL.texture.create.vulkan.texture\0";
pub const SDL_PROP_TEXTURE_COLORSPACE_NUMBER: &[u8; 23] = b"SDL.texture.colorspace\0";
pub const SDL_PROP_TEXTURE_FORMAT_NUMBER: &[u8; 19] = b"SDL.texture.format\0";
pub const SDL_PROP_TEXTURE_ACCESS_NUMBER: &[u8; 19] = b"SDL.texture.access\0";
pub const SDL_PROP_TEXTURE_WIDTH_NUMBER: &[u8; 18] = b"SDL.texture.width\0";
pub const SDL_PROP_TEXTURE_HEIGHT_NUMBER: &[u8; 19] = b"SDL.texture.height\0";
pub const SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT: &[u8; 28] = b"SDL.texture.SDR_white_point\0";
pub const SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT: &[u8; 25] = b"SDL.texture.HDR_headroom\0";
pub const SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER: &[u8; 26] = b"SDL.texture.d3d11.texture\0";
pub const SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER: &[u8; 28] = b"SDL.texture.d3d11.texture_u\0";
pub const SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER: &[u8; 28] = b"SDL.texture.d3d11.texture_v\0";
pub const SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER: &[u8; 26] = b"SDL.texture.d3d12.texture\0";
pub const SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER: &[u8; 28] = b"SDL.texture.d3d12.texture_u\0";
pub const SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER: &[u8; 28] = b"SDL.texture.d3d12.texture_v\0";
pub const SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER: &[u8; 27] = b"SDL.texture.opengl.texture\0";
pub const SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER: &[u8; 30] = b"SDL.texture.opengl.texture_uv\0";
pub const SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER: &[u8; 29] = b"SDL.texture.opengl.texture_u\0";
pub const SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER: &[u8; 29] = b"SDL.texture.opengl.texture_v\0";
pub const SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER: &[u8; 26] = b"SDL.texture.opengl.target\0";
pub const SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT: &[u8; 25] = b"SDL.texture.opengl.tex_w\0";
pub const SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT: &[u8; 25] = b"SDL.texture.opengl.tex_h\0";
pub const SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER: &[u8; 30] = b"SDL.texture.opengles2.texture\0";
pub const SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER: &[u8; 33] =
    b"SDL.texture.opengles2.texture_uv\0";
pub const SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER: &[u8; 32] =
    b"SDL.texture.opengles2.texture_u\0";
pub const SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER: &[u8; 32] =
    b"SDL.texture.opengles2.texture_v\0";
pub const SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER: &[u8; 29] =
    b"SDL.texture.opengles2.target\0";
pub const SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER: &[u8; 27] = b"SDL.texture.vulkan.texture\0";
pub const SDL_RENDERER_VSYNC_DISABLED: u32 = 0;
pub const SDL_RENDERER_VSYNC_ADAPTIVE: i32 = -1;
pub const SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE: u32 = 8;
pub const SDL_MS_PER_SECOND: u32 = 1000;
pub const SDL_US_PER_SECOND: u32 = 1000000;
pub const SDL_NS_PER_SECOND: u32 = 1000000000;
pub const SDL_NS_PER_MS: u32 = 1000000;
pub const SDL_NS_PER_US: u32 = 1000;
pub const SDL_TRAYENTRY_BUTTON: u32 = 1;
pub const SDL_TRAYENTRY_CHECKBOX: u32 = 2;
pub const SDL_TRAYENTRY_SUBMENU: u32 = 4;
pub const SDL_TRAYENTRY_DISABLED: u32 = 2147483648;
pub const SDL_TRAYENTRY_CHECKED: u32 = 1073741824;
pub const SDL_MAJOR_VERSION: u32 = 3;
pub const SDL_MINOR_VERSION: u32 = 2;
pub const SDL_MICRO_VERSION: u32 = 4;
pub const SDL_IMAGE_MAJOR_VERSION: u32 = 3;
pub const SDL_IMAGE_MINOR_VERSION: u32 = 2;
pub const SDL_IMAGE_MICRO_VERSION: u32 = 0;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = libc::c_long;
pub type __u_quad_t = libc::c_ulong;
pub type __intmax_t = libc::c_long;
pub type __uintmax_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [libc::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::core::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::core::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::core::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = libc::c_ulong;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __suseconds64_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = libc::c_ulong;
pub type __fsword_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type __sig_atomic_t = libc::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = libc::c_schar;
pub type int_fast16_t = libc::c_long;
pub type int_fast32_t = libc::c_long;
pub type int_fast64_t = libc::c_long;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_ulong;
pub type uint_fast32_t = libc::c_ulong;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut libc::c_void,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const libc::c_void,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn strcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strcat(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strcmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn strcoll(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const libc::c_ushort,
    pub __ctype_tolower: *const libc::c_int,
    pub __ctype_toupper: *const libc::c_int,
    pub __names: [*const libc::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::core::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::core::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::core::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::core::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::core::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::core::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::core::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __l: locale_t,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strndup(__string: *const libc::c_char, __n: libc::c_ulong) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strrchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strcspn(__s: *const libc::c_char, __reject: *const libc::c_char) -> libc::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(__s: *const libc::c_char, __accept: *const libc::c_char) -> libc::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(__s: *const libc::c_char, __accept: *const libc::c_char) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const libc::c_char,
        __needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strtok(__s: *mut libc::c_char, __delim: *const libc::c_char) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut libc::c_char,
        __delim: *const libc::c_char,
        __save_ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut libc::c_char,
        __delim: *const libc::c_char,
        __save_ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strcasestr(
        __haystack: *const libc::c_char,
        __needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn memmem(
        __haystack: *const libc::c_void,
        __haystacklen: usize,
        __needle: *const libc::c_void,
        __needlelen: usize,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn __mempcpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: usize,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn mempcpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn strlen(__s: *const libc::c_char) -> libc::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const libc::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: libc::c_int) -> *mut libc::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: libc::c_int,
        __buf: *mut libc::c_char,
        __buflen: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(__errnum: libc::c_int, __l: locale_t) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn bcopy(__src: *const libc::c_void, __dest: *mut libc::c_void, __n: libc::c_ulong);
}
unsafe extern "C" {
    pub fn bzero(__s: *mut libc::c_void, __n: libc::c_ulong);
}
unsafe extern "C" {
    pub fn index(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn rindex(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: libc::c_long) -> libc::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: libc::c_longlong) -> libc::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __loc: locale_t,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut libc::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut libc::c_char,
        __delim: *const libc::c_char,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: libc::c_int) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: usize,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_ulong;
}
unsafe extern "C" {
    pub fn strlcat(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_ulong;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type wchar_t = libc::c_int;
pub type wint_t = libc::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: libc::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: libc::c_uint,
    pub __wchb: [libc::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::core::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::core::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::core::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::core::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::core::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::core::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::core::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::core::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
pub type mbstate_t = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcslcpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcslcat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcscmp(__s1: *const libc::c_int, __s2: *const libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn wcsncmp(
        __s1: *const libc::c_int,
        __s2: *const libc::c_int,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t) -> libc::c_int;
}
unsafe extern "C" {
    pub fn wcsncasecmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize) -> libc::c_int;
}
unsafe extern "C" {
    pub fn wcscasecmp_l(__s1: *const wchar_t, __s2: *const wchar_t, __loc: locale_t)
        -> libc::c_int;
}
unsafe extern "C" {
    pub fn wcsncasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: usize,
        __loc: locale_t,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t) -> libc::c_int;
}
unsafe extern "C" {
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcscoll_l(__s1: *const wchar_t, __s2: *const wchar_t, __loc: locale_t) -> libc::c_int;
}
unsafe extern "C" {
    pub fn wcsxfrm_l(
        __s1: *mut wchar_t,
        __s2: *const wchar_t,
        __n: usize,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcschr(__wcs: *const libc::c_int, __wc: libc::c_int) -> *mut libc::c_int;
}
unsafe extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> usize;
}
unsafe extern "C" {
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> usize;
}
unsafe extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcstok(
        __s: *mut wchar_t,
        __delim: *const wchar_t,
        __ptr: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcslen(__s: *const libc::c_int) -> libc::c_ulong;
}
unsafe extern "C" {
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn wmemchr(
        __s: *const libc::c_int,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_int;
}
unsafe extern "C" {
    pub fn wmemcmp(
        __s1: *const libc::c_int,
        __s2: *const libc::c_int,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn wmemcpy(
        __s1: *mut libc::c_int,
        __s2: *const libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_int;
}
unsafe extern "C" {
    pub fn wmemmove(
        __s1: *mut libc::c_int,
        __s2: *const libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_int;
}
unsafe extern "C" {
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn btowc(__c: libc::c_int) -> wint_t;
}
unsafe extern "C" {
    pub fn wctob(__c: wint_t) -> libc::c_int;
}
unsafe extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;
}
unsafe extern "C" {
    pub fn mbrtowc(
        __pwc: *mut wchar_t,
        __s: *const libc::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcrtomb(__s: *mut libc::c_char, __wc: wchar_t, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn __mbrlen(__s: *const libc::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn mbrlen(__s: *const libc::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn mbsrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const libc::c_char,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsrtombs(
        __dst: *mut libc::c_char,
        __src: *mut *const wchar_t,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn mbsnrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const libc::c_char,
        __nmc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsnrtombs(
        __dst: *mut libc::c_char,
        __src: *mut *const wchar_t,
        __nwc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
unsafe extern "C" {
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
unsafe extern "C" {
    pub fn wcstold(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> u128;
}
unsafe extern "C" {
    pub fn wcstol(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: libc::c_int,
    ) -> libc::c_long;
}
unsafe extern "C" {
    pub fn wcstoul(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: libc::c_int,
    ) -> libc::c_ulong;
}
unsafe extern "C" {
    pub fn wcstoll(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
unsafe extern "C" {
    pub fn wcstoull(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
unsafe extern "C" {
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut usize) -> *mut __FILE;
}
unsafe extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> libc::c_int;
}
unsafe extern "C" {
    pub fn wprintf(__format: *const wchar_t, ...) -> libc::c_int;
}
unsafe extern "C" {
    pub fn swprintf(__s: *mut wchar_t, __n: usize, __format: *const wchar_t, ...) -> libc::c_int;
}
unsafe extern "C" {
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> libc::c_int;
}
unsafe extern "C" {
    pub fn vswprintf(
        __s: *mut wchar_t,
        __n: usize,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> libc::c_int;
}
unsafe extern "C" {
    pub fn wscanf(__format: *const wchar_t, ...) -> libc::c_int;
}
unsafe extern "C" {
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...) -> libc::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...) -> libc::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> libc::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...) -> libc::c_int;
}
unsafe extern "C" {
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> libc::c_int;
}
unsafe extern "C" {
    pub fn vswscanf(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfwscanf"]
    pub fn vfwscanf1(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag) -> libc::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vswscanf"]
    pub fn vswscanf1(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwchar() -> wint_t;
}
unsafe extern "C" {
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
unsafe extern "C" {
    pub fn fgetws(__ws: *mut wchar_t, __n: libc::c_int, __stream: *mut __FILE) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE) -> libc::c_int;
}
unsafe extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn wcsftime(
        __s: *mut wchar_t,
        __maxsize: usize,
        __format: *const wchar_t,
        __tp: *const tm,
    ) -> usize;
}
pub type __gwchar_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::core::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::core::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::core::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::core::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: libc::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: libc::c_int,
    ) -> uintmax_t;
}
pub type Sint8 = i8;
pub type Uint8 = u8;
pub type Sint16 = i16;
pub type Uint16 = u16;
pub type Sint32 = i32;
pub type Uint32 = u32;
pub type Sint64 = i64;
pub type Uint64 = u64;
unsafe extern "C" {
    pub fn SDL_malloc(size: usize) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_calloc(nmemb: usize, size: usize) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_realloc(mem: *mut libc::c_void, size: usize) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_free(mem: *mut libc::c_void);
}
unsafe extern "C" {
    pub fn SDL_GetOriginalMemoryFunctions(
        malloc_func: *mut SDL_malloc_func,
        calloc_func: *mut SDL_calloc_func,
        realloc_func: *mut SDL_realloc_func,
        free_func: *mut SDL_free_func,
    );
}
unsafe extern "C" {
    pub fn SDL_GetMemoryFunctions(
        malloc_func: *mut SDL_malloc_func,
        calloc_func: *mut SDL_calloc_func,
        realloc_func: *mut SDL_realloc_func,
        free_func: *mut SDL_free_func,
    );
}
unsafe extern "C" {
    pub fn SDL_SetMemoryFunctions(
        malloc_func: SDL_malloc_func,
        calloc_func: SDL_calloc_func,
        realloc_func: SDL_realloc_func,
        free_func: SDL_free_func,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_aligned_alloc(alignment: usize, size: usize) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_aligned_free(mem: *mut libc::c_void);
}
unsafe extern "C" {
    pub fn SDL_GetNumAllocations() -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetEnvironment() -> *mut SDL_Environment;
}
unsafe extern "C" {
    pub fn SDL_CreateEnvironment(populated: bool) -> *mut SDL_Environment;
}
unsafe extern "C" {
    pub fn SDL_GetEnvironmentVariable(
        env: *mut SDL_Environment,
        name: *const libc::c_char,
    ) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetEnvironmentVariables(env: *mut SDL_Environment) -> *mut *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_SetEnvironmentVariable(
        env: *mut SDL_Environment,
        name: *const libc::c_char,
        value: *const libc::c_char,
        overwrite: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UnsetEnvironmentVariable(
        env: *mut SDL_Environment,
        name: *const libc::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_DestroyEnvironment(env: *mut SDL_Environment);
}
unsafe extern "C" {
    pub fn SDL_getenv(name: *const libc::c_char) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_getenv_unsafe(name: *const libc::c_char) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_setenv_unsafe(
        name: *const libc::c_char,
        value: *const libc::c_char,
        overwrite: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_unsetenv_unsafe(name: *const libc::c_char) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_qsort(
        base: *mut libc::c_void,
        nmemb: usize,
        size: usize,
        compare: SDL_CompareCallback,
    );
}
unsafe extern "C" {
    pub fn SDL_bsearch(
        key: *const libc::c_void,
        base: *const libc::c_void,
        nmemb: usize,
        size: usize,
        compare: SDL_CompareCallback,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_qsort_r(
        base: *mut libc::c_void,
        nmemb: usize,
        size: usize,
        compare: SDL_CompareCallback_r,
        userdata: *mut libc::c_void,
    );
}
unsafe extern "C" {
    pub fn SDL_bsearch_r(
        key: *const libc::c_void,
        base: *const libc::c_void,
        nmemb: usize,
        size: usize,
        compare: SDL_CompareCallback_r,
        userdata: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_abs(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_isalpha(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_isalnum(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_isblank(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_iscntrl(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_isdigit(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_isxdigit(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_ispunct(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_isspace(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_isupper(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_islower(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_isprint(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_isgraph(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_toupper(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_tolower(x: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_crc16(crc: Uint16, data: *const libc::c_void, len: usize) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_crc32(crc: Uint32, data: *const libc::c_void, len: usize) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_murmur3_32(data: *const libc::c_void, len: usize, seed: Uint32) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_memcpy(
        dst: *mut libc::c_void,
        src: *const libc::c_void,
        len: usize,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_memmove(
        dst: *mut libc::c_void,
        src: *const libc::c_void,
        len: usize,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_memset(dst: *mut libc::c_void, c: libc::c_int, len: usize) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_memset4(dst: *mut libc::c_void, val: Uint32, dwords: usize) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_memcmp(s1: *const libc::c_void, s2: *const libc::c_void, len: usize) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_wcslen(wstr: *const wchar_t) -> usize;
}
unsafe extern "C" {
    pub fn SDL_wcsnlen(wstr: *const wchar_t, maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn SDL_wcslcpy(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn SDL_wcslcat(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn SDL_wcsdup(wstr: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn SDL_wcsstr(haystack: *const wchar_t, needle: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn SDL_wcsnstr(
        haystack: *const wchar_t,
        needle: *const wchar_t,
        maxlen: usize,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn SDL_wcscmp(str1: *const wchar_t, str2: *const wchar_t) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_wcsncmp(str1: *const wchar_t, str2: *const wchar_t, maxlen: usize) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_wcscasecmp(str1: *const wchar_t, str2: *const wchar_t) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_wcsncasecmp(
        str1: *const wchar_t,
        str2: *const wchar_t,
        maxlen: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_wcstol(
        str_: *const wchar_t,
        endp: *mut *mut wchar_t,
        base: libc::c_int,
    ) -> libc::c_long;
}
unsafe extern "C" {
    pub fn SDL_strlen(str_: *const libc::c_char) -> usize;
}
unsafe extern "C" {
    pub fn SDL_strnlen(str_: *const libc::c_char, maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn SDL_strlcpy(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn SDL_utf8strlcpy(
        dst: *mut libc::c_char,
        src: *const libc::c_char,
        dst_bytes: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn SDL_strlcat(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn SDL_strdup(str_: *const libc::c_char) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_strndup(str_: *const libc::c_char, maxlen: usize) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_strrev(str_: *mut libc::c_char) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_strupr(str_: *mut libc::c_char) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_strlwr(str_: *mut libc::c_char) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_strchr(str_: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_strrchr(str_: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_strstr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_strnstr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
        maxlen: usize,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_strcasestr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_strtok_r(
        str_: *mut libc::c_char,
        delim: *const libc::c_char,
        saveptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_utf8strlen(str_: *const libc::c_char) -> usize;
}
unsafe extern "C" {
    pub fn SDL_utf8strnlen(str_: *const libc::c_char, bytes: usize) -> usize;
}
unsafe extern "C" {
    pub fn SDL_itoa(
        value: libc::c_int,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_uitoa(
        value: libc::c_uint,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_ltoa(
        value: libc::c_long,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_ultoa(
        value: libc::c_ulong,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_lltoa(
        value: libc::c_longlong,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_ulltoa(
        value: libc::c_ulonglong,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_atoi(str_: *const libc::c_char) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_atof(str_: *const libc::c_char) -> f64;
}
unsafe extern "C" {
    pub fn SDL_strtol(
        str_: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_long;
}
unsafe extern "C" {
    pub fn SDL_strtoul(
        str_: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_ulong;
}
unsafe extern "C" {
    pub fn SDL_strtoll(
        str_: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_longlong;
}
unsafe extern "C" {
    pub fn SDL_strtoull(
        str_: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_ulonglong;
}
unsafe extern "C" {
    pub fn SDL_strtod(str_: *const libc::c_char, endp: *mut *mut libc::c_char) -> f64;
}
unsafe extern "C" {
    pub fn SDL_strcmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_strncmp(
        str1: *const libc::c_char,
        str2: *const libc::c_char,
        maxlen: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_strcasecmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_strncasecmp(
        str1: *const libc::c_char,
        str2: *const libc::c_char,
        maxlen: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_strpbrk(
        str_: *const libc::c_char,
        breakset: *const libc::c_char,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_StepUTF8(pstr: *mut *const libc::c_char, pslen: *mut usize) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_StepBackUTF8(start: *const libc::c_char, pstr: *mut *const libc::c_char) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_UCS4ToUTF8(codepoint: Uint32, dst: *mut libc::c_char) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_sscanf(text: *const libc::c_char, fmt: *const libc::c_char, ...) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_vsscanf(
        text: *const libc::c_char,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_snprintf(
        text: *mut libc::c_char,
        maxlen: usize,
        fmt: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_swprintf(text: *mut wchar_t, maxlen: usize, fmt: *const wchar_t, ...)
        -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_vsnprintf(
        text: *mut libc::c_char,
        maxlen: usize,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_vswprintf(
        text: *mut wchar_t,
        maxlen: usize,
        fmt: *const wchar_t,
        ap: *mut __va_list_tag,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_asprintf(strp: *mut *mut libc::c_char, fmt: *const libc::c_char, ...)
        -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_vasprintf(
        strp: *mut *mut libc::c_char,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_srand(seed: Uint64);
}
unsafe extern "C" {
    pub fn SDL_rand(n: Sint32) -> Sint32;
}
unsafe extern "C" {
    pub fn SDL_randf() -> f32;
}
unsafe extern "C" {
    pub fn SDL_rand_bits() -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_rand_r(state: *mut Uint64, n: Sint32) -> Sint32;
}
unsafe extern "C" {
    pub fn SDL_randf_r(state: *mut Uint64) -> f32;
}
unsafe extern "C" {
    pub fn SDL_rand_bits_r(state: *mut Uint64) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_acos(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_acosf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_asin(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_asinf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_atan(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_atanf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_atan2(y: f64, x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_atan2f(y: f32, x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_ceil(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_ceilf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_copysign(x: f64, y: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_copysignf(x: f32, y: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_cos(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_cosf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_exp(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_expf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_fabs(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_fabsf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_floor(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_floorf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_trunc(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_truncf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_fmod(x: f64, y: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_fmodf(x: f32, y: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_isinf(x: f64) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_isinff(x: f32) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_isnan(x: f64) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_isnanf(x: f32) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_log(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_logf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_log10(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_log10f(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_modf(x: f64, y: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_modff(x: f32, y: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_pow(x: f64, y: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_powf(x: f32, y: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_round(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_roundf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_lround(x: f64) -> libc::c_long;
}
unsafe extern "C" {
    pub fn SDL_lroundf(x: f32) -> libc::c_long;
}
unsafe extern "C" {
    pub fn SDL_scalbn(x: f64, n: libc::c_int) -> f64;
}
unsafe extern "C" {
    pub fn SDL_scalbnf(x: f32, n: libc::c_int) -> f32;
}
unsafe extern "C" {
    pub fn SDL_sin(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_sinf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_sqrt(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_sqrtf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_tan(x: f64) -> f64;
}
unsafe extern "C" {
    pub fn SDL_tanf(x: f32) -> f32;
}
unsafe extern "C" {
    pub fn SDL_iconv_open(
        tocode: *const libc::c_char,
        fromcode: *const libc::c_char,
    ) -> SDL_iconv_t;
}
unsafe extern "C" {
    pub fn SDL_iconv_close(cd: SDL_iconv_t) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_iconv(
        cd: SDL_iconv_t,
        inbuf: *mut *const libc::c_char,
        inbytesleft: *mut usize,
        outbuf: *mut *mut libc::c_char,
        outbytesleft: *mut usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn SDL_iconv_string(
        tocode: *const libc::c_char,
        fromcode: *const libc::c_char,
        inbuf: *const libc::c_char,
        inbytesleft: usize,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_ReportAssertion(
        data: *mut SDL_AssertData,
        func: *const libc::c_char,
        file: *const libc::c_char,
        line: libc::c_int,
    ) -> SDL_AssertState;
}
unsafe extern "C" {
    pub fn SDL_SetAssertionHandler(handler: SDL_AssertionHandler, userdata: *mut libc::c_void);
}
unsafe extern "C" {
    pub fn SDL_GetDefaultAssertionHandler() -> SDL_AssertionHandler;
}
unsafe extern "C" {
    pub fn SDL_GetAssertionHandler(puserdata: *mut *mut libc::c_void) -> SDL_AssertionHandler;
}
unsafe extern "C" {
    pub fn SDL_GetAssertionReport() -> *const SDL_AssertData;
}
unsafe extern "C" {
    pub fn SDL_ResetAssertionReport();
}
unsafe extern "C" {
    pub fn SDL_AsyncIOFromFile(
        file: *const libc::c_char,
        mode: *const libc::c_char,
    ) -> *mut SDL_AsyncIO;
}
unsafe extern "C" {
    pub fn SDL_GetAsyncIOSize(asyncio: *mut SDL_AsyncIO) -> Sint64;
}
unsafe extern "C" {
    pub fn SDL_ReadAsyncIO(
        asyncio: *mut SDL_AsyncIO,
        ptr: *mut libc::c_void,
        offset: Uint64,
        size: Uint64,
        queue: *mut SDL_AsyncIOQueue,
        userdata: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteAsyncIO(
        asyncio: *mut SDL_AsyncIO,
        ptr: *mut libc::c_void,
        offset: Uint64,
        size: Uint64,
        queue: *mut SDL_AsyncIOQueue,
        userdata: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CloseAsyncIO(
        asyncio: *mut SDL_AsyncIO,
        flush: bool,
        queue: *mut SDL_AsyncIOQueue,
        userdata: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CreateAsyncIOQueue() -> *mut SDL_AsyncIOQueue;
}
unsafe extern "C" {
    pub fn SDL_DestroyAsyncIOQueue(queue: *mut SDL_AsyncIOQueue);
}
unsafe extern "C" {
    pub fn SDL_GetAsyncIOResult(
        queue: *mut SDL_AsyncIOQueue,
        outcome: *mut SDL_AsyncIOOutcome,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WaitAsyncIOResult(
        queue: *mut SDL_AsyncIOQueue,
        outcome: *mut SDL_AsyncIOOutcome,
        timeoutMS: Sint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SignalAsyncIOQueue(queue: *mut SDL_AsyncIOQueue);
}
unsafe extern "C" {
    pub fn SDL_LoadFileAsync(
        file: *const libc::c_char,
        queue: *mut SDL_AsyncIOQueue,
        userdata: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_TryLockSpinlock(lock: *mut SDL_SpinLock) -> bool;
}
unsafe extern "C" {
    pub fn SDL_LockSpinlock(lock: *mut SDL_SpinLock);
}
unsafe extern "C" {
    pub fn SDL_UnlockSpinlock(lock: *mut SDL_SpinLock);
}
unsafe extern "C" {
    pub fn SDL_MemoryBarrierReleaseFunction();
}
unsafe extern "C" {
    pub fn SDL_MemoryBarrierAcquireFunction();
}
unsafe extern "C" {
    pub fn SDL_CompareAndSwapAtomicInt(
        a: *mut SDL_AtomicInt,
        oldval: libc::c_int,
        newval: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetAtomicInt(a: *mut SDL_AtomicInt, v: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetAtomicInt(a: *mut SDL_AtomicInt) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_AddAtomicInt(a: *mut SDL_AtomicInt, v: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_CompareAndSwapAtomicU32(
        a: *mut SDL_AtomicU32,
        oldval: Uint32,
        newval: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetAtomicU32(a: *mut SDL_AtomicU32, v: Uint32) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_GetAtomicU32(a: *mut SDL_AtomicU32) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_CompareAndSwapAtomicPointer(
        a: *mut *mut libc::c_void,
        oldval: *mut libc::c_void,
        newval: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetAtomicPointer(
        a: *mut *mut libc::c_void,
        v: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_GetAtomicPointer(a: *mut *mut libc::c_void) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_SetError(fmt: *const libc::c_char, ...) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetErrorV(fmt: *const libc::c_char, ap: *mut __va_list_tag) -> bool;
}
unsafe extern "C" {
    pub fn SDL_OutOfMemory() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetError() -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_ClearError() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGlobalProperties() -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_CreateProperties() -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_CopyProperties(src: SDL_PropertiesID, dst: SDL_PropertiesID) -> bool;
}
unsafe extern "C" {
    pub fn SDL_LockProperties(props: SDL_PropertiesID) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UnlockProperties(props: SDL_PropertiesID);
}
unsafe extern "C" {
    pub fn SDL_SetPointerPropertyWithCleanup(
        props: SDL_PropertiesID,
        name: *const libc::c_char,
        value: *mut libc::c_void,
        cleanup: SDL_CleanupPropertyCallback,
        userdata: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetPointerProperty(
        props: SDL_PropertiesID,
        name: *const libc::c_char,
        value: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetStringProperty(
        props: SDL_PropertiesID,
        name: *const libc::c_char,
        value: *const libc::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetNumberProperty(
        props: SDL_PropertiesID,
        name: *const libc::c_char,
        value: Sint64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetFloatProperty(
        props: SDL_PropertiesID,
        name: *const libc::c_char,
        value: f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetBooleanProperty(
        props: SDL_PropertiesID,
        name: *const libc::c_char,
        value: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasProperty(props: SDL_PropertiesID, name: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetPropertyType(
        props: SDL_PropertiesID,
        name: *const libc::c_char,
    ) -> SDL_PropertyType;
}
unsafe extern "C" {
    pub fn SDL_GetPointerProperty(
        props: SDL_PropertiesID,
        name: *const libc::c_char,
        default_value: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_GetStringProperty(
        props: SDL_PropertiesID,
        name: *const libc::c_char,
        default_value: *const libc::c_char,
    ) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetNumberProperty(
        props: SDL_PropertiesID,
        name: *const libc::c_char,
        default_value: Sint64,
    ) -> Sint64;
}
unsafe extern "C" {
    pub fn SDL_GetFloatProperty(
        props: SDL_PropertiesID,
        name: *const libc::c_char,
        default_value: f32,
    ) -> f32;
}
unsafe extern "C" {
    pub fn SDL_GetBooleanProperty(
        props: SDL_PropertiesID,
        name: *const libc::c_char,
        default_value: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ClearProperty(props: SDL_PropertiesID, name: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_EnumerateProperties(
        props: SDL_PropertiesID,
        callback: SDL_EnumeratePropertiesCallback,
        userdata: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_DestroyProperties(props: SDL_PropertiesID);
}
unsafe extern "C" {
    pub fn SDL_CreateThreadRuntime(
        fn_: SDL_ThreadFunction,
        name: *const libc::c_char,
        data: *mut libc::c_void,
        pfnBeginThread: SDL_FunctionPointer,
        pfnEndThread: SDL_FunctionPointer,
    ) -> *mut SDL_Thread;
}
unsafe extern "C" {
    pub fn SDL_CreateThreadWithPropertiesRuntime(
        props: SDL_PropertiesID,
        pfnBeginThread: SDL_FunctionPointer,
        pfnEndThread: SDL_FunctionPointer,
    ) -> *mut SDL_Thread;
}
unsafe extern "C" {
    pub fn SDL_GetThreadName(thread: *mut SDL_Thread) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetCurrentThreadID() -> SDL_ThreadID;
}
unsafe extern "C" {
    pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> SDL_ThreadID;
}
unsafe extern "C" {
    pub fn SDL_SetCurrentThreadPriority(priority: SDL_ThreadPriority) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WaitThread(thread: *mut SDL_Thread, status: *mut libc::c_int);
}
unsafe extern "C" {
    pub fn SDL_GetThreadState(thread: *mut SDL_Thread) -> SDL_ThreadState;
}
unsafe extern "C" {
    pub fn SDL_DetachThread(thread: *mut SDL_Thread);
}
unsafe extern "C" {
    pub fn SDL_GetTLS(id: *mut SDL_TLSID) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_SetTLS(
        id: *mut SDL_TLSID,
        value: *const libc::c_void,
        destructor: SDL_TLSDestructorCallback,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CleanupTLS();
}
unsafe extern "C" {
    pub fn SDL_CreateMutex() -> *mut SDL_Mutex;
}
unsafe extern "C" {
    pub fn SDL_LockMutex(mutex: *mut SDL_Mutex);
}
unsafe extern "C" {
    pub fn SDL_TryLockMutex(mutex: *mut SDL_Mutex) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UnlockMutex(mutex: *mut SDL_Mutex);
}
unsafe extern "C" {
    pub fn SDL_DestroyMutex(mutex: *mut SDL_Mutex);
}
unsafe extern "C" {
    pub fn SDL_CreateRWLock() -> *mut SDL_RWLock;
}
unsafe extern "C" {
    pub fn SDL_LockRWLockForReading(rwlock: *mut SDL_RWLock);
}
unsafe extern "C" {
    pub fn SDL_LockRWLockForWriting(rwlock: *mut SDL_RWLock);
}
unsafe extern "C" {
    pub fn SDL_TryLockRWLockForReading(rwlock: *mut SDL_RWLock) -> bool;
}
unsafe extern "C" {
    pub fn SDL_TryLockRWLockForWriting(rwlock: *mut SDL_RWLock) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UnlockRWLock(rwlock: *mut SDL_RWLock);
}
unsafe extern "C" {
    pub fn SDL_DestroyRWLock(rwlock: *mut SDL_RWLock);
}
unsafe extern "C" {
    pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_Semaphore;
}
unsafe extern "C" {
    pub fn SDL_DestroySemaphore(sem: *mut SDL_Semaphore);
}
unsafe extern "C" {
    pub fn SDL_WaitSemaphore(sem: *mut SDL_Semaphore);
}
unsafe extern "C" {
    pub fn SDL_TryWaitSemaphore(sem: *mut SDL_Semaphore) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WaitSemaphoreTimeout(sem: *mut SDL_Semaphore, timeoutMS: Sint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SignalSemaphore(sem: *mut SDL_Semaphore);
}
unsafe extern "C" {
    pub fn SDL_GetSemaphoreValue(sem: *mut SDL_Semaphore) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_CreateCondition() -> *mut SDL_Condition;
}
unsafe extern "C" {
    pub fn SDL_DestroyCondition(cond: *mut SDL_Condition);
}
unsafe extern "C" {
    pub fn SDL_SignalCondition(cond: *mut SDL_Condition);
}
unsafe extern "C" {
    pub fn SDL_BroadcastCondition(cond: *mut SDL_Condition);
}
unsafe extern "C" {
    pub fn SDL_WaitCondition(cond: *mut SDL_Condition, mutex: *mut SDL_Mutex);
}
unsafe extern "C" {
    pub fn SDL_WaitConditionTimeout(
        cond: *mut SDL_Condition,
        mutex: *mut SDL_Mutex,
        timeoutMS: Sint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ShouldInit(state: *mut SDL_InitState) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ShouldQuit(state: *mut SDL_InitState) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetInitialized(state: *mut SDL_InitState, initialized: bool);
}
unsafe extern "C" {
    pub fn SDL_IOFromFile(
        file: *const libc::c_char,
        mode: *const libc::c_char,
    ) -> *mut SDL_IOStream;
}
unsafe extern "C" {
    pub fn SDL_IOFromMem(mem: *mut libc::c_void, size: usize) -> *mut SDL_IOStream;
}
unsafe extern "C" {
    pub fn SDL_IOFromConstMem(mem: *const libc::c_void, size: usize) -> *mut SDL_IOStream;
}
unsafe extern "C" {
    pub fn SDL_IOFromDynamicMem() -> *mut SDL_IOStream;
}
unsafe extern "C" {
    pub fn SDL_OpenIO(
        iface: *const SDL_IOStreamInterface,
        userdata: *mut libc::c_void,
    ) -> *mut SDL_IOStream;
}
unsafe extern "C" {
    pub fn SDL_CloseIO(context: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetIOProperties(context: *mut SDL_IOStream) -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_GetIOStatus(context: *mut SDL_IOStream) -> SDL_IOStatus;
}
unsafe extern "C" {
    pub fn SDL_GetIOSize(context: *mut SDL_IOStream) -> Sint64;
}
unsafe extern "C" {
    pub fn SDL_SeekIO(context: *mut SDL_IOStream, offset: Sint64, whence: SDL_IOWhence) -> Sint64;
}
unsafe extern "C" {
    pub fn SDL_TellIO(context: *mut SDL_IOStream) -> Sint64;
}
unsafe extern "C" {
    pub fn SDL_ReadIO(context: *mut SDL_IOStream, ptr: *mut libc::c_void, size: usize) -> usize;
}
unsafe extern "C" {
    pub fn SDL_WriteIO(context: *mut SDL_IOStream, ptr: *const libc::c_void, size: usize) -> usize;
}
unsafe extern "C" {
    pub fn SDL_IOprintf(context: *mut SDL_IOStream, fmt: *const libc::c_char, ...) -> usize;
}
unsafe extern "C" {
    pub fn SDL_IOvprintf(
        context: *mut SDL_IOStream,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    ) -> usize;
}
unsafe extern "C" {
    pub fn SDL_FlushIO(context: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    pub fn SDL_LoadFile_IO(
        src: *mut SDL_IOStream,
        datasize: *mut usize,
        closeio: bool,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_LoadFile(file: *const libc::c_char, datasize: *mut usize) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_SaveFile_IO(
        src: *mut SDL_IOStream,
        data: *const libc::c_void,
        datasize: usize,
        closeio: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SaveFile(
        file: *const libc::c_char,
        data: *const libc::c_void,
        datasize: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadU8(src: *mut SDL_IOStream, value: *mut Uint8) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadS8(src: *mut SDL_IOStream, value: *mut Sint8) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadU16LE(src: *mut SDL_IOStream, value: *mut Uint16) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadS16LE(src: *mut SDL_IOStream, value: *mut Sint16) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadU16BE(src: *mut SDL_IOStream, value: *mut Uint16) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadS16BE(src: *mut SDL_IOStream, value: *mut Sint16) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadU32LE(src: *mut SDL_IOStream, value: *mut Uint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadS32LE(src: *mut SDL_IOStream, value: *mut Sint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadU32BE(src: *mut SDL_IOStream, value: *mut Uint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadS32BE(src: *mut SDL_IOStream, value: *mut Sint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadU64LE(src: *mut SDL_IOStream, value: *mut Uint64) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadS64LE(src: *mut SDL_IOStream, value: *mut Sint64) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadU64BE(src: *mut SDL_IOStream, value: *mut Uint64) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadS64BE(src: *mut SDL_IOStream, value: *mut Sint64) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteU8(dst: *mut SDL_IOStream, value: Uint8) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteS8(dst: *mut SDL_IOStream, value: Sint8) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteU16LE(dst: *mut SDL_IOStream, value: Uint16) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteS16LE(dst: *mut SDL_IOStream, value: Sint16) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteU16BE(dst: *mut SDL_IOStream, value: Uint16) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteS16BE(dst: *mut SDL_IOStream, value: Sint16) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteU32LE(dst: *mut SDL_IOStream, value: Uint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteS32LE(dst: *mut SDL_IOStream, value: Sint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteU32BE(dst: *mut SDL_IOStream, value: Uint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteS32BE(dst: *mut SDL_IOStream, value: Sint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteU64LE(dst: *mut SDL_IOStream, value: Uint64) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteS64LE(dst: *mut SDL_IOStream, value: Sint64) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteU64BE(dst: *mut SDL_IOStream, value: Uint64) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteS64BE(dst: *mut SDL_IOStream, value: Sint64) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetNumAudioDrivers() -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetAudioDriver(index: libc::c_int) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetCurrentAudioDriver() -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetAudioPlaybackDevices(count: *mut libc::c_int) -> *mut SDL_AudioDeviceID;
}
unsafe extern "C" {
    pub fn SDL_GetAudioRecordingDevices(count: *mut libc::c_int) -> *mut SDL_AudioDeviceID;
}
unsafe extern "C" {
    pub fn SDL_GetAudioDeviceName(devid: SDL_AudioDeviceID) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetAudioDeviceFormat(
        devid: SDL_AudioDeviceID,
        spec: *mut SDL_AudioSpec,
        sample_frames: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetAudioDeviceChannelMap(
        devid: SDL_AudioDeviceID,
        count: *mut libc::c_int,
    ) -> *mut libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_OpenAudioDevice(
        devid: SDL_AudioDeviceID,
        spec: *const SDL_AudioSpec,
    ) -> SDL_AudioDeviceID;
}
unsafe extern "C" {
    pub fn SDL_IsAudioDevicePhysical(devid: SDL_AudioDeviceID) -> bool;
}
unsafe extern "C" {
    pub fn SDL_IsAudioDevicePlayback(devid: SDL_AudioDeviceID) -> bool;
}
unsafe extern "C" {
    pub fn SDL_PauseAudioDevice(devid: SDL_AudioDeviceID) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ResumeAudioDevice(devid: SDL_AudioDeviceID) -> bool;
}
unsafe extern "C" {
    pub fn SDL_AudioDevicePaused(devid: SDL_AudioDeviceID) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetAudioDeviceGain(devid: SDL_AudioDeviceID) -> f32;
}
unsafe extern "C" {
    pub fn SDL_SetAudioDeviceGain(devid: SDL_AudioDeviceID, gain: f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CloseAudioDevice(devid: SDL_AudioDeviceID);
}
unsafe extern "C" {
    pub fn SDL_BindAudioStreams(
        devid: SDL_AudioDeviceID,
        streams: *const *mut SDL_AudioStream,
        num_streams: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_BindAudioStream(devid: SDL_AudioDeviceID, stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UnbindAudioStreams(streams: *const *mut SDL_AudioStream, num_streams: libc::c_int);
}
unsafe extern "C" {
    pub fn SDL_UnbindAudioStream(stream: *mut SDL_AudioStream);
}
unsafe extern "C" {
    pub fn SDL_GetAudioStreamDevice(stream: *mut SDL_AudioStream) -> SDL_AudioDeviceID;
}
unsafe extern "C" {
    pub fn SDL_CreateAudioStream(
        src_spec: *const SDL_AudioSpec,
        dst_spec: *const SDL_AudioSpec,
    ) -> *mut SDL_AudioStream;
}
unsafe extern "C" {
    pub fn SDL_GetAudioStreamProperties(stream: *mut SDL_AudioStream) -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_GetAudioStreamFormat(
        stream: *mut SDL_AudioStream,
        src_spec: *mut SDL_AudioSpec,
        dst_spec: *mut SDL_AudioSpec,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetAudioStreamFormat(
        stream: *mut SDL_AudioStream,
        src_spec: *const SDL_AudioSpec,
        dst_spec: *const SDL_AudioSpec,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetAudioStreamFrequencyRatio(stream: *mut SDL_AudioStream) -> f32;
}
unsafe extern "C" {
    pub fn SDL_SetAudioStreamFrequencyRatio(stream: *mut SDL_AudioStream, ratio: f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetAudioStreamGain(stream: *mut SDL_AudioStream) -> f32;
}
unsafe extern "C" {
    pub fn SDL_SetAudioStreamGain(stream: *mut SDL_AudioStream, gain: f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetAudioStreamInputChannelMap(
        stream: *mut SDL_AudioStream,
        count: *mut libc::c_int,
    ) -> *mut libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetAudioStreamOutputChannelMap(
        stream: *mut SDL_AudioStream,
        count: *mut libc::c_int,
    ) -> *mut libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_SetAudioStreamInputChannelMap(
        stream: *mut SDL_AudioStream,
        chmap: *const libc::c_int,
        count: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetAudioStreamOutputChannelMap(
        stream: *mut SDL_AudioStream,
        chmap: *const libc::c_int,
        count: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_PutAudioStreamData(
        stream: *mut SDL_AudioStream,
        buf: *const libc::c_void,
        len: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetAudioStreamData(
        stream: *mut SDL_AudioStream,
        buf: *mut libc::c_void,
        len: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetAudioStreamAvailable(stream: *mut SDL_AudioStream) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetAudioStreamQueued(stream: *mut SDL_AudioStream) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_FlushAudioStream(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ClearAudioStream(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    pub fn SDL_PauseAudioStreamDevice(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ResumeAudioStreamDevice(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    pub fn SDL_AudioStreamDevicePaused(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    pub fn SDL_LockAudioStream(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UnlockAudioStream(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetAudioStreamGetCallback(
        stream: *mut SDL_AudioStream,
        callback: SDL_AudioStreamCallback,
        userdata: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetAudioStreamPutCallback(
        stream: *mut SDL_AudioStream,
        callback: SDL_AudioStreamCallback,
        userdata: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_DestroyAudioStream(stream: *mut SDL_AudioStream);
}
unsafe extern "C" {
    pub fn SDL_OpenAudioDeviceStream(
        devid: SDL_AudioDeviceID,
        spec: *const SDL_AudioSpec,
        callback: SDL_AudioStreamCallback,
        userdata: *mut libc::c_void,
    ) -> *mut SDL_AudioStream;
}
unsafe extern "C" {
    pub fn SDL_SetAudioPostmixCallback(
        devid: SDL_AudioDeviceID,
        callback: SDL_AudioPostmixCallback,
        userdata: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_LoadWAV_IO(
        src: *mut SDL_IOStream,
        closeio: bool,
        spec: *mut SDL_AudioSpec,
        audio_buf: *mut *mut Uint8,
        audio_len: *mut Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_LoadWAV(
        path: *const libc::c_char,
        spec: *mut SDL_AudioSpec,
        audio_buf: *mut *mut Uint8,
        audio_len: *mut Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_MixAudio(
        dst: *mut Uint8,
        src: *const Uint8,
        format: SDL_AudioFormat,
        len: Uint32,
        volume: f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ConvertAudioSamples(
        src_spec: *const SDL_AudioSpec,
        src_data: *const Uint8,
        src_len: libc::c_int,
        dst_spec: *const SDL_AudioSpec,
        dst_data: *mut *mut Uint8,
        dst_len: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetAudioFormatName(format: SDL_AudioFormat) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetSilenceValueForFormat(format: SDL_AudioFormat) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_ComposeCustomBlendMode(
        srcColorFactor: SDL_BlendFactor,
        dstColorFactor: SDL_BlendFactor,
        colorOperation: SDL_BlendOperation,
        srcAlphaFactor: SDL_BlendFactor,
        dstAlphaFactor: SDL_BlendFactor,
        alphaOperation: SDL_BlendOperation,
    ) -> SDL_BlendMode;
}
unsafe extern "C" {
    pub fn SDL_GetPixelFormatName(format: SDL_PixelFormat) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetMasksForPixelFormat(
        format: SDL_PixelFormat,
        bpp: *mut libc::c_int,
        Rmask: *mut Uint32,
        Gmask: *mut Uint32,
        Bmask: *mut Uint32,
        Amask: *mut Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetPixelFormatForMasks(
        bpp: libc::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> SDL_PixelFormat;
}
unsafe extern "C" {
    pub fn SDL_GetPixelFormatDetails(format: SDL_PixelFormat) -> *const SDL_PixelFormatDetails;
}
unsafe extern "C" {
    pub fn SDL_CreatePalette(ncolors: libc::c_int) -> *mut SDL_Palette;
}
unsafe extern "C" {
    pub fn SDL_SetPaletteColors(
        palette: *mut SDL_Palette,
        colors: *const SDL_Color,
        firstcolor: libc::c_int,
        ncolors: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_DestroyPalette(palette: *mut SDL_Palette);
}
unsafe extern "C" {
    pub fn SDL_MapRGB(
        format: *const SDL_PixelFormatDetails,
        palette: *const SDL_Palette,
        r: Uint8,
        g: Uint8,
        b: Uint8,
    ) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_MapRGBA(
        format: *const SDL_PixelFormatDetails,
        palette: *const SDL_Palette,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_GetRGB(
        pixel: Uint32,
        format: *const SDL_PixelFormatDetails,
        palette: *const SDL_Palette,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    );
}
unsafe extern "C" {
    pub fn SDL_GetRGBA(
        pixel: Uint32,
        format: *const SDL_PixelFormatDetails,
        palette: *const SDL_Palette,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    );
}
unsafe extern "C" {
    pub fn SDL_HasRectIntersection(A: *const SDL_Rect, B: *const SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRectIntersection(
        A: *const SDL_Rect,
        B: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRectUnion(A: *const SDL_Rect, B: *const SDL_Rect, result: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRectEnclosingPoints(
        points: *const SDL_Point,
        count: libc::c_int,
        clip: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRectAndLineIntersection(
        rect: *const SDL_Rect,
        X1: *mut libc::c_int,
        Y1: *mut libc::c_int,
        X2: *mut libc::c_int,
        Y2: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasRectIntersectionFloat(A: *const SDL_FRect, B: *const SDL_FRect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRectIntersectionFloat(
        A: *const SDL_FRect,
        B: *const SDL_FRect,
        result: *mut SDL_FRect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRectUnionFloat(
        A: *const SDL_FRect,
        B: *const SDL_FRect,
        result: *mut SDL_FRect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRectEnclosingPointsFloat(
        points: *const SDL_FPoint,
        count: libc::c_int,
        clip: *const SDL_FRect,
        result: *mut SDL_FRect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRectAndLineIntersectionFloat(
        rect: *const SDL_FRect,
        X1: *mut f32,
        Y1: *mut f32,
        X2: *mut f32,
        Y2: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CreateSurface(
        width: libc::c_int,
        height: libc::c_int,
        format: SDL_PixelFormat,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    pub fn SDL_CreateSurfaceFrom(
        width: libc::c_int,
        height: libc::c_int,
        format: SDL_PixelFormat,
        pixels: *mut libc::c_void,
        pitch: libc::c_int,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    pub fn SDL_DestroySurface(surface: *mut SDL_Surface);
}
unsafe extern "C" {
    pub fn SDL_GetSurfaceProperties(surface: *mut SDL_Surface) -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_SetSurfaceColorspace(surface: *mut SDL_Surface, colorspace: SDL_Colorspace) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetSurfaceColorspace(surface: *mut SDL_Surface) -> SDL_Colorspace;
}
unsafe extern "C" {
    pub fn SDL_CreateSurfacePalette(surface: *mut SDL_Surface) -> *mut SDL_Palette;
}
unsafe extern "C" {
    pub fn SDL_SetSurfacePalette(surface: *mut SDL_Surface, palette: *mut SDL_Palette) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetSurfacePalette(surface: *mut SDL_Surface) -> *mut SDL_Palette;
}
unsafe extern "C" {
    pub fn SDL_AddSurfaceAlternateImage(surface: *mut SDL_Surface, image: *mut SDL_Surface)
        -> bool;
}
unsafe extern "C" {
    pub fn SDL_SurfaceHasAlternateImages(surface: *mut SDL_Surface) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetSurfaceImages(
        surface: *mut SDL_Surface,
        count: *mut libc::c_int,
    ) -> *mut *mut SDL_Surface;
}
unsafe extern "C" {
    pub fn SDL_RemoveSurfaceAlternateImages(surface: *mut SDL_Surface);
}
unsafe extern "C" {
    pub fn SDL_LockSurface(surface: *mut SDL_Surface) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
}
unsafe extern "C" {
    pub fn SDL_LoadBMP_IO(src: *mut SDL_IOStream, closeio: bool) -> *mut SDL_Surface;
}
unsafe extern "C" {
    pub fn SDL_LoadBMP(file: *const libc::c_char) -> *mut SDL_Surface;
}
unsafe extern "C" {
    pub fn SDL_SaveBMP_IO(surface: *mut SDL_Surface, dst: *mut SDL_IOStream, closeio: bool)
        -> bool;
}
unsafe extern "C" {
    pub fn SDL_SaveBMP(surface: *mut SDL_Surface, file: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetSurfaceRLE(surface: *mut SDL_Surface, enabled: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SurfaceHasRLE(surface: *mut SDL_Surface) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetSurfaceColorKey(surface: *mut SDL_Surface, enabled: bool, key: Uint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SurfaceHasColorKey(surface: *mut SDL_Surface) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetSurfaceColorKey(surface: *mut SDL_Surface, key: *mut Uint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetSurfaceColorMod(surface: *mut SDL_Surface, r: Uint8, g: Uint8, b: Uint8) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetSurfaceColorMod(
        surface: *mut SDL_Surface,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: Uint8) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: *mut Uint8) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetSurfaceBlendMode(surface: *mut SDL_Surface, blendMode: SDL_BlendMode) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetSurfaceBlendMode(
        surface: *mut SDL_Surface,
        blendMode: *mut SDL_BlendMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetSurfaceClipRect(surface: *mut SDL_Surface, rect: *const SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetSurfaceClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_FlipSurface(surface: *mut SDL_Surface, flip: SDL_FlipMode) -> bool;
}
unsafe extern "C" {
    pub fn SDL_DuplicateSurface(surface: *mut SDL_Surface) -> *mut SDL_Surface;
}
unsafe extern "C" {
    pub fn SDL_ScaleSurface(
        surface: *mut SDL_Surface,
        width: libc::c_int,
        height: libc::c_int,
        scaleMode: SDL_ScaleMode,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    pub fn SDL_ConvertSurface(
        surface: *mut SDL_Surface,
        format: SDL_PixelFormat,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    pub fn SDL_ConvertSurfaceAndColorspace(
        surface: *mut SDL_Surface,
        format: SDL_PixelFormat,
        palette: *mut SDL_Palette,
        colorspace: SDL_Colorspace,
        props: SDL_PropertiesID,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    pub fn SDL_ConvertPixels(
        width: libc::c_int,
        height: libc::c_int,
        src_format: SDL_PixelFormat,
        src: *const libc::c_void,
        src_pitch: libc::c_int,
        dst_format: SDL_PixelFormat,
        dst: *mut libc::c_void,
        dst_pitch: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ConvertPixelsAndColorspace(
        width: libc::c_int,
        height: libc::c_int,
        src_format: SDL_PixelFormat,
        src_colorspace: SDL_Colorspace,
        src_properties: SDL_PropertiesID,
        src: *const libc::c_void,
        src_pitch: libc::c_int,
        dst_format: SDL_PixelFormat,
        dst_colorspace: SDL_Colorspace,
        dst_properties: SDL_PropertiesID,
        dst: *mut libc::c_void,
        dst_pitch: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_PremultiplyAlpha(
        width: libc::c_int,
        height: libc::c_int,
        src_format: SDL_PixelFormat,
        src: *const libc::c_void,
        src_pitch: libc::c_int,
        dst_format: SDL_PixelFormat,
        dst: *mut libc::c_void,
        dst_pitch: libc::c_int,
        linear: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_PremultiplySurfaceAlpha(surface: *mut SDL_Surface, linear: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ClearSurface(surface: *mut SDL_Surface, r: f32, g: f32, b: f32, a: f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_FillSurfaceRect(dst: *mut SDL_Surface, rect: *const SDL_Rect, color: Uint32)
        -> bool;
}
unsafe extern "C" {
    pub fn SDL_FillSurfaceRects(
        dst: *mut SDL_Surface,
        rects: *const SDL_Rect,
        count: libc::c_int,
        color: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_BlitSurface(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_BlitSurfaceUnchecked(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_BlitSurfaceScaled(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
        scaleMode: SDL_ScaleMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_BlitSurfaceUncheckedScaled(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
        scaleMode: SDL_ScaleMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_StretchSurface(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
        scaleMode: SDL_ScaleMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_BlitSurfaceTiled(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_BlitSurfaceTiledWithScale(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        scale: f32,
        scaleMode: SDL_ScaleMode,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_BlitSurface9Grid(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        left_width: libc::c_int,
        right_width: libc::c_int,
        top_height: libc::c_int,
        bottom_height: libc::c_int,
        scale: f32,
        scaleMode: SDL_ScaleMode,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_MapSurfaceRGB(surface: *mut SDL_Surface, r: Uint8, g: Uint8, b: Uint8) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_MapSurfaceRGBA(
        surface: *mut SDL_Surface,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_ReadSurfacePixel(
        surface: *mut SDL_Surface,
        x: libc::c_int,
        y: libc::c_int,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadSurfacePixelFloat(
        surface: *mut SDL_Surface,
        x: libc::c_int,
        y: libc::c_int,
        r: *mut f32,
        g: *mut f32,
        b: *mut f32,
        a: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteSurfacePixel(
        surface: *mut SDL_Surface,
        x: libc::c_int,
        y: libc::c_int,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteSurfacePixelFloat(
        surface: *mut SDL_Surface,
        x: libc::c_int,
        y: libc::c_int,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetNumCameraDrivers() -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetCameraDriver(index: libc::c_int) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetCurrentCameraDriver() -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetCameras(count: *mut libc::c_int) -> *mut SDL_CameraID;
}
unsafe extern "C" {
    pub fn SDL_GetCameraSupportedFormats(
        instance_id: SDL_CameraID,
        count: *mut libc::c_int,
    ) -> *mut *mut SDL_CameraSpec;
}
unsafe extern "C" {
    pub fn SDL_GetCameraName(instance_id: SDL_CameraID) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetCameraPosition(instance_id: SDL_CameraID) -> SDL_CameraPosition;
}
unsafe extern "C" {
    pub fn SDL_OpenCamera(
        instance_id: SDL_CameraID,
        spec: *const SDL_CameraSpec,
    ) -> *mut SDL_Camera;
}
unsafe extern "C" {
    pub fn SDL_GetCameraPermissionState(camera: *mut SDL_Camera) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetCameraID(camera: *mut SDL_Camera) -> SDL_CameraID;
}
unsafe extern "C" {
    pub fn SDL_GetCameraProperties(camera: *mut SDL_Camera) -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_GetCameraFormat(camera: *mut SDL_Camera, spec: *mut SDL_CameraSpec) -> bool;
}
unsafe extern "C" {
    pub fn SDL_AcquireCameraFrame(
        camera: *mut SDL_Camera,
        timestampNS: *mut Uint64,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    pub fn SDL_ReleaseCameraFrame(camera: *mut SDL_Camera, frame: *mut SDL_Surface);
}
unsafe extern "C" {
    pub fn SDL_CloseCamera(camera: *mut SDL_Camera);
}
unsafe extern "C" {
    pub fn SDL_SetClipboardText(text: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetClipboardText() -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_HasClipboardText() -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetPrimarySelectionText(text: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetPrimarySelectionText() -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_HasPrimarySelectionText() -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetClipboardData(
        callback: SDL_ClipboardDataCallback,
        cleanup: SDL_ClipboardCleanupCallback,
        userdata: *mut libc::c_void,
        mime_types: *mut *const libc::c_char,
        num_mime_types: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ClearClipboardData() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetClipboardData(
        mime_type: *const libc::c_char,
        size: *mut usize,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_HasClipboardData(mime_type: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetClipboardMimeTypes(num_mime_types: *mut usize) -> *mut *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetNumLogicalCPUCores() -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetCPUCacheLineSize() -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_HasAltiVec() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasMMX() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasSSE() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasSSE2() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasSSE3() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasSSE41() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasSSE42() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasAVX() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasAVX2() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasAVX512F() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasARMSIMD() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasNEON() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasLSX() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasLASX() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetSystemRAM() -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetSIMDAlignment() -> usize;
}
unsafe extern "C" {
    pub fn SDL_GetNumVideoDrivers() -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetVideoDriver(index: libc::c_int) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetCurrentVideoDriver() -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetSystemTheme() -> SDL_SystemTheme;
}
unsafe extern "C" {
    pub fn SDL_GetDisplays(count: *mut libc::c_int) -> *mut SDL_DisplayID;
}
unsafe extern "C" {
    pub fn SDL_GetPrimaryDisplay() -> SDL_DisplayID;
}
unsafe extern "C" {
    pub fn SDL_GetDisplayProperties(displayID: SDL_DisplayID) -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_GetDisplayName(displayID: SDL_DisplayID) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetDisplayBounds(displayID: SDL_DisplayID, rect: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetDisplayUsableBounds(displayID: SDL_DisplayID, rect: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetNaturalDisplayOrientation(displayID: SDL_DisplayID) -> SDL_DisplayOrientation;
}
unsafe extern "C" {
    pub fn SDL_GetCurrentDisplayOrientation(displayID: SDL_DisplayID) -> SDL_DisplayOrientation;
}
unsafe extern "C" {
    pub fn SDL_GetDisplayContentScale(displayID: SDL_DisplayID) -> f32;
}
unsafe extern "C" {
    pub fn SDL_GetFullscreenDisplayModes(
        displayID: SDL_DisplayID,
        count: *mut libc::c_int,
    ) -> *mut *mut SDL_DisplayMode;
}
unsafe extern "C" {
    pub fn SDL_GetClosestFullscreenDisplayMode(
        displayID: SDL_DisplayID,
        w: libc::c_int,
        h: libc::c_int,
        refresh_rate: f32,
        include_high_density_modes: bool,
        closest: *mut SDL_DisplayMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetDesktopDisplayMode(displayID: SDL_DisplayID) -> *const SDL_DisplayMode;
}
unsafe extern "C" {
    pub fn SDL_GetCurrentDisplayMode(displayID: SDL_DisplayID) -> *const SDL_DisplayMode;
}
unsafe extern "C" {
    pub fn SDL_GetDisplayForPoint(point: *const SDL_Point) -> SDL_DisplayID;
}
unsafe extern "C" {
    pub fn SDL_GetDisplayForRect(rect: *const SDL_Rect) -> SDL_DisplayID;
}
unsafe extern "C" {
    pub fn SDL_GetDisplayForWindow(window: *mut SDL_Window) -> SDL_DisplayID;
}
unsafe extern "C" {
    pub fn SDL_GetWindowPixelDensity(window: *mut SDL_Window) -> f32;
}
unsafe extern "C" {
    pub fn SDL_GetWindowDisplayScale(window: *mut SDL_Window) -> f32;
}
unsafe extern "C" {
    pub fn SDL_SetWindowFullscreenMode(
        window: *mut SDL_Window,
        mode: *const SDL_DisplayMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowFullscreenMode(window: *mut SDL_Window) -> *const SDL_DisplayMode;
}
unsafe extern "C" {
    pub fn SDL_GetWindowICCProfile(window: *mut SDL_Window, size: *mut usize) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_GetWindowPixelFormat(window: *mut SDL_Window) -> SDL_PixelFormat;
}
unsafe extern "C" {
    pub fn SDL_GetWindows(count: *mut libc::c_int) -> *mut *mut SDL_Window;
}
unsafe extern "C" {
    pub fn SDL_CreateWindow(
        title: *const libc::c_char,
        w: libc::c_int,
        h: libc::c_int,
        flags: SDL_WindowFlags,
    ) -> *mut SDL_Window;
}
unsafe extern "C" {
    pub fn SDL_CreatePopupWindow(
        parent: *mut SDL_Window,
        offset_x: libc::c_int,
        offset_y: libc::c_int,
        w: libc::c_int,
        h: libc::c_int,
        flags: SDL_WindowFlags,
    ) -> *mut SDL_Window;
}
unsafe extern "C" {
    pub fn SDL_CreateWindowWithProperties(props: SDL_PropertiesID) -> *mut SDL_Window;
}
unsafe extern "C" {
    pub fn SDL_GetWindowID(window: *mut SDL_Window) -> SDL_WindowID;
}
unsafe extern "C" {
    pub fn SDL_GetWindowFromID(id: SDL_WindowID) -> *mut SDL_Window;
}
unsafe extern "C" {
    pub fn SDL_GetWindowParent(window: *mut SDL_Window) -> *mut SDL_Window;
}
unsafe extern "C" {
    pub fn SDL_GetWindowProperties(window: *mut SDL_Window) -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_GetWindowFlags(window: *mut SDL_Window) -> SDL_WindowFlags;
}
unsafe extern "C" {
    pub fn SDL_SetWindowTitle(window: *mut SDL_Window, title: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowTitle(window: *mut SDL_Window) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_SetWindowIcon(window: *mut SDL_Window, icon: *mut SDL_Surface) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowPosition(window: *mut SDL_Window, x: libc::c_int, y: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowPosition(
        window: *mut SDL_Window,
        x: *mut libc::c_int,
        y: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowSize(window: *mut SDL_Window, w: libc::c_int, h: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowSafeArea(window: *mut SDL_Window, rect: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowAspectRatio(
        window: *mut SDL_Window,
        min_aspect: f32,
        max_aspect: f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowAspectRatio(
        window: *mut SDL_Window,
        min_aspect: *mut f32,
        max_aspect: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowBordersSize(
        window: *mut SDL_Window,
        top: *mut libc::c_int,
        left: *mut libc::c_int,
        bottom: *mut libc::c_int,
        right: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowSizeInPixels(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowMinimumSize(
        window: *mut SDL_Window,
        min_w: libc::c_int,
        min_h: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowMinimumSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowMaximumSize(
        window: *mut SDL_Window,
        max_w: libc::c_int,
        max_h: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowMaximumSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowBordered(window: *mut SDL_Window, bordered: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowResizable(window: *mut SDL_Window, resizable: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowAlwaysOnTop(window: *mut SDL_Window, on_top: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ShowWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_HideWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RaiseWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_MaximizeWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_MinimizeWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RestoreWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowFullscreen(window: *mut SDL_Window, fullscreen: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SyncWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WindowHasSurface(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowSurface(window: *mut SDL_Window) -> *mut SDL_Surface;
}
unsafe extern "C" {
    pub fn SDL_SetWindowSurfaceVSync(window: *mut SDL_Window, vsync: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowSurfaceVSync(window: *mut SDL_Window, vsync: *mut libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UpdateWindowSurface(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UpdateWindowSurfaceRects(
        window: *mut SDL_Window,
        rects: *const SDL_Rect,
        numrects: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_DestroyWindowSurface(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowKeyboardGrab(window: *mut SDL_Window, grabbed: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowMouseGrab(window: *mut SDL_Window, grabbed: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowKeyboardGrab(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowMouseGrab(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGrabbedWindow() -> *mut SDL_Window;
}
unsafe extern "C" {
    pub fn SDL_SetWindowMouseRect(window: *mut SDL_Window, rect: *const SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowMouseRect(window: *mut SDL_Window) -> *const SDL_Rect;
}
unsafe extern "C" {
    pub fn SDL_SetWindowOpacity(window: *mut SDL_Window, opacity: f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowOpacity(window: *mut SDL_Window) -> f32;
}
unsafe extern "C" {
    pub fn SDL_SetWindowParent(window: *mut SDL_Window, parent: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowModal(window: *mut SDL_Window, modal: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowFocusable(window: *mut SDL_Window, focusable: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ShowWindowSystemMenu(
        window: *mut SDL_Window,
        x: libc::c_int,
        y: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowHitTest(
        window: *mut SDL_Window,
        callback: SDL_HitTest,
        callback_data: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowShape(window: *mut SDL_Window, shape: *mut SDL_Surface) -> bool;
}
unsafe extern "C" {
    pub fn SDL_FlashWindow(window: *mut SDL_Window, operation: SDL_FlashOperation) -> bool;
}
unsafe extern "C" {
    pub fn SDL_DestroyWindow(window: *mut SDL_Window);
}
unsafe extern "C" {
    pub fn SDL_ScreenSaverEnabled() -> bool;
}
unsafe extern "C" {
    pub fn SDL_EnableScreenSaver() -> bool;
}
unsafe extern "C" {
    pub fn SDL_DisableScreenSaver() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GL_LoadLibrary(path: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GL_GetProcAddress(proc_: *const libc::c_char) -> SDL_FunctionPointer;
}
unsafe extern "C" {
    pub fn SDL_EGL_GetProcAddress(proc_: *const libc::c_char) -> SDL_FunctionPointer;
}
unsafe extern "C" {
    pub fn SDL_GL_UnloadLibrary();
}
unsafe extern "C" {
    pub fn SDL_GL_ExtensionSupported(extension: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GL_ResetAttributes();
}
unsafe extern "C" {
    pub fn SDL_GL_SetAttribute(attr: SDL_GLAttr, value: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GL_GetAttribute(attr: SDL_GLAttr, value: *mut libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GL_CreateContext(window: *mut SDL_Window) -> SDL_GLContext;
}
unsafe extern "C" {
    pub fn SDL_GL_MakeCurrent(window: *mut SDL_Window, context: SDL_GLContext) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GL_GetCurrentWindow() -> *mut SDL_Window;
}
unsafe extern "C" {
    pub fn SDL_GL_GetCurrentContext() -> SDL_GLContext;
}
unsafe extern "C" {
    pub fn SDL_EGL_GetCurrentDisplay() -> SDL_EGLDisplay;
}
unsafe extern "C" {
    pub fn SDL_EGL_GetCurrentConfig() -> SDL_EGLConfig;
}
unsafe extern "C" {
    pub fn SDL_EGL_GetWindowSurface(window: *mut SDL_Window) -> SDL_EGLSurface;
}
unsafe extern "C" {
    pub fn SDL_EGL_SetAttributeCallbacks(
        platformAttribCallback: SDL_EGLAttribArrayCallback,
        surfaceAttribCallback: SDL_EGLIntArrayCallback,
        contextAttribCallback: SDL_EGLIntArrayCallback,
        userdata: *mut libc::c_void,
    );
}
unsafe extern "C" {
    pub fn SDL_GL_SetSwapInterval(interval: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GL_GetSwapInterval(interval: *mut libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GL_SwapWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GL_DestroyContext(context: SDL_GLContext) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ShowOpenFileDialog(
        callback: SDL_DialogFileCallback,
        userdata: *mut libc::c_void,
        window: *mut SDL_Window,
        filters: *const SDL_DialogFileFilter,
        nfilters: libc::c_int,
        default_location: *const libc::c_char,
        allow_many: bool,
    );
}
unsafe extern "C" {
    pub fn SDL_ShowSaveFileDialog(
        callback: SDL_DialogFileCallback,
        userdata: *mut libc::c_void,
        window: *mut SDL_Window,
        filters: *const SDL_DialogFileFilter,
        nfilters: libc::c_int,
        default_location: *const libc::c_char,
    );
}
unsafe extern "C" {
    pub fn SDL_ShowOpenFolderDialog(
        callback: SDL_DialogFileCallback,
        userdata: *mut libc::c_void,
        window: *mut SDL_Window,
        default_location: *const libc::c_char,
        allow_many: bool,
    );
}
unsafe extern "C" {
    pub fn SDL_ShowFileDialogWithProperties(
        type_: SDL_FileDialogType,
        callback: SDL_DialogFileCallback,
        userdata: *mut libc::c_void,
        props: SDL_PropertiesID,
    );
}
unsafe extern "C" {
    pub fn SDL_GUIDToString(guid: SDL_GUID, pszGUID: *mut libc::c_char, cbGUID: libc::c_int);
}
unsafe extern "C" {
    pub fn SDL_StringToGUID(pchGUID: *const libc::c_char) -> SDL_GUID;
}
unsafe extern "C" {
    pub fn SDL_GetPowerInfo(seconds: *mut libc::c_int, percent: *mut libc::c_int)
        -> SDL_PowerState;
}
unsafe extern "C" {
    pub fn SDL_GetSensors(count: *mut libc::c_int) -> *mut SDL_SensorID;
}
unsafe extern "C" {
    pub fn SDL_GetSensorNameForID(instance_id: SDL_SensorID) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetSensorTypeForID(instance_id: SDL_SensorID) -> SDL_SensorType;
}
unsafe extern "C" {
    pub fn SDL_GetSensorNonPortableTypeForID(instance_id: SDL_SensorID) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_OpenSensor(instance_id: SDL_SensorID) -> *mut SDL_Sensor;
}
unsafe extern "C" {
    pub fn SDL_GetSensorFromID(instance_id: SDL_SensorID) -> *mut SDL_Sensor;
}
unsafe extern "C" {
    pub fn SDL_GetSensorProperties(sensor: *mut SDL_Sensor) -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_GetSensorName(sensor: *mut SDL_Sensor) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetSensorType(sensor: *mut SDL_Sensor) -> SDL_SensorType;
}
unsafe extern "C" {
    pub fn SDL_GetSensorNonPortableType(sensor: *mut SDL_Sensor) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetSensorID(sensor: *mut SDL_Sensor) -> SDL_SensorID;
}
unsafe extern "C" {
    pub fn SDL_GetSensorData(
        sensor: *mut SDL_Sensor,
        data: *mut f32,
        num_values: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CloseSensor(sensor: *mut SDL_Sensor);
}
unsafe extern "C" {
    pub fn SDL_UpdateSensors();
}
unsafe extern "C" {
    pub fn SDL_LockJoysticks();
}
unsafe extern "C" {
    pub fn SDL_UnlockJoysticks();
}
unsafe extern "C" {
    pub fn SDL_HasJoystick() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetJoysticks(count: *mut libc::c_int) -> *mut SDL_JoystickID;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickNameForID(instance_id: SDL_JoystickID) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickPathForID(instance_id: SDL_JoystickID) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickPlayerIndexForID(instance_id: SDL_JoystickID) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickGUIDForID(instance_id: SDL_JoystickID) -> SDL_GUID;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickVendorForID(instance_id: SDL_JoystickID) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickProductForID(instance_id: SDL_JoystickID) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickProductVersionForID(instance_id: SDL_JoystickID) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickTypeForID(instance_id: SDL_JoystickID) -> SDL_JoystickType;
}
unsafe extern "C" {
    pub fn SDL_OpenJoystick(instance_id: SDL_JoystickID) -> *mut SDL_Joystick;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickFromID(instance_id: SDL_JoystickID) -> *mut SDL_Joystick;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickFromPlayerIndex(player_index: libc::c_int) -> *mut SDL_Joystick;
}
unsafe extern "C" {
    pub fn SDL_AttachVirtualJoystick(desc: *const SDL_VirtualJoystickDesc) -> SDL_JoystickID;
}
unsafe extern "C" {
    pub fn SDL_DetachVirtualJoystick(instance_id: SDL_JoystickID) -> bool;
}
unsafe extern "C" {
    pub fn SDL_IsJoystickVirtual(instance_id: SDL_JoystickID) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetJoystickVirtualAxis(
        joystick: *mut SDL_Joystick,
        axis: libc::c_int,
        value: Sint16,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetJoystickVirtualBall(
        joystick: *mut SDL_Joystick,
        ball: libc::c_int,
        xrel: Sint16,
        yrel: Sint16,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetJoystickVirtualButton(
        joystick: *mut SDL_Joystick,
        button: libc::c_int,
        down: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetJoystickVirtualHat(
        joystick: *mut SDL_Joystick,
        hat: libc::c_int,
        value: Uint8,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetJoystickVirtualTouchpad(
        joystick: *mut SDL_Joystick,
        touchpad: libc::c_int,
        finger: libc::c_int,
        down: bool,
        x: f32,
        y: f32,
        pressure: f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SendJoystickVirtualSensorData(
        joystick: *mut SDL_Joystick,
        type_: SDL_SensorType,
        sensor_timestamp: Uint64,
        data: *const f32,
        num_values: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickProperties(joystick: *mut SDL_Joystick) -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickName(joystick: *mut SDL_Joystick) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickPath(joystick: *mut SDL_Joystick) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickPlayerIndex(joystick: *mut SDL_Joystick) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_SetJoystickPlayerIndex(
        joystick: *mut SDL_Joystick,
        player_index: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickGUID(joystick: *mut SDL_Joystick) -> SDL_GUID;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickVendor(joystick: *mut SDL_Joystick) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickProduct(joystick: *mut SDL_Joystick) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickProductVersion(joystick: *mut SDL_Joystick) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickFirmwareVersion(joystick: *mut SDL_Joystick) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickSerial(joystick: *mut SDL_Joystick) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickType(joystick: *mut SDL_Joystick) -> SDL_JoystickType;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickGUIDInfo(
        guid: SDL_GUID,
        vendor: *mut Uint16,
        product: *mut Uint16,
        version: *mut Uint16,
        crc16: *mut Uint16,
    );
}
unsafe extern "C" {
    pub fn SDL_JoystickConnected(joystick: *mut SDL_Joystick) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickID(joystick: *mut SDL_Joystick) -> SDL_JoystickID;
}
unsafe extern "C" {
    pub fn SDL_GetNumJoystickAxes(joystick: *mut SDL_Joystick) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetNumJoystickBalls(joystick: *mut SDL_Joystick) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetNumJoystickHats(joystick: *mut SDL_Joystick) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetNumJoystickButtons(joystick: *mut SDL_Joystick) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_SetJoystickEventsEnabled(enabled: bool);
}
unsafe extern "C" {
    pub fn SDL_JoystickEventsEnabled() -> bool;
}
unsafe extern "C" {
    pub fn SDL_UpdateJoysticks();
}
unsafe extern "C" {
    pub fn SDL_GetJoystickAxis(joystick: *mut SDL_Joystick, axis: libc::c_int) -> Sint16;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickAxisInitialState(
        joystick: *mut SDL_Joystick,
        axis: libc::c_int,
        state: *mut Sint16,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickBall(
        joystick: *mut SDL_Joystick,
        ball: libc::c_int,
        dx: *mut libc::c_int,
        dy: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickHat(joystick: *mut SDL_Joystick, hat: libc::c_int) -> Uint8;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickButton(joystick: *mut SDL_Joystick, button: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RumbleJoystick(
        joystick: *mut SDL_Joystick,
        low_frequency_rumble: Uint16,
        high_frequency_rumble: Uint16,
        duration_ms: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RumbleJoystickTriggers(
        joystick: *mut SDL_Joystick,
        left_rumble: Uint16,
        right_rumble: Uint16,
        duration_ms: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetJoystickLED(
        joystick: *mut SDL_Joystick,
        red: Uint8,
        green: Uint8,
        blue: Uint8,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SendJoystickEffect(
        joystick: *mut SDL_Joystick,
        data: *const libc::c_void,
        size: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CloseJoystick(joystick: *mut SDL_Joystick);
}
unsafe extern "C" {
    pub fn SDL_GetJoystickConnectionState(
        joystick: *mut SDL_Joystick,
    ) -> SDL_JoystickConnectionState;
}
unsafe extern "C" {
    pub fn SDL_GetJoystickPowerInfo(
        joystick: *mut SDL_Joystick,
        percent: *mut libc::c_int,
    ) -> SDL_PowerState;
}
unsafe extern "C" {
    pub fn SDL_AddGamepadMapping(mapping: *const libc::c_char) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_AddGamepadMappingsFromIO(src: *mut SDL_IOStream, closeio: bool) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_AddGamepadMappingsFromFile(file: *const libc::c_char) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_ReloadGamepadMappings() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadMappings(count: *mut libc::c_int) -> *mut *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadMappingForGUID(guid: SDL_GUID) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadMapping(gamepad: *mut SDL_Gamepad) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_SetGamepadMapping(instance_id: SDL_JoystickID, mapping: *const libc::c_char)
        -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasGamepad() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGamepads(count: *mut libc::c_int) -> *mut SDL_JoystickID;
}
unsafe extern "C" {
    pub fn SDL_IsGamepad(instance_id: SDL_JoystickID) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadNameForID(instance_id: SDL_JoystickID) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadPathForID(instance_id: SDL_JoystickID) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadPlayerIndexForID(instance_id: SDL_JoystickID) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadGUIDForID(instance_id: SDL_JoystickID) -> SDL_GUID;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadVendorForID(instance_id: SDL_JoystickID) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadProductForID(instance_id: SDL_JoystickID) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadProductVersionForID(instance_id: SDL_JoystickID) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadTypeForID(instance_id: SDL_JoystickID) -> SDL_GamepadType;
}
unsafe extern "C" {
    pub fn SDL_GetRealGamepadTypeForID(instance_id: SDL_JoystickID) -> SDL_GamepadType;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadMappingForID(instance_id: SDL_JoystickID) -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_OpenGamepad(instance_id: SDL_JoystickID) -> *mut SDL_Gamepad;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadFromID(instance_id: SDL_JoystickID) -> *mut SDL_Gamepad;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadFromPlayerIndex(player_index: libc::c_int) -> *mut SDL_Gamepad;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadProperties(gamepad: *mut SDL_Gamepad) -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadID(gamepad: *mut SDL_Gamepad) -> SDL_JoystickID;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadName(gamepad: *mut SDL_Gamepad) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadPath(gamepad: *mut SDL_Gamepad) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadType(gamepad: *mut SDL_Gamepad) -> SDL_GamepadType;
}
unsafe extern "C" {
    pub fn SDL_GetRealGamepadType(gamepad: *mut SDL_Gamepad) -> SDL_GamepadType;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadPlayerIndex(gamepad: *mut SDL_Gamepad) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_SetGamepadPlayerIndex(gamepad: *mut SDL_Gamepad, player_index: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadVendor(gamepad: *mut SDL_Gamepad) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadProduct(gamepad: *mut SDL_Gamepad) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadProductVersion(gamepad: *mut SDL_Gamepad) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadFirmwareVersion(gamepad: *mut SDL_Gamepad) -> Uint16;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadSerial(gamepad: *mut SDL_Gamepad) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadSteamHandle(gamepad: *mut SDL_Gamepad) -> Uint64;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadConnectionState(gamepad: *mut SDL_Gamepad) -> SDL_JoystickConnectionState;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadPowerInfo(
        gamepad: *mut SDL_Gamepad,
        percent: *mut libc::c_int,
    ) -> SDL_PowerState;
}
unsafe extern "C" {
    pub fn SDL_GamepadConnected(gamepad: *mut SDL_Gamepad) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadJoystick(gamepad: *mut SDL_Gamepad) -> *mut SDL_Joystick;
}
unsafe extern "C" {
    pub fn SDL_SetGamepadEventsEnabled(enabled: bool);
}
unsafe extern "C" {
    pub fn SDL_GamepadEventsEnabled() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadBindings(
        gamepad: *mut SDL_Gamepad,
        count: *mut libc::c_int,
    ) -> *mut *mut SDL_GamepadBinding;
}
unsafe extern "C" {
    pub fn SDL_UpdateGamepads();
}
unsafe extern "C" {
    pub fn SDL_GetGamepadTypeFromString(str_: *const libc::c_char) -> SDL_GamepadType;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadStringForType(type_: SDL_GamepadType) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadAxisFromString(str_: *const libc::c_char) -> SDL_GamepadAxis;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadStringForAxis(axis: SDL_GamepadAxis) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GamepadHasAxis(gamepad: *mut SDL_Gamepad, axis: SDL_GamepadAxis) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadAxis(gamepad: *mut SDL_Gamepad, axis: SDL_GamepadAxis) -> Sint16;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadButtonFromString(str_: *const libc::c_char) -> SDL_GamepadButton;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadStringForButton(button: SDL_GamepadButton) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GamepadHasButton(gamepad: *mut SDL_Gamepad, button: SDL_GamepadButton) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadButton(gamepad: *mut SDL_Gamepad, button: SDL_GamepadButton) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadButtonLabelForType(
        type_: SDL_GamepadType,
        button: SDL_GamepadButton,
    ) -> SDL_GamepadButtonLabel;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadButtonLabel(
        gamepad: *mut SDL_Gamepad,
        button: SDL_GamepadButton,
    ) -> SDL_GamepadButtonLabel;
}
unsafe extern "C" {
    pub fn SDL_GetNumGamepadTouchpads(gamepad: *mut SDL_Gamepad) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetNumGamepadTouchpadFingers(
        gamepad: *mut SDL_Gamepad,
        touchpad: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadTouchpadFinger(
        gamepad: *mut SDL_Gamepad,
        touchpad: libc::c_int,
        finger: libc::c_int,
        down: *mut bool,
        x: *mut f32,
        y: *mut f32,
        pressure: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GamepadHasSensor(gamepad: *mut SDL_Gamepad, type_: SDL_SensorType) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetGamepadSensorEnabled(
        gamepad: *mut SDL_Gamepad,
        type_: SDL_SensorType,
        enabled: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GamepadSensorEnabled(gamepad: *mut SDL_Gamepad, type_: SDL_SensorType) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadSensorDataRate(gamepad: *mut SDL_Gamepad, type_: SDL_SensorType) -> f32;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadSensorData(
        gamepad: *mut SDL_Gamepad,
        type_: SDL_SensorType,
        data: *mut f32,
        num_values: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RumbleGamepad(
        gamepad: *mut SDL_Gamepad,
        low_frequency_rumble: Uint16,
        high_frequency_rumble: Uint16,
        duration_ms: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RumbleGamepadTriggers(
        gamepad: *mut SDL_Gamepad,
        left_rumble: Uint16,
        right_rumble: Uint16,
        duration_ms: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetGamepadLED(
        gamepad: *mut SDL_Gamepad,
        red: Uint8,
        green: Uint8,
        blue: Uint8,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SendGamepadEffect(
        gamepad: *mut SDL_Gamepad,
        data: *const libc::c_void,
        size: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CloseGamepad(gamepad: *mut SDL_Gamepad);
}
unsafe extern "C" {
    pub fn SDL_GetGamepadAppleSFSymbolsNameForButton(
        gamepad: *mut SDL_Gamepad,
        button: SDL_GamepadButton,
    ) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetGamepadAppleSFSymbolsNameForAxis(
        gamepad: *mut SDL_Gamepad,
        axis: SDL_GamepadAxis,
    ) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_HasKeyboard() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetKeyboards(count: *mut libc::c_int) -> *mut SDL_KeyboardID;
}
unsafe extern "C" {
    pub fn SDL_GetKeyboardNameForID(instance_id: SDL_KeyboardID) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetKeyboardFocus() -> *mut SDL_Window;
}
unsafe extern "C" {
    pub fn SDL_GetKeyboardState(numkeys: *mut libc::c_int) -> *const bool;
}
unsafe extern "C" {
    pub fn SDL_ResetKeyboard();
}
unsafe extern "C" {
    pub fn SDL_GetModState() -> SDL_Keymod;
}
unsafe extern "C" {
    pub fn SDL_SetModState(modstate: SDL_Keymod);
}
unsafe extern "C" {
    pub fn SDL_GetKeyFromScancode(
        scancode: SDL_Scancode,
        modstate: SDL_Keymod,
        key_event: bool,
    ) -> SDL_Keycode;
}
unsafe extern "C" {
    pub fn SDL_GetScancodeFromKey(key: SDL_Keycode, modstate: *mut SDL_Keymod) -> SDL_Scancode;
}
unsafe extern "C" {
    pub fn SDL_SetScancodeName(scancode: SDL_Scancode, name: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetScancodeName(scancode: SDL_Scancode) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetScancodeFromName(name: *const libc::c_char) -> SDL_Scancode;
}
unsafe extern "C" {
    pub fn SDL_GetKeyName(key: SDL_Keycode) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetKeyFromName(name: *const libc::c_char) -> SDL_Keycode;
}
unsafe extern "C" {
    pub fn SDL_StartTextInput(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_StartTextInputWithProperties(
        window: *mut SDL_Window,
        props: SDL_PropertiesID,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_TextInputActive(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_StopTextInput(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ClearComposition(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetTextInputArea(
        window: *mut SDL_Window,
        rect: *const SDL_Rect,
        cursor: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetTextInputArea(
        window: *mut SDL_Window,
        rect: *mut SDL_Rect,
        cursor: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasScreenKeyboardSupport() -> bool;
}
unsafe extern "C" {
    pub fn SDL_ScreenKeyboardShown(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasMouse() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetMice(count: *mut libc::c_int) -> *mut SDL_MouseID;
}
unsafe extern "C" {
    pub fn SDL_GetMouseNameForID(instance_id: SDL_MouseID) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetMouseFocus() -> *mut SDL_Window;
}
unsafe extern "C" {
    pub fn SDL_GetMouseState(x: *mut f32, y: *mut f32) -> SDL_MouseButtonFlags;
}
unsafe extern "C" {
    pub fn SDL_GetGlobalMouseState(x: *mut f32, y: *mut f32) -> SDL_MouseButtonFlags;
}
unsafe extern "C" {
    pub fn SDL_GetRelativeMouseState(x: *mut f32, y: *mut f32) -> SDL_MouseButtonFlags;
}
unsafe extern "C" {
    pub fn SDL_WarpMouseInWindow(window: *mut SDL_Window, x: f32, y: f32);
}
unsafe extern "C" {
    pub fn SDL_WarpMouseGlobal(x: f32, y: f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetWindowRelativeMouseMode(window: *mut SDL_Window, enabled: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetWindowRelativeMouseMode(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CaptureMouse(enabled: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CreateCursor(
        data: *const Uint8,
        mask: *const Uint8,
        w: libc::c_int,
        h: libc::c_int,
        hot_x: libc::c_int,
        hot_y: libc::c_int,
    ) -> *mut SDL_Cursor;
}
unsafe extern "C" {
    pub fn SDL_CreateColorCursor(
        surface: *mut SDL_Surface,
        hot_x: libc::c_int,
        hot_y: libc::c_int,
    ) -> *mut SDL_Cursor;
}
unsafe extern "C" {
    pub fn SDL_CreateSystemCursor(id: SDL_SystemCursor) -> *mut SDL_Cursor;
}
unsafe extern "C" {
    pub fn SDL_SetCursor(cursor: *mut SDL_Cursor) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetCursor() -> *mut SDL_Cursor;
}
unsafe extern "C" {
    pub fn SDL_GetDefaultCursor() -> *mut SDL_Cursor;
}
unsafe extern "C" {
    pub fn SDL_DestroyCursor(cursor: *mut SDL_Cursor);
}
unsafe extern "C" {
    pub fn SDL_ShowCursor() -> bool;
}
unsafe extern "C" {
    pub fn SDL_HideCursor() -> bool;
}
unsafe extern "C" {
    pub fn SDL_CursorVisible() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetTouchDevices(count: *mut libc::c_int) -> *mut SDL_TouchID;
}
unsafe extern "C" {
    pub fn SDL_GetTouchDeviceName(touchID: SDL_TouchID) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetTouchDeviceType(touchID: SDL_TouchID) -> SDL_TouchDeviceType;
}
unsafe extern "C" {
    pub fn SDL_GetTouchFingers(
        touchID: SDL_TouchID,
        count: *mut libc::c_int,
    ) -> *mut *mut SDL_Finger;
}
unsafe extern "C" {
    pub fn SDL_PumpEvents();
}
unsafe extern "C" {
    pub fn SDL_PeepEvents(
        events: *mut SDL_Event,
        numevents: libc::c_int,
        action: SDL_EventAction,
        minType: Uint32,
        maxType: Uint32,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_HasEvent(type_: Uint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_HasEvents(minType: Uint32, maxType: Uint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_FlushEvent(type_: Uint32);
}
unsafe extern "C" {
    pub fn SDL_FlushEvents(minType: Uint32, maxType: Uint32);
}
unsafe extern "C" {
    pub fn SDL_PollEvent(event: *mut SDL_Event) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WaitEvent(event: *mut SDL_Event) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WaitEventTimeout(event: *mut SDL_Event, timeoutMS: Sint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_PushEvent(event: *mut SDL_Event) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetEventFilter(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
unsafe extern "C" {
    pub fn SDL_GetEventFilter(
        filter: *mut SDL_EventFilter,
        userdata: *mut *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_AddEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RemoveEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
unsafe extern "C" {
    pub fn SDL_FilterEvents(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
unsafe extern "C" {
    pub fn SDL_SetEventEnabled(type_: Uint32, enabled: bool);
}
unsafe extern "C" {
    pub fn SDL_EventEnabled(type_: Uint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RegisterEvents(numevents: libc::c_int) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_GetWindowFromEvent(event: *const SDL_Event) -> *mut SDL_Window;
}
unsafe extern "C" {
    pub fn SDL_GetBasePath() -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetPrefPath(org: *const libc::c_char, app: *const libc::c_char)
        -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetUserFolder(folder: SDL_Folder) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_CreateDirectory(path: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_EnumerateDirectory(
        path: *const libc::c_char,
        callback: SDL_EnumerateDirectoryCallback,
        userdata: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RemovePath(path: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenamePath(oldpath: *const libc::c_char, newpath: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CopyFile(oldpath: *const libc::c_char, newpath: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetPathInfo(path: *const libc::c_char, info: *mut SDL_PathInfo) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GlobDirectory(
        path: *const libc::c_char,
        pattern: *const libc::c_char,
        flags: SDL_GlobFlags,
        count: *mut libc::c_int,
    ) -> *mut *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetCurrentDirectory() -> *mut libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GPUSupportsShaderFormats(
        format_flags: SDL_GPUShaderFormat,
        name: *const libc::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GPUSupportsProperties(props: SDL_PropertiesID) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CreateGPUDevice(
        format_flags: SDL_GPUShaderFormat,
        debug_mode: bool,
        name: *const libc::c_char,
    ) -> *mut SDL_GPUDevice;
}
unsafe extern "C" {
    pub fn SDL_CreateGPUDeviceWithProperties(props: SDL_PropertiesID) -> *mut SDL_GPUDevice;
}
unsafe extern "C" {
    pub fn SDL_DestroyGPUDevice(device: *mut SDL_GPUDevice);
}
unsafe extern "C" {
    pub fn SDL_GetNumGPUDrivers() -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetGPUDriver(index: libc::c_int) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetGPUDeviceDriver(device: *mut SDL_GPUDevice) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetGPUShaderFormats(device: *mut SDL_GPUDevice) -> SDL_GPUShaderFormat;
}
unsafe extern "C" {
    pub fn SDL_CreateGPUComputePipeline(
        device: *mut SDL_GPUDevice,
        createinfo: *const SDL_GPUComputePipelineCreateInfo,
    ) -> *mut SDL_GPUComputePipeline;
}
unsafe extern "C" {
    pub fn SDL_CreateGPUGraphicsPipeline(
        device: *mut SDL_GPUDevice,
        createinfo: *const SDL_GPUGraphicsPipelineCreateInfo,
    ) -> *mut SDL_GPUGraphicsPipeline;
}
unsafe extern "C" {
    pub fn SDL_CreateGPUSampler(
        device: *mut SDL_GPUDevice,
        createinfo: *const SDL_GPUSamplerCreateInfo,
    ) -> *mut SDL_GPUSampler;
}
unsafe extern "C" {
    pub fn SDL_CreateGPUShader(
        device: *mut SDL_GPUDevice,
        createinfo: *const SDL_GPUShaderCreateInfo,
    ) -> *mut SDL_GPUShader;
}
unsafe extern "C" {
    pub fn SDL_CreateGPUTexture(
        device: *mut SDL_GPUDevice,
        createinfo: *const SDL_GPUTextureCreateInfo,
    ) -> *mut SDL_GPUTexture;
}
unsafe extern "C" {
    pub fn SDL_CreateGPUBuffer(
        device: *mut SDL_GPUDevice,
        createinfo: *const SDL_GPUBufferCreateInfo,
    ) -> *mut SDL_GPUBuffer;
}
unsafe extern "C" {
    pub fn SDL_CreateGPUTransferBuffer(
        device: *mut SDL_GPUDevice,
        createinfo: *const SDL_GPUTransferBufferCreateInfo,
    ) -> *mut SDL_GPUTransferBuffer;
}
unsafe extern "C" {
    pub fn SDL_SetGPUBufferName(
        device: *mut SDL_GPUDevice,
        buffer: *mut SDL_GPUBuffer,
        text: *const libc::c_char,
    );
}
unsafe extern "C" {
    pub fn SDL_SetGPUTextureName(
        device: *mut SDL_GPUDevice,
        texture: *mut SDL_GPUTexture,
        text: *const libc::c_char,
    );
}
unsafe extern "C" {
    pub fn SDL_InsertGPUDebugLabel(
        command_buffer: *mut SDL_GPUCommandBuffer,
        text: *const libc::c_char,
    );
}
unsafe extern "C" {
    pub fn SDL_PushGPUDebugGroup(
        command_buffer: *mut SDL_GPUCommandBuffer,
        name: *const libc::c_char,
    );
}
unsafe extern "C" {
    pub fn SDL_PopGPUDebugGroup(command_buffer: *mut SDL_GPUCommandBuffer);
}
unsafe extern "C" {
    pub fn SDL_ReleaseGPUTexture(device: *mut SDL_GPUDevice, texture: *mut SDL_GPUTexture);
}
unsafe extern "C" {
    pub fn SDL_ReleaseGPUSampler(device: *mut SDL_GPUDevice, sampler: *mut SDL_GPUSampler);
}
unsafe extern "C" {
    pub fn SDL_ReleaseGPUBuffer(device: *mut SDL_GPUDevice, buffer: *mut SDL_GPUBuffer);
}
unsafe extern "C" {
    pub fn SDL_ReleaseGPUTransferBuffer(
        device: *mut SDL_GPUDevice,
        transfer_buffer: *mut SDL_GPUTransferBuffer,
    );
}
unsafe extern "C" {
    pub fn SDL_ReleaseGPUComputePipeline(
        device: *mut SDL_GPUDevice,
        compute_pipeline: *mut SDL_GPUComputePipeline,
    );
}
unsafe extern "C" {
    pub fn SDL_ReleaseGPUShader(device: *mut SDL_GPUDevice, shader: *mut SDL_GPUShader);
}
unsafe extern "C" {
    pub fn SDL_ReleaseGPUGraphicsPipeline(
        device: *mut SDL_GPUDevice,
        graphics_pipeline: *mut SDL_GPUGraphicsPipeline,
    );
}
unsafe extern "C" {
    pub fn SDL_AcquireGPUCommandBuffer(device: *mut SDL_GPUDevice) -> *mut SDL_GPUCommandBuffer;
}
unsafe extern "C" {
    pub fn SDL_PushGPUVertexUniformData(
        command_buffer: *mut SDL_GPUCommandBuffer,
        slot_index: Uint32,
        data: *const libc::c_void,
        length: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_PushGPUFragmentUniformData(
        command_buffer: *mut SDL_GPUCommandBuffer,
        slot_index: Uint32,
        data: *const libc::c_void,
        length: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_PushGPUComputeUniformData(
        command_buffer: *mut SDL_GPUCommandBuffer,
        slot_index: Uint32,
        data: *const libc::c_void,
        length: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_BeginGPURenderPass(
        command_buffer: *mut SDL_GPUCommandBuffer,
        color_target_infos: *const SDL_GPUColorTargetInfo,
        num_color_targets: Uint32,
        depth_stencil_target_info: *const SDL_GPUDepthStencilTargetInfo,
    ) -> *mut SDL_GPURenderPass;
}
unsafe extern "C" {
    pub fn SDL_BindGPUGraphicsPipeline(
        render_pass: *mut SDL_GPURenderPass,
        graphics_pipeline: *mut SDL_GPUGraphicsPipeline,
    );
}
unsafe extern "C" {
    pub fn SDL_SetGPUViewport(
        render_pass: *mut SDL_GPURenderPass,
        viewport: *const SDL_GPUViewport,
    );
}
unsafe extern "C" {
    pub fn SDL_SetGPUScissor(render_pass: *mut SDL_GPURenderPass, scissor: *const SDL_Rect);
}
unsafe extern "C" {
    pub fn SDL_SetGPUBlendConstants(
        render_pass: *mut SDL_GPURenderPass,
        blend_constants: SDL_FColor,
    );
}
unsafe extern "C" {
    pub fn SDL_SetGPUStencilReference(render_pass: *mut SDL_GPURenderPass, reference: Uint8);
}
unsafe extern "C" {
    pub fn SDL_BindGPUVertexBuffers(
        render_pass: *mut SDL_GPURenderPass,
        first_slot: Uint32,
        bindings: *const SDL_GPUBufferBinding,
        num_bindings: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_BindGPUIndexBuffer(
        render_pass: *mut SDL_GPURenderPass,
        binding: *const SDL_GPUBufferBinding,
        index_element_size: SDL_GPUIndexElementSize,
    );
}
unsafe extern "C" {
    pub fn SDL_BindGPUVertexSamplers(
        render_pass: *mut SDL_GPURenderPass,
        first_slot: Uint32,
        texture_sampler_bindings: *const SDL_GPUTextureSamplerBinding,
        num_bindings: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_BindGPUVertexStorageTextures(
        render_pass: *mut SDL_GPURenderPass,
        first_slot: Uint32,
        storage_textures: *const *mut SDL_GPUTexture,
        num_bindings: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_BindGPUVertexStorageBuffers(
        render_pass: *mut SDL_GPURenderPass,
        first_slot: Uint32,
        storage_buffers: *const *mut SDL_GPUBuffer,
        num_bindings: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_BindGPUFragmentSamplers(
        render_pass: *mut SDL_GPURenderPass,
        first_slot: Uint32,
        texture_sampler_bindings: *const SDL_GPUTextureSamplerBinding,
        num_bindings: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_BindGPUFragmentStorageTextures(
        render_pass: *mut SDL_GPURenderPass,
        first_slot: Uint32,
        storage_textures: *const *mut SDL_GPUTexture,
        num_bindings: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_BindGPUFragmentStorageBuffers(
        render_pass: *mut SDL_GPURenderPass,
        first_slot: Uint32,
        storage_buffers: *const *mut SDL_GPUBuffer,
        num_bindings: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_DrawGPUIndexedPrimitives(
        render_pass: *mut SDL_GPURenderPass,
        num_indices: Uint32,
        num_instances: Uint32,
        first_index: Uint32,
        vertex_offset: Sint32,
        first_instance: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_DrawGPUPrimitives(
        render_pass: *mut SDL_GPURenderPass,
        num_vertices: Uint32,
        num_instances: Uint32,
        first_vertex: Uint32,
        first_instance: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_DrawGPUPrimitivesIndirect(
        render_pass: *mut SDL_GPURenderPass,
        buffer: *mut SDL_GPUBuffer,
        offset: Uint32,
        draw_count: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_DrawGPUIndexedPrimitivesIndirect(
        render_pass: *mut SDL_GPURenderPass,
        buffer: *mut SDL_GPUBuffer,
        offset: Uint32,
        draw_count: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_EndGPURenderPass(render_pass: *mut SDL_GPURenderPass);
}
unsafe extern "C" {
    pub fn SDL_BeginGPUComputePass(
        command_buffer: *mut SDL_GPUCommandBuffer,
        storage_texture_bindings: *const SDL_GPUStorageTextureReadWriteBinding,
        num_storage_texture_bindings: Uint32,
        storage_buffer_bindings: *const SDL_GPUStorageBufferReadWriteBinding,
        num_storage_buffer_bindings: Uint32,
    ) -> *mut SDL_GPUComputePass;
}
unsafe extern "C" {
    pub fn SDL_BindGPUComputePipeline(
        compute_pass: *mut SDL_GPUComputePass,
        compute_pipeline: *mut SDL_GPUComputePipeline,
    );
}
unsafe extern "C" {
    pub fn SDL_BindGPUComputeSamplers(
        compute_pass: *mut SDL_GPUComputePass,
        first_slot: Uint32,
        texture_sampler_bindings: *const SDL_GPUTextureSamplerBinding,
        num_bindings: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_BindGPUComputeStorageTextures(
        compute_pass: *mut SDL_GPUComputePass,
        first_slot: Uint32,
        storage_textures: *const *mut SDL_GPUTexture,
        num_bindings: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_BindGPUComputeStorageBuffers(
        compute_pass: *mut SDL_GPUComputePass,
        first_slot: Uint32,
        storage_buffers: *const *mut SDL_GPUBuffer,
        num_bindings: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_DispatchGPUCompute(
        compute_pass: *mut SDL_GPUComputePass,
        groupcount_x: Uint32,
        groupcount_y: Uint32,
        groupcount_z: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_DispatchGPUComputeIndirect(
        compute_pass: *mut SDL_GPUComputePass,
        buffer: *mut SDL_GPUBuffer,
        offset: Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_EndGPUComputePass(compute_pass: *mut SDL_GPUComputePass);
}
unsafe extern "C" {
    pub fn SDL_MapGPUTransferBuffer(
        device: *mut SDL_GPUDevice,
        transfer_buffer: *mut SDL_GPUTransferBuffer,
        cycle: bool,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_UnmapGPUTransferBuffer(
        device: *mut SDL_GPUDevice,
        transfer_buffer: *mut SDL_GPUTransferBuffer,
    );
}
unsafe extern "C" {
    pub fn SDL_BeginGPUCopyPass(command_buffer: *mut SDL_GPUCommandBuffer) -> *mut SDL_GPUCopyPass;
}
unsafe extern "C" {
    pub fn SDL_UploadToGPUTexture(
        copy_pass: *mut SDL_GPUCopyPass,
        source: *const SDL_GPUTextureTransferInfo,
        destination: *const SDL_GPUTextureRegion,
        cycle: bool,
    );
}
unsafe extern "C" {
    pub fn SDL_UploadToGPUBuffer(
        copy_pass: *mut SDL_GPUCopyPass,
        source: *const SDL_GPUTransferBufferLocation,
        destination: *const SDL_GPUBufferRegion,
        cycle: bool,
    );
}
unsafe extern "C" {
    pub fn SDL_CopyGPUTextureToTexture(
        copy_pass: *mut SDL_GPUCopyPass,
        source: *const SDL_GPUTextureLocation,
        destination: *const SDL_GPUTextureLocation,
        w: Uint32,
        h: Uint32,
        d: Uint32,
        cycle: bool,
    );
}
unsafe extern "C" {
    pub fn SDL_CopyGPUBufferToBuffer(
        copy_pass: *mut SDL_GPUCopyPass,
        source: *const SDL_GPUBufferLocation,
        destination: *const SDL_GPUBufferLocation,
        size: Uint32,
        cycle: bool,
    );
}
unsafe extern "C" {
    pub fn SDL_DownloadFromGPUTexture(
        copy_pass: *mut SDL_GPUCopyPass,
        source: *const SDL_GPUTextureRegion,
        destination: *const SDL_GPUTextureTransferInfo,
    );
}
unsafe extern "C" {
    pub fn SDL_DownloadFromGPUBuffer(
        copy_pass: *mut SDL_GPUCopyPass,
        source: *const SDL_GPUBufferRegion,
        destination: *const SDL_GPUTransferBufferLocation,
    );
}
unsafe extern "C" {
    pub fn SDL_EndGPUCopyPass(copy_pass: *mut SDL_GPUCopyPass);
}
unsafe extern "C" {
    pub fn SDL_GenerateMipmapsForGPUTexture(
        command_buffer: *mut SDL_GPUCommandBuffer,
        texture: *mut SDL_GPUTexture,
    );
}
unsafe extern "C" {
    pub fn SDL_BlitGPUTexture(
        command_buffer: *mut SDL_GPUCommandBuffer,
        info: *const SDL_GPUBlitInfo,
    );
}
unsafe extern "C" {
    pub fn SDL_WindowSupportsGPUSwapchainComposition(
        device: *mut SDL_GPUDevice,
        window: *mut SDL_Window,
        swapchain_composition: SDL_GPUSwapchainComposition,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WindowSupportsGPUPresentMode(
        device: *mut SDL_GPUDevice,
        window: *mut SDL_Window,
        present_mode: SDL_GPUPresentMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ClaimWindowForGPUDevice(device: *mut SDL_GPUDevice, window: *mut SDL_Window)
        -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReleaseWindowFromGPUDevice(device: *mut SDL_GPUDevice, window: *mut SDL_Window);
}
unsafe extern "C" {
    pub fn SDL_SetGPUSwapchainParameters(
        device: *mut SDL_GPUDevice,
        window: *mut SDL_Window,
        swapchain_composition: SDL_GPUSwapchainComposition,
        present_mode: SDL_GPUPresentMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetGPUAllowedFramesInFlight(
        device: *mut SDL_GPUDevice,
        allowed_frames_in_flight: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetGPUSwapchainTextureFormat(
        device: *mut SDL_GPUDevice,
        window: *mut SDL_Window,
    ) -> SDL_GPUTextureFormat;
}
unsafe extern "C" {
    pub fn SDL_AcquireGPUSwapchainTexture(
        command_buffer: *mut SDL_GPUCommandBuffer,
        window: *mut SDL_Window,
        swapchain_texture: *mut *mut SDL_GPUTexture,
        swapchain_texture_width: *mut Uint32,
        swapchain_texture_height: *mut Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WaitForGPUSwapchain(device: *mut SDL_GPUDevice, window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WaitAndAcquireGPUSwapchainTexture(
        command_buffer: *mut SDL_GPUCommandBuffer,
        window: *mut SDL_Window,
        swapchain_texture: *mut *mut SDL_GPUTexture,
        swapchain_texture_width: *mut Uint32,
        swapchain_texture_height: *mut Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SubmitGPUCommandBuffer(command_buffer: *mut SDL_GPUCommandBuffer) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SubmitGPUCommandBufferAndAcquireFence(
        command_buffer: *mut SDL_GPUCommandBuffer,
    ) -> *mut SDL_GPUFence;
}
unsafe extern "C" {
    pub fn SDL_CancelGPUCommandBuffer(command_buffer: *mut SDL_GPUCommandBuffer) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WaitForGPUIdle(device: *mut SDL_GPUDevice) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WaitForGPUFences(
        device: *mut SDL_GPUDevice,
        wait_all: bool,
        fences: *const *mut SDL_GPUFence,
        num_fences: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_QueryGPUFence(device: *mut SDL_GPUDevice, fence: *mut SDL_GPUFence) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReleaseGPUFence(device: *mut SDL_GPUDevice, fence: *mut SDL_GPUFence);
}
unsafe extern "C" {
    pub fn SDL_GPUTextureFormatTexelBlockSize(format: SDL_GPUTextureFormat) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_GPUTextureSupportsFormat(
        device: *mut SDL_GPUDevice,
        format: SDL_GPUTextureFormat,
        type_: SDL_GPUTextureType,
        usage: SDL_GPUTextureUsageFlags,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GPUTextureSupportsSampleCount(
        device: *mut SDL_GPUDevice,
        format: SDL_GPUTextureFormat,
        sample_count: SDL_GPUSampleCount,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CalculateGPUTextureFormatSize(
        format: SDL_GPUTextureFormat,
        width: Uint32,
        height: Uint32,
        depth_or_layer_count: Uint32,
    ) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_GetHaptics(count: *mut libc::c_int) -> *mut SDL_HapticID;
}
unsafe extern "C" {
    pub fn SDL_GetHapticNameForID(instance_id: SDL_HapticID) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_OpenHaptic(instance_id: SDL_HapticID) -> *mut SDL_Haptic;
}
unsafe extern "C" {
    pub fn SDL_GetHapticFromID(instance_id: SDL_HapticID) -> *mut SDL_Haptic;
}
unsafe extern "C" {
    pub fn SDL_GetHapticID(haptic: *mut SDL_Haptic) -> SDL_HapticID;
}
unsafe extern "C" {
    pub fn SDL_GetHapticName(haptic: *mut SDL_Haptic) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_IsMouseHaptic() -> bool;
}
unsafe extern "C" {
    pub fn SDL_OpenHapticFromMouse() -> *mut SDL_Haptic;
}
unsafe extern "C" {
    pub fn SDL_IsJoystickHaptic(joystick: *mut SDL_Joystick) -> bool;
}
unsafe extern "C" {
    pub fn SDL_OpenHapticFromJoystick(joystick: *mut SDL_Joystick) -> *mut SDL_Haptic;
}
unsafe extern "C" {
    pub fn SDL_CloseHaptic(haptic: *mut SDL_Haptic);
}
unsafe extern "C" {
    pub fn SDL_GetMaxHapticEffects(haptic: *mut SDL_Haptic) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetMaxHapticEffectsPlaying(haptic: *mut SDL_Haptic) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetHapticFeatures(haptic: *mut SDL_Haptic) -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_GetNumHapticAxes(haptic: *mut SDL_Haptic) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_HapticEffectSupported(
        haptic: *mut SDL_Haptic,
        effect: *const SDL_HapticEffect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CreateHapticEffect(
        haptic: *mut SDL_Haptic,
        effect: *const SDL_HapticEffect,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_UpdateHapticEffect(
        haptic: *mut SDL_Haptic,
        effect: libc::c_int,
        data: *const SDL_HapticEffect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RunHapticEffect(
        haptic: *mut SDL_Haptic,
        effect: libc::c_int,
        iterations: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_StopHapticEffect(haptic: *mut SDL_Haptic, effect: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_DestroyHapticEffect(haptic: *mut SDL_Haptic, effect: libc::c_int);
}
unsafe extern "C" {
    pub fn SDL_GetHapticEffectStatus(haptic: *mut SDL_Haptic, effect: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetHapticGain(haptic: *mut SDL_Haptic, gain: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetHapticAutocenter(haptic: *mut SDL_Haptic, autocenter: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_PauseHaptic(haptic: *mut SDL_Haptic) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ResumeHaptic(haptic: *mut SDL_Haptic) -> bool;
}
unsafe extern "C" {
    pub fn SDL_StopHapticEffects(haptic: *mut SDL_Haptic) -> bool;
}
unsafe extern "C" {
    pub fn SDL_HapticRumbleSupported(haptic: *mut SDL_Haptic) -> bool;
}
unsafe extern "C" {
    pub fn SDL_InitHapticRumble(haptic: *mut SDL_Haptic) -> bool;
}
unsafe extern "C" {
    pub fn SDL_PlayHapticRumble(haptic: *mut SDL_Haptic, strength: f32, length: Uint32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_StopHapticRumble(haptic: *mut SDL_Haptic) -> bool;
}
unsafe extern "C" {
    pub fn SDL_hid_init() -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_exit() -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_device_change_count() -> Uint32;
}
unsafe extern "C" {
    pub fn SDL_hid_enumerate(
        vendor_id: libc::c_ushort,
        product_id: libc::c_ushort,
    ) -> *mut SDL_hid_device_info;
}
unsafe extern "C" {
    pub fn SDL_hid_free_enumeration(devs: *mut SDL_hid_device_info);
}
unsafe extern "C" {
    pub fn SDL_hid_open(
        vendor_id: libc::c_ushort,
        product_id: libc::c_ushort,
        serial_number: *const wchar_t,
    ) -> *mut SDL_hid_device;
}
unsafe extern "C" {
    pub fn SDL_hid_open_path(path: *const libc::c_char) -> *mut SDL_hid_device;
}
unsafe extern "C" {
    pub fn SDL_hid_write(
        dev: *mut SDL_hid_device,
        data: *const libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_read_timeout(
        dev: *mut SDL_hid_device,
        data: *mut libc::c_uchar,
        length: usize,
        milliseconds: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_read(
        dev: *mut SDL_hid_device,
        data: *mut libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_set_nonblocking(dev: *mut SDL_hid_device, nonblock: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_send_feature_report(
        dev: *mut SDL_hid_device,
        data: *const libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_get_feature_report(
        dev: *mut SDL_hid_device,
        data: *mut libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_get_input_report(
        dev: *mut SDL_hid_device,
        data: *mut libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_close(dev: *mut SDL_hid_device) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_get_manufacturer_string(
        dev: *mut SDL_hid_device,
        string: *mut wchar_t,
        maxlen: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_get_product_string(
        dev: *mut SDL_hid_device,
        string: *mut wchar_t,
        maxlen: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_get_serial_number_string(
        dev: *mut SDL_hid_device,
        string: *mut wchar_t,
        maxlen: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_get_indexed_string(
        dev: *mut SDL_hid_device,
        string_index: libc::c_int,
        string: *mut wchar_t,
        maxlen: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_get_device_info(dev: *mut SDL_hid_device) -> *mut SDL_hid_device_info;
}
unsafe extern "C" {
    pub fn SDL_hid_get_report_descriptor(
        dev: *mut SDL_hid_device,
        buf: *mut libc::c_uchar,
        buf_size: usize,
    ) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_hid_ble_scan(active: bool);
}
unsafe extern "C" {
    pub fn SDL_SetHintWithPriority(
        name: *const libc::c_char,
        value: *const libc::c_char,
        priority: SDL_HintPriority,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetHint(name: *const libc::c_char, value: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ResetHint(name: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ResetHints();
}
unsafe extern "C" {
    pub fn SDL_GetHint(name: *const libc::c_char) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetHintBoolean(name: *const libc::c_char, default_value: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_AddHintCallback(
        name: *const libc::c_char,
        callback: SDL_HintCallback,
        userdata: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RemoveHintCallback(
        name: *const libc::c_char,
        callback: SDL_HintCallback,
        userdata: *mut libc::c_void,
    );
}
unsafe extern "C" {
    pub fn SDL_Init(flags: SDL_InitFlags) -> bool;
}
unsafe extern "C" {
    pub fn SDL_InitSubSystem(flags: SDL_InitFlags) -> bool;
}
unsafe extern "C" {
    pub fn SDL_QuitSubSystem(flags: SDL_InitFlags);
}
unsafe extern "C" {
    pub fn SDL_WasInit(flags: SDL_InitFlags) -> SDL_InitFlags;
}
unsafe extern "C" {
    pub fn SDL_Quit();
}
unsafe extern "C" {
    pub fn SDL_IsMainThread() -> bool;
}
unsafe extern "C" {
    pub fn SDL_RunOnMainThread(
        callback: SDL_MainThreadCallback,
        userdata: *mut libc::c_void,
        wait_complete: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetAppMetadata(
        appname: *const libc::c_char,
        appversion: *const libc::c_char,
        appidentifier: *const libc::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetAppMetadataProperty(
        name: *const libc::c_char,
        value: *const libc::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetAppMetadataProperty(name: *const libc::c_char) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_LoadObject(sofile: *const libc::c_char) -> *mut SDL_SharedObject;
}
unsafe extern "C" {
    pub fn SDL_LoadFunction(
        handle: *mut SDL_SharedObject,
        name: *const libc::c_char,
    ) -> SDL_FunctionPointer;
}
unsafe extern "C" {
    pub fn SDL_UnloadObject(handle: *mut SDL_SharedObject);
}
unsafe extern "C" {
    pub fn SDL_GetPreferredLocales(count: *mut libc::c_int) -> *mut *mut SDL_Locale;
}
unsafe extern "C" {
    pub fn SDL_SetLogPriorities(priority: SDL_LogPriority);
}
unsafe extern "C" {
    pub fn SDL_SetLogPriority(category: libc::c_int, priority: SDL_LogPriority);
}
unsafe extern "C" {
    pub fn SDL_GetLogPriority(category: libc::c_int) -> SDL_LogPriority;
}
unsafe extern "C" {
    pub fn SDL_ResetLogPriorities();
}
unsafe extern "C" {
    pub fn SDL_SetLogPriorityPrefix(priority: SDL_LogPriority, prefix: *const libc::c_char)
        -> bool;
}
unsafe extern "C" {
    pub fn SDL_Log(fmt: *const libc::c_char, ...);
}
unsafe extern "C" {
    pub fn SDL_LogTrace(category: libc::c_int, fmt: *const libc::c_char, ...);
}
unsafe extern "C" {
    pub fn SDL_LogVerbose(category: libc::c_int, fmt: *const libc::c_char, ...);
}
unsafe extern "C" {
    pub fn SDL_LogDebug(category: libc::c_int, fmt: *const libc::c_char, ...);
}
unsafe extern "C" {
    pub fn SDL_LogInfo(category: libc::c_int, fmt: *const libc::c_char, ...);
}
unsafe extern "C" {
    pub fn SDL_LogWarn(category: libc::c_int, fmt: *const libc::c_char, ...);
}
unsafe extern "C" {
    pub fn SDL_LogError(category: libc::c_int, fmt: *const libc::c_char, ...);
}
unsafe extern "C" {
    pub fn SDL_LogCritical(category: libc::c_int, fmt: *const libc::c_char, ...);
}
unsafe extern "C" {
    pub fn SDL_LogMessage(
        category: libc::c_int,
        priority: SDL_LogPriority,
        fmt: *const libc::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn SDL_LogMessageV(
        category: libc::c_int,
        priority: SDL_LogPriority,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn SDL_GetDefaultLogOutputFunction() -> SDL_LogOutputFunction;
}
unsafe extern "C" {
    pub fn SDL_GetLogOutputFunction(
        callback: *mut SDL_LogOutputFunction,
        userdata: *mut *mut libc::c_void,
    );
}
unsafe extern "C" {
    pub fn SDL_SetLogOutputFunction(callback: SDL_LogOutputFunction, userdata: *mut libc::c_void);
}
unsafe extern "C" {
    pub fn SDL_ShowMessageBox(
        messageboxdata: *const SDL_MessageBoxData,
        buttonid: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ShowSimpleMessageBox(
        flags: SDL_MessageBoxFlags,
        title: *const libc::c_char,
        message: *const libc::c_char,
        window: *mut SDL_Window,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_Metal_CreateView(window: *mut SDL_Window) -> SDL_MetalView;
}
unsafe extern "C" {
    pub fn SDL_Metal_DestroyView(view: SDL_MetalView);
}
unsafe extern "C" {
    pub fn SDL_Metal_GetLayer(view: SDL_MetalView) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_OpenURL(url: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetPlatform() -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_CreateProcess(
        args: *const *const libc::c_char,
        pipe_stdio: bool,
    ) -> *mut SDL_Process;
}
unsafe extern "C" {
    pub fn SDL_CreateProcessWithProperties(props: SDL_PropertiesID) -> *mut SDL_Process;
}
unsafe extern "C" {
    pub fn SDL_GetProcessProperties(process: *mut SDL_Process) -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_ReadProcess(
        process: *mut SDL_Process,
        datasize: *mut usize,
        exitcode: *mut libc::c_int,
    ) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_GetProcessInput(process: *mut SDL_Process) -> *mut SDL_IOStream;
}
unsafe extern "C" {
    pub fn SDL_GetProcessOutput(process: *mut SDL_Process) -> *mut SDL_IOStream;
}
unsafe extern "C" {
    pub fn SDL_KillProcess(process: *mut SDL_Process, force: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WaitProcess(
        process: *mut SDL_Process,
        block: bool,
        exitcode: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_DestroyProcess(process: *mut SDL_Process);
}
unsafe extern "C" {
    pub fn SDL_GetNumRenderDrivers() -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetRenderDriver(index: libc::c_int) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_CreateWindowAndRenderer(
        title: *const libc::c_char,
        width: libc::c_int,
        height: libc::c_int,
        window_flags: SDL_WindowFlags,
        window: *mut *mut SDL_Window,
        renderer: *mut *mut SDL_Renderer,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CreateRenderer(
        window: *mut SDL_Window,
        name: *const libc::c_char,
    ) -> *mut SDL_Renderer;
}
unsafe extern "C" {
    pub fn SDL_CreateRendererWithProperties(props: SDL_PropertiesID) -> *mut SDL_Renderer;
}
unsafe extern "C" {
    pub fn SDL_CreateSoftwareRenderer(surface: *mut SDL_Surface) -> *mut SDL_Renderer;
}
unsafe extern "C" {
    pub fn SDL_GetRenderer(window: *mut SDL_Window) -> *mut SDL_Renderer;
}
unsafe extern "C" {
    pub fn SDL_GetRenderWindow(renderer: *mut SDL_Renderer) -> *mut SDL_Window;
}
unsafe extern "C" {
    pub fn SDL_GetRendererName(renderer: *mut SDL_Renderer) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_GetRendererProperties(renderer: *mut SDL_Renderer) -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_GetRenderOutputSize(
        renderer: *mut SDL_Renderer,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetCurrentRenderOutputSize(
        renderer: *mut SDL_Renderer,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CreateTexture(
        renderer: *mut SDL_Renderer,
        format: SDL_PixelFormat,
        access: SDL_TextureAccess,
        w: libc::c_int,
        h: libc::c_int,
    ) -> *mut SDL_Texture;
}
unsafe extern "C" {
    pub fn SDL_CreateTextureFromSurface(
        renderer: *mut SDL_Renderer,
        surface: *mut SDL_Surface,
    ) -> *mut SDL_Texture;
}
unsafe extern "C" {
    pub fn SDL_CreateTextureWithProperties(
        renderer: *mut SDL_Renderer,
        props: SDL_PropertiesID,
    ) -> *mut SDL_Texture;
}
unsafe extern "C" {
    pub fn SDL_GetTextureProperties(texture: *mut SDL_Texture) -> SDL_PropertiesID;
}
unsafe extern "C" {
    pub fn SDL_GetRendererFromTexture(texture: *mut SDL_Texture) -> *mut SDL_Renderer;
}
unsafe extern "C" {
    pub fn SDL_GetTextureSize(texture: *mut SDL_Texture, w: *mut f32, h: *mut f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetTextureColorMod(texture: *mut SDL_Texture, r: Uint8, g: Uint8, b: Uint8) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetTextureColorModFloat(texture: *mut SDL_Texture, r: f32, g: f32, b: f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetTextureColorMod(
        texture: *mut SDL_Texture,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetTextureColorModFloat(
        texture: *mut SDL_Texture,
        r: *mut f32,
        g: *mut f32,
        b: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetTextureAlphaMod(texture: *mut SDL_Texture, alpha: Uint8) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetTextureAlphaModFloat(texture: *mut SDL_Texture, alpha: f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetTextureAlphaMod(texture: *mut SDL_Texture, alpha: *mut Uint8) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetTextureAlphaModFloat(texture: *mut SDL_Texture, alpha: *mut f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetTextureBlendMode(texture: *mut SDL_Texture, blendMode: SDL_BlendMode) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetTextureBlendMode(
        texture: *mut SDL_Texture,
        blendMode: *mut SDL_BlendMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetTextureScaleMode(texture: *mut SDL_Texture, scaleMode: SDL_ScaleMode) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetTextureScaleMode(
        texture: *mut SDL_Texture,
        scaleMode: *mut SDL_ScaleMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UpdateTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        pixels: *const libc::c_void,
        pitch: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UpdateYUVTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        Yplane: *const Uint8,
        Ypitch: libc::c_int,
        Uplane: *const Uint8,
        Upitch: libc::c_int,
        Vplane: *const Uint8,
        Vpitch: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UpdateNVTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        Yplane: *const Uint8,
        Ypitch: libc::c_int,
        UVplane: *const Uint8,
        UVpitch: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_LockTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        pixels: *mut *mut libc::c_void,
        pitch: *mut libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_LockTextureToSurface(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        surface: *mut *mut SDL_Surface,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_UnlockTexture(texture: *mut SDL_Texture);
}
unsafe extern "C" {
    pub fn SDL_SetRenderTarget(renderer: *mut SDL_Renderer, texture: *mut SDL_Texture) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderTarget(renderer: *mut SDL_Renderer) -> *mut SDL_Texture;
}
unsafe extern "C" {
    pub fn SDL_SetRenderLogicalPresentation(
        renderer: *mut SDL_Renderer,
        w: libc::c_int,
        h: libc::c_int,
        mode: SDL_RendererLogicalPresentation,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderLogicalPresentation(
        renderer: *mut SDL_Renderer,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
        mode: *mut SDL_RendererLogicalPresentation,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderLogicalPresentationRect(
        renderer: *mut SDL_Renderer,
        rect: *mut SDL_FRect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderCoordinatesFromWindow(
        renderer: *mut SDL_Renderer,
        window_x: f32,
        window_y: f32,
        x: *mut f32,
        y: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderCoordinatesToWindow(
        renderer: *mut SDL_Renderer,
        x: f32,
        y: f32,
        window_x: *mut f32,
        window_y: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ConvertEventToRenderCoordinates(
        renderer: *mut SDL_Renderer,
        event: *mut SDL_Event,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetRenderViewport(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderViewport(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderViewportSet(renderer: *mut SDL_Renderer) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderSafeArea(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetRenderClipRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderClipRect(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderClipEnabled(renderer: *mut SDL_Renderer) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetRenderScale(renderer: *mut SDL_Renderer, scaleX: f32, scaleY: f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderScale(
        renderer: *mut SDL_Renderer,
        scaleX: *mut f32,
        scaleY: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetRenderDrawColor(
        renderer: *mut SDL_Renderer,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetRenderDrawColorFloat(
        renderer: *mut SDL_Renderer,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderDrawColor(
        renderer: *mut SDL_Renderer,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderDrawColorFloat(
        renderer: *mut SDL_Renderer,
        r: *mut f32,
        g: *mut f32,
        b: *mut f32,
        a: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetRenderColorScale(renderer: *mut SDL_Renderer, scale: f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderColorScale(renderer: *mut SDL_Renderer, scale: *mut f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetRenderDrawBlendMode(
        renderer: *mut SDL_Renderer,
        blendMode: SDL_BlendMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderDrawBlendMode(
        renderer: *mut SDL_Renderer,
        blendMode: *mut SDL_BlendMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderClear(renderer: *mut SDL_Renderer) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderPoint(renderer: *mut SDL_Renderer, x: f32, y: f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderPoints(
        renderer: *mut SDL_Renderer,
        points: *const SDL_FPoint,
        count: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderLine(renderer: *mut SDL_Renderer, x1: f32, y1: f32, x2: f32, y2: f32) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderLines(
        renderer: *mut SDL_Renderer,
        points: *const SDL_FPoint,
        count: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderRect(renderer: *mut SDL_Renderer, rect: *const SDL_FRect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderRects(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_FRect,
        count: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderFillRect(renderer: *mut SDL_Renderer, rect: *const SDL_FRect) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderFillRects(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_FRect,
        count: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderTexture(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_FRect,
        dstrect: *const SDL_FRect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderTextureRotated(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_FRect,
        dstrect: *const SDL_FRect,
        angle: f64,
        center: *const SDL_FPoint,
        flip: SDL_FlipMode,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderTextureAffine(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_FRect,
        origin: *const SDL_FPoint,
        right: *const SDL_FPoint,
        down: *const SDL_FPoint,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderTextureTiled(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_FRect,
        scale: f32,
        dstrect: *const SDL_FRect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderTexture9Grid(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_FRect,
        left_width: f32,
        right_width: f32,
        top_height: f32,
        bottom_height: f32,
        scale: f32,
        dstrect: *const SDL_FRect,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderGeometry(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        vertices: *const SDL_Vertex,
        num_vertices: libc::c_int,
        indices: *const libc::c_int,
        num_indices: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderGeometryRaw(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        xy: *const f32,
        xy_stride: libc::c_int,
        color: *const SDL_FColor,
        color_stride: libc::c_int,
        uv: *const f32,
        uv_stride: libc::c_int,
        num_vertices: libc::c_int,
        indices: *const libc::c_void,
        num_indices: libc::c_int,
        size_indices: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderReadPixels(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    pub fn SDL_RenderPresent(renderer: *mut SDL_Renderer) -> bool;
}
unsafe extern "C" {
    pub fn SDL_DestroyTexture(texture: *mut SDL_Texture);
}
unsafe extern "C" {
    pub fn SDL_DestroyRenderer(renderer: *mut SDL_Renderer);
}
unsafe extern "C" {
    pub fn SDL_FlushRenderer(renderer: *mut SDL_Renderer) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderMetalLayer(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_GetRenderMetalCommandEncoder(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
unsafe extern "C" {
    pub fn SDL_AddVulkanRenderSemaphores(
        renderer: *mut SDL_Renderer,
        wait_stage_mask: Uint32,
        wait_semaphore: Sint64,
        signal_semaphore: Sint64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetRenderVSync(renderer: *mut SDL_Renderer, vsync: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetRenderVSync(renderer: *mut SDL_Renderer, vsync: *mut libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderDebugText(
        renderer: *mut SDL_Renderer,
        x: f32,
        y: f32,
        str_: *const libc::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenderDebugTextFormat(
        renderer: *mut SDL_Renderer,
        x: f32,
        y: f32,
        fmt: *const libc::c_char,
        ...
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_OpenTitleStorage(
        override_: *const libc::c_char,
        props: SDL_PropertiesID,
    ) -> *mut SDL_Storage;
}
unsafe extern "C" {
    pub fn SDL_OpenUserStorage(
        org: *const libc::c_char,
        app: *const libc::c_char,
        props: SDL_PropertiesID,
    ) -> *mut SDL_Storage;
}
unsafe extern "C" {
    pub fn SDL_OpenFileStorage(path: *const libc::c_char) -> *mut SDL_Storage;
}
unsafe extern "C" {
    pub fn SDL_OpenStorage(
        iface: *const SDL_StorageInterface,
        userdata: *mut libc::c_void,
    ) -> *mut SDL_Storage;
}
unsafe extern "C" {
    pub fn SDL_CloseStorage(storage: *mut SDL_Storage) -> bool;
}
unsafe extern "C" {
    pub fn SDL_StorageReady(storage: *mut SDL_Storage) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetStorageFileSize(
        storage: *mut SDL_Storage,
        path: *const libc::c_char,
        length: *mut Uint64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_ReadStorageFile(
        storage: *mut SDL_Storage,
        path: *const libc::c_char,
        destination: *mut libc::c_void,
        length: Uint64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_WriteStorageFile(
        storage: *mut SDL_Storage,
        path: *const libc::c_char,
        source: *const libc::c_void,
        length: Uint64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CreateStorageDirectory(storage: *mut SDL_Storage, path: *const libc::c_char)
        -> bool;
}
unsafe extern "C" {
    pub fn SDL_EnumerateStorageDirectory(
        storage: *mut SDL_Storage,
        path: *const libc::c_char,
        callback: SDL_EnumerateDirectoryCallback,
        userdata: *mut libc::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RemoveStoragePath(storage: *mut SDL_Storage, path: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    pub fn SDL_RenameStoragePath(
        storage: *mut SDL_Storage,
        oldpath: *const libc::c_char,
        newpath: *const libc::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CopyStorageFile(
        storage: *mut SDL_Storage,
        oldpath: *const libc::c_char,
        newpath: *const libc::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetStoragePathInfo(
        storage: *mut SDL_Storage,
        path: *const libc::c_char,
        info: *mut SDL_PathInfo,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetStorageSpaceRemaining(storage: *mut SDL_Storage) -> Uint64;
}
unsafe extern "C" {
    pub fn SDL_GlobStorageDirectory(
        storage: *mut SDL_Storage,
        path: *const libc::c_char,
        pattern: *const libc::c_char,
        flags: SDL_GlobFlags,
        count: *mut libc::c_int,
    ) -> *mut *mut libc::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XEvent {
    _unused: [u8; 0],
}
pub type XEvent = _XEvent;
unsafe extern "C" {
    pub fn SDL_SetX11EventHook(callback: SDL_X11EventHook, userdata: *mut libc::c_void);
}
unsafe extern "C" {
    pub fn SDL_SetLinuxThreadPriority(threadID: Sint64, priority: libc::c_int) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetLinuxThreadPriorityAndPolicy(
        threadID: Sint64,
        sdlPriority: libc::c_int,
        schedPolicy: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_IsTablet() -> bool;
}
unsafe extern "C" {
    pub fn SDL_IsTV() -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetSandbox() -> SDL_Sandbox;
}
unsafe extern "C" {
    pub fn SDL_OnApplicationWillTerminate();
}
unsafe extern "C" {
    pub fn SDL_OnApplicationDidReceiveMemoryWarning();
}
unsafe extern "C" {
    pub fn SDL_OnApplicationWillEnterBackground();
}
unsafe extern "C" {
    pub fn SDL_OnApplicationDidEnterBackground();
}
unsafe extern "C" {
    pub fn SDL_OnApplicationWillEnterForeground();
}
unsafe extern "C" {
    pub fn SDL_OnApplicationDidEnterForeground();
}
unsafe extern "C" {
    pub fn SDL_GetDateTimeLocalePreferences(
        dateFormat: *mut SDL_DateFormat,
        timeFormat: *mut SDL_TimeFormat,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SDL_GetCurrentTime(ticks: *mut SDL_Time) -> bool;
}
unsafe extern "C" {
    pub fn SDL_TimeToDateTime(ticks: SDL_Time, dt: *mut SDL_DateTime, localTime: bool) -> bool;
}
unsafe extern "C" {
    pub fn SDL_DateTimeToTime(dt: *const SDL_DateTime, ticks: *mut SDL_Time) -> bool;
}
unsafe extern "C" {
    pub fn SDL_TimeToWindows(
        ticks: SDL_Time,
        dwLowDateTime: *mut Uint32,
        dwHighDateTime: *mut Uint32,
    );
}
unsafe extern "C" {
    pub fn SDL_TimeFromWindows(dwLowDateTime: Uint32, dwHighDateTime: Uint32) -> SDL_Time;
}
unsafe extern "C" {
    pub fn SDL_GetDaysInMonth(year: libc::c_int, month: libc::c_int) -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetDayOfYear(year: libc::c_int, month: libc::c_int, day: libc::c_int)
        -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetDayOfWeek(year: libc::c_int, month: libc::c_int, day: libc::c_int)
        -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetTicks() -> Uint64;
}
unsafe extern "C" {
    pub fn SDL_GetTicksNS() -> Uint64;
}
unsafe extern "C" {
    pub fn SDL_GetPerformanceCounter() -> Uint64;
}
unsafe extern "C" {
    pub fn SDL_GetPerformanceFrequency() -> Uint64;
}
unsafe extern "C" {
    pub fn SDL_Delay(ms: Uint32);
}
unsafe extern "C" {
    pub fn SDL_DelayNS(ns: Uint64);
}
unsafe extern "C" {
    pub fn SDL_DelayPrecise(ns: Uint64);
}
unsafe extern "C" {
    pub fn SDL_AddTimer(
        interval: Uint32,
        callback: SDL_TimerCallback,
        userdata: *mut libc::c_void,
    ) -> SDL_TimerID;
}
unsafe extern "C" {
    pub fn SDL_AddTimerNS(
        interval: Uint64,
        callback: SDL_NSTimerCallback,
        userdata: *mut libc::c_void,
    ) -> SDL_TimerID;
}
unsafe extern "C" {
    pub fn SDL_RemoveTimer(id: SDL_TimerID) -> bool;
}
unsafe extern "C" {
    pub fn SDL_CreateTray(icon: *mut SDL_Surface, tooltip: *const libc::c_char) -> *mut SDL_Tray;
}
unsafe extern "C" {
    pub fn SDL_SetTrayIcon(tray: *mut SDL_Tray, icon: *mut SDL_Surface);
}
unsafe extern "C" {
    pub fn SDL_SetTrayTooltip(tray: *mut SDL_Tray, tooltip: *const libc::c_char);
}
unsafe extern "C" {
    pub fn SDL_CreateTrayMenu(tray: *mut SDL_Tray) -> *mut SDL_TrayMenu;
}
unsafe extern "C" {
    pub fn SDL_CreateTraySubmenu(entry: *mut SDL_TrayEntry) -> *mut SDL_TrayMenu;
}
unsafe extern "C" {
    pub fn SDL_GetTrayMenu(tray: *mut SDL_Tray) -> *mut SDL_TrayMenu;
}
unsafe extern "C" {
    pub fn SDL_GetTraySubmenu(entry: *mut SDL_TrayEntry) -> *mut SDL_TrayMenu;
}
unsafe extern "C" {
    pub fn SDL_GetTrayEntries(
        menu: *mut SDL_TrayMenu,
        count: *mut libc::c_int,
    ) -> *mut *const SDL_TrayEntry;
}
unsafe extern "C" {
    pub fn SDL_RemoveTrayEntry(entry: *mut SDL_TrayEntry);
}
unsafe extern "C" {
    pub fn SDL_InsertTrayEntryAt(
        menu: *mut SDL_TrayMenu,
        pos: libc::c_int,
        label: *const libc::c_char,
        flags: SDL_TrayEntryFlags,
    ) -> *mut SDL_TrayEntry;
}
unsafe extern "C" {
    pub fn SDL_SetTrayEntryLabel(entry: *mut SDL_TrayEntry, label: *const libc::c_char);
}
unsafe extern "C" {
    pub fn SDL_GetTrayEntryLabel(entry: *mut SDL_TrayEntry) -> *const libc::c_char;
}
unsafe extern "C" {
    pub fn SDL_SetTrayEntryChecked(entry: *mut SDL_TrayEntry, checked: bool);
}
unsafe extern "C" {
    pub fn SDL_GetTrayEntryChecked(entry: *mut SDL_TrayEntry) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetTrayEntryEnabled(entry: *mut SDL_TrayEntry, enabled: bool);
}
unsafe extern "C" {
    pub fn SDL_GetTrayEntryEnabled(entry: *mut SDL_TrayEntry) -> bool;
}
unsafe extern "C" {
    pub fn SDL_SetTrayEntryCallback(
        entry: *mut SDL_TrayEntry,
        callback: SDL_TrayCallback,
        userdata: *mut libc::c_void,
    );
}
unsafe extern "C" {
    pub fn SDL_ClickTrayEntry(entry: *mut SDL_TrayEntry);
}
unsafe extern "C" {
    pub fn SDL_DestroyTray(tray: *mut SDL_Tray);
}
unsafe extern "C" {
    pub fn SDL_GetTrayEntryParent(entry: *mut SDL_TrayEntry) -> *mut SDL_TrayMenu;
}
unsafe extern "C" {
    pub fn SDL_GetTrayMenuParentEntry(menu: *mut SDL_TrayMenu) -> *mut SDL_TrayEntry;
}
unsafe extern "C" {
    pub fn SDL_GetTrayMenuParentTray(menu: *mut SDL_TrayMenu) -> *mut SDL_Tray;
}
unsafe extern "C" {
    pub fn SDL_UpdateTrays();
}
unsafe extern "C" {
    pub fn SDL_GetVersion() -> libc::c_int;
}
unsafe extern "C" {
    pub fn SDL_GetRevision() -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " This function gets the version of the dynamically linked SDL_image library.\n\n \\returns SDL_image version.\n\n \\since This function is available since SDL_image 3.0.0."]
    pub fn IMG_Version() -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Load an image from an SDL data source into a software surface.\n\n An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use\n this if you plan to hand the data to something else or manipulate it\n further in code.\n\n There are no guarantees about what format the new SDL_Surface data will be;\n in many cases, SDL_image will attempt to supply a surface that exactly\n matches the provided image, but in others it might have to convert (either\n because the image is in a format that SDL doesn't directly support or\n because it's compressed data that could reasonably uncompress to various\n formats and SDL_image had to pick one). You can inspect an SDL_Surface for\n its specifics, and use SDL_ConvertSurface to then migrate to any supported\n format.\n\n If the image format supports a transparent pixel, SDL will set the colorkey\n for the surface. You can enable RLE acceleration on the surface afterwards\n by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,\n image->format->colorkey);\n\n If `closeio` is true, `src` will be closed before returning, whether this\n function succeeds or not. SDL_image reads everything it needs from `src`\n during this call in any case.\n\n Even though this function accepts a file type, SDL_image may still try\n other decoders that are capable of detecting file type from the contents of\n the image data, but may rely on the caller-provided type string for formats\n that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on\n its ability to guess the format.\n\n There is a separate function to read files from disk without having to deal\n with SDL_IOStream: `IMG_Load(\"filename.jpg\")` will call this function and\n manage those details for you, determining the file type from the filename's\n extension.\n\n There is also IMG_Load_IO(), which is equivalent to this function except\n that it will rely on SDL_image to determine what type of data it is\n loading, much like passing a NULL for type.\n\n If you are using SDL's 2D rendering API, there is an equivalent call to\n load images directly into an SDL_Texture for use by the GPU without using a\n software surface: call IMG_LoadTextureTyped_IO() instead.\n\n When done with the returned surface, the app should dispose of it with a\n call to SDL_DestroySurface().\n\n \\param src an SDL_IOStream that data will be read from.\n \\param closeio true to close/free the SDL_IOStream before returning, false\n                to leave it open.\n \\param type a filename extension that represent this data (\"BMP\", \"GIF\",\n             \"PNG\", etc).\n \\returns a new SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_Load\n \\sa IMG_Load_IO\n \\sa SDL_DestroySurface"]
    pub fn IMG_LoadTyped_IO(
        src: *mut SDL_IOStream,
        closeio: bool,
        type_: *const libc::c_char,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load an image from a filesystem path into a software surface.\n\n An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use\n this if you plan to hand the data to something else or manipulate it\n further in code.\n\n There are no guarantees about what format the new SDL_Surface data will be;\n in many cases, SDL_image will attempt to supply a surface that exactly\n matches the provided image, but in others it might have to convert (either\n because the image is in a format that SDL doesn't directly support or\n because it's compressed data that could reasonably uncompress to various\n formats and SDL_image had to pick one). You can inspect an SDL_Surface for\n its specifics, and use SDL_ConvertSurface to then migrate to any supported\n format.\n\n If the image format supports a transparent pixel, SDL will set the colorkey\n for the surface. You can enable RLE acceleration on the surface afterwards\n by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,\n image->format->colorkey);\n\n There is a separate function to read files from an SDL_IOStream, if you\n need an i/o abstraction to provide data from anywhere instead of a simple\n filesystem read; that function is IMG_Load_IO().\n\n If you are using SDL's 2D rendering API, there is an equivalent call to\n load images directly into an SDL_Texture for use by the GPU without using a\n software surface: call IMG_LoadTexture() instead.\n\n When done with the returned surface, the app should dispose of it with a\n call to\n [SDL_DestroySurface](https://wiki.libsdl.org/SDL3/SDL_DestroySurface)\n ().\n\n \\param file a path on the filesystem to load an image from.\n \\returns a new SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadTyped_IO\n \\sa IMG_Load_IO\n \\sa SDL_DestroySurface"]
    pub fn IMG_Load(file: *const libc::c_char) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load an image from an SDL data source into a software surface.\n\n An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use\n this if you plan to hand the data to something else or manipulate it\n further in code.\n\n There are no guarantees about what format the new SDL_Surface data will be;\n in many cases, SDL_image will attempt to supply a surface that exactly\n matches the provided image, but in others it might have to convert (either\n because the image is in a format that SDL doesn't directly support or\n because it's compressed data that could reasonably uncompress to various\n formats and SDL_image had to pick one). You can inspect an SDL_Surface for\n its specifics, and use SDL_ConvertSurface to then migrate to any supported\n format.\n\n If the image format supports a transparent pixel, SDL will set the colorkey\n for the surface. You can enable RLE acceleration on the surface afterwards\n by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,\n image->format->colorkey);\n\n If `closeio` is true, `src` will be closed before returning, whether this\n function succeeds or not. SDL_image reads everything it needs from `src`\n during this call in any case.\n\n There is a separate function to read files from disk without having to deal\n with SDL_IOStream: `IMG_Load(\"filename.jpg\")` will call this function and\n manage those details for you, determining the file type from the filename's\n extension.\n\n There is also IMG_LoadTyped_IO(), which is equivalent to this function\n except a file extension (like \"BMP\", \"JPG\", etc) can be specified, in case\n SDL_image cannot autodetect the file format.\n\n If you are using SDL's 2D rendering API, there is an equivalent call to\n load images directly into an SDL_Texture for use by the GPU without using a\n software surface: call IMG_LoadTexture_IO() instead.\n\n When done with the returned surface, the app should dispose of it with a\n call to SDL_DestroySurface().\n\n \\param src an SDL_IOStream that data will be read from.\n \\param closeio true to close/free the SDL_IOStream before returning, false\n                to leave it open.\n \\returns a new SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_Load\n \\sa IMG_LoadTyped_IO\n \\sa SDL_DestroySurface"]
    pub fn IMG_Load_IO(src: *mut SDL_IOStream, closeio: bool) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load an image from a filesystem path into a GPU texture.\n\n An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render\n API. This can be significantly more efficient than using a CPU-bound\n SDL_Surface if you don't need to manipulate the image directly after\n loading it.\n\n If the loaded image has transparency or a colorkey, a texture with an alpha\n channel will be created. Otherwise, SDL_image will attempt to create an\n SDL_Texture in the most format that most reasonably represents the image\n data (but in many cases, this will just end up being 32-bit RGB or 32-bit\n RGBA).\n\n There is a separate function to read files from an SDL_IOStream, if you\n need an i/o abstraction to provide data from anywhere instead of a simple\n filesystem read; that function is IMG_LoadTexture_IO().\n\n If you would rather decode an image to an SDL_Surface (a buffer of pixels\n in CPU memory), call IMG_Load() instead.\n\n When done with the returned texture, the app should dispose of it with a\n call to SDL_DestroyTexture().\n\n \\param renderer the SDL_Renderer to use to create the GPU texture.\n \\param file a path on the filesystem to load an image from.\n \\returns a new texture, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadTextureTyped_IO\n \\sa IMG_LoadTexture_IO"]
    pub fn IMG_LoadTexture(
        renderer: *mut SDL_Renderer,
        file: *const libc::c_char,
    ) -> *mut SDL_Texture;
}
unsafe extern "C" {
    #[doc = " Load an image from an SDL data source into a GPU texture.\n\n An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render\n API. This can be significantly more efficient than using a CPU-bound\n SDL_Surface if you don't need to manipulate the image directly after\n loading it.\n\n If the loaded image has transparency or a colorkey, a texture with an alpha\n channel will be created. Otherwise, SDL_image will attempt to create an\n SDL_Texture in the most format that most reasonably represents the image\n data (but in many cases, this will just end up being 32-bit RGB or 32-bit\n RGBA).\n\n If `closeio` is true, `src` will be closed before returning, whether this\n function succeeds or not. SDL_image reads everything it needs from `src`\n during this call in any case.\n\n There is a separate function to read files from disk without having to deal\n with SDL_IOStream: `IMG_LoadTexture(renderer, \"filename.jpg\")` will call\n this function and manage those details for you, determining the file type\n from the filename's extension.\n\n There is also IMG_LoadTextureTyped_IO(), which is equivalent to this\n function except a file extension (like \"BMP\", \"JPG\", etc) can be specified,\n in case SDL_image cannot autodetect the file format.\n\n If you would rather decode an image to an SDL_Surface (a buffer of pixels\n in CPU memory), call IMG_Load() instead.\n\n When done with the returned texture, the app should dispose of it with a\n call to SDL_DestroyTexture().\n\n \\param renderer the SDL_Renderer to use to create the GPU texture.\n \\param src an SDL_IOStream that data will be read from.\n \\param closeio true to close/free the SDL_IOStream before returning, false\n                to leave it open.\n \\returns a new texture, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadTexture\n \\sa IMG_LoadTextureTyped_IO\n \\sa SDL_DestroyTexture"]
    pub fn IMG_LoadTexture_IO(
        renderer: *mut SDL_Renderer,
        src: *mut SDL_IOStream,
        closeio: bool,
    ) -> *mut SDL_Texture;
}
unsafe extern "C" {
    #[doc = " Load an image from an SDL data source into a GPU texture.\n\n An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render\n API. This can be significantly more efficient than using a CPU-bound\n SDL_Surface if you don't need to manipulate the image directly after\n loading it.\n\n If the loaded image has transparency or a colorkey, a texture with an alpha\n channel will be created. Otherwise, SDL_image will attempt to create an\n SDL_Texture in the most format that most reasonably represents the image\n data (but in many cases, this will just end up being 32-bit RGB or 32-bit\n RGBA).\n\n If `closeio` is true, `src` will be closed before returning, whether this\n function succeeds or not. SDL_image reads everything it needs from `src`\n during this call in any case.\n\n Even though this function accepts a file type, SDL_image may still try\n other decoders that are capable of detecting file type from the contents of\n the image data, but may rely on the caller-provided type string for formats\n that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on\n its ability to guess the format.\n\n There is a separate function to read files from disk without having to deal\n with SDL_IOStream: `IMG_LoadTexture(\"filename.jpg\")` will call this\n function and manage those details for you, determining the file type from\n the filename's extension.\n\n There is also IMG_LoadTexture_IO(), which is equivalent to this function\n except that it will rely on SDL_image to determine what type of data it is\n loading, much like passing a NULL for type.\n\n If you would rather decode an image to an SDL_Surface (a buffer of pixels\n in CPU memory), call IMG_LoadTyped_IO() instead.\n\n When done with the returned texture, the app should dispose of it with a\n call to SDL_DestroyTexture().\n\n \\param renderer the SDL_Renderer to use to create the GPU texture.\n \\param src an SDL_IOStream that data will be read from.\n \\param closeio true to close/free the SDL_IOStream before returning, false\n                to leave it open.\n \\param type a filename extension that represent this data (\"BMP\", \"GIF\",\n             \"PNG\", etc).\n \\returns a new texture, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadTexture\n \\sa IMG_LoadTexture_IO\n \\sa SDL_DestroyTexture"]
    pub fn IMG_LoadTextureTyped_IO(
        renderer: *mut SDL_Renderer,
        src: *mut SDL_IOStream,
        closeio: bool,
        type_: *const libc::c_char,
    ) -> *mut SDL_Texture;
}
unsafe extern "C" {
    #[doc = " Detect AVIF image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is AVIF data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isAVIF(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect ICO image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is ICO data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isICO(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect CUR image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is CUR data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isCUR(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect BMP image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is BMP data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isBMP(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect GIF image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is GIF data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isGIF(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect JPG image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is JPG data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isJPG(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect JXL image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is JXL data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isJXL(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect LBM image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is LBM data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isLBM(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect PCX image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is PCX data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isPCX(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect PNG image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is PNG data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isPNG(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect PNM image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is PNM data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isPNM(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect SVG image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is SVG data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isSVG(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect QOI image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is QOI data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isQOI(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect TIFF image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is TIFF data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isTIF(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect XCF image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is XCF data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXPM\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isXCF(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect XPM image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is XPM data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXV\n \\sa IMG_isWEBP"]
    pub fn IMG_isXPM(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect XV image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is XV data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isWEBP"]
    pub fn IMG_isXV(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Detect WEBP image data on a readable/seekable SDL_IOStream.\n\n This function attempts to determine if a file is a given filetype, reading\n the least amount possible from the SDL_IOStream (usually a few bytes).\n\n There is no distinction made between \"not the filetype in question\" and\n basic i/o errors.\n\n This function will always attempt to seek `src` back to where it started\n when this function was called, but it will not report any errors in doing\n so, but assuming seeking works, this means you can immediately use this\n with a different IMG_isTYPE function, or load the image without further\n seeking.\n\n You do not need to call this function to load data; SDL_image can work to\n determine file type in many cases in its standard load functions.\n\n \\param src a seekable/readable SDL_IOStream to provide image data.\n \\returns non-zero if this is WEBP data, zero otherwise.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_isAVIF\n \\sa IMG_isICO\n \\sa IMG_isCUR\n \\sa IMG_isBMP\n \\sa IMG_isGIF\n \\sa IMG_isJPG\n \\sa IMG_isJXL\n \\sa IMG_isLBM\n \\sa IMG_isPCX\n \\sa IMG_isPNG\n \\sa IMG_isPNM\n \\sa IMG_isSVG\n \\sa IMG_isQOI\n \\sa IMG_isTIF\n \\sa IMG_isXCF\n \\sa IMG_isXPM\n \\sa IMG_isXV"]
    pub fn IMG_isWEBP(src: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Load a AVIF image directly.\n\n If you know you definitely have a AVIF image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadAVIF_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a ICO image directly.\n\n If you know you definitely have a ICO image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadICO_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a CUR image directly.\n\n If you know you definitely have a CUR image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadCUR_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a BMP image directly.\n\n If you know you definitely have a BMP image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadBMP_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a GIF image directly.\n\n If you know you definitely have a GIF image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadGIF_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a JPG image directly.\n\n If you know you definitely have a JPG image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadJPG_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a JXL image directly.\n\n If you know you definitely have a JXL image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadJXL_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a LBM image directly.\n\n If you know you definitely have a LBM image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadLBM_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a PCX image directly.\n\n If you know you definitely have a PCX image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadPCX_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a PNG image directly.\n\n If you know you definitely have a PNG image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadPNG_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a PNM image directly.\n\n If you know you definitely have a PNM image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadPNM_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a SVG image directly.\n\n If you know you definitely have a SVG image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadSVG_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a QOI image directly.\n\n If you know you definitely have a QOI image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadQOI_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a TGA image directly.\n\n If you know you definitely have a TGA image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadTGA_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a TIFF image directly.\n\n If you know you definitely have a TIFF image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadTIF_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a XCF image directly.\n\n If you know you definitely have a XCF image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadXCF_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a XPM image directly.\n\n If you know you definitely have a XPM image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXV_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadXPM_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a XV image directly.\n\n If you know you definitely have a XV image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadWEBP_IO"]
    pub fn IMG_LoadXV_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a WEBP image directly.\n\n If you know you definitely have a WEBP image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream to load image data from.\n \\returns SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAVIF_IO\n \\sa IMG_LoadICO_IO\n \\sa IMG_LoadCUR_IO\n \\sa IMG_LoadBMP_IO\n \\sa IMG_LoadGIF_IO\n \\sa IMG_LoadJPG_IO\n \\sa IMG_LoadJXL_IO\n \\sa IMG_LoadLBM_IO\n \\sa IMG_LoadPCX_IO\n \\sa IMG_LoadPNG_IO\n \\sa IMG_LoadPNM_IO\n \\sa IMG_LoadSVG_IO\n \\sa IMG_LoadQOI_IO\n \\sa IMG_LoadTGA_IO\n \\sa IMG_LoadTIF_IO\n \\sa IMG_LoadXCF_IO\n \\sa IMG_LoadXPM_IO\n \\sa IMG_LoadXV_IO"]
    pub fn IMG_LoadWEBP_IO(src: *mut SDL_IOStream) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load an SVG image, scaled to a specific size.\n\n Since SVG files are resolution-independent, you specify the size you would\n like the output image to be and it will be generated at those dimensions.\n\n Either width or height may be 0 and the image will be auto-sized to\n preserve aspect ratio.\n\n When done with the returned surface, the app should dispose of it with a\n call to SDL_DestroySurface().\n\n \\param src an SDL_IOStream to load SVG data from.\n \\param width desired width of the generated surface, in pixels.\n \\param height desired height of the generated surface, in pixels.\n \\returns a new SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0."]
    pub fn IMG_LoadSizedSVG_IO(
        src: *mut SDL_IOStream,
        width: libc::c_int,
        height: libc::c_int,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load an XPM image from a memory array.\n\n The returned surface will be an 8bpp indexed surface, if possible,\n otherwise it will be 32bpp. If you always want 32-bit data, use\n IMG_ReadXPMFromArrayToRGB888() instead.\n\n When done with the returned surface, the app should dispose of it with a\n call to SDL_DestroySurface().\n\n \\param xpm a null-terminated array of strings that comprise XPM data.\n \\returns a new SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_ReadXPMFromArrayToRGB888"]
    pub fn IMG_ReadXPMFromArray(xpm: *mut *mut libc::c_char) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load an XPM image from a memory array.\n\n The returned surface will always be a 32-bit RGB surface. If you want 8-bit\n indexed colors (and the XPM data allows it), use IMG_ReadXPMFromArray()\n instead.\n\n When done with the returned surface, the app should dispose of it with a\n call to SDL_DestroySurface().\n\n \\param xpm a null-terminated array of strings that comprise XPM data.\n \\returns a new SDL surface, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_ReadXPMFromArray"]
    pub fn IMG_ReadXPMFromArrayToRGB888(xpm: *mut *mut libc::c_char) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Save an SDL_Surface into a AVIF image file.\n\n If the file already exists, it will be overwritten.\n\n \\param surface the SDL surface to save.\n \\param file path on the filesystem to write new file to.\n \\param quality the desired quality, ranging between 0 (lowest) and 100\n                (highest).\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_SaveAVIF_IO"]
    pub fn IMG_SaveAVIF(
        surface: *mut SDL_Surface,
        file: *const libc::c_char,
        quality: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Save an SDL_Surface into AVIF image data, via an SDL_IOStream.\n\n If you just want to save to a filename, you can use IMG_SaveAVIF() instead.\n\n If `closeio` is true, `dst` will be closed before returning, whether this\n function succeeds or not.\n\n \\param surface the SDL surface to save.\n \\param dst the SDL_IOStream to save the image data to.\n \\param closeio true to close/free the SDL_IOStream before returning, false\n                to leave it open.\n \\param quality the desired quality, ranging between 0 (lowest) and 100\n                (highest).\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_SaveAVIF"]
    pub fn IMG_SaveAVIF_IO(
        surface: *mut SDL_Surface,
        dst: *mut SDL_IOStream,
        closeio: bool,
        quality: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Save an SDL_Surface into a PNG image file.\n\n If the file already exists, it will be overwritten.\n\n \\param surface the SDL surface to save.\n \\param file path on the filesystem to write new file to.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_SavePNG_IO"]
    pub fn IMG_SavePNG(surface: *mut SDL_Surface, file: *const libc::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Save an SDL_Surface into PNG image data, via an SDL_IOStream.\n\n If you just want to save to a filename, you can use IMG_SavePNG() instead.\n\n If `closeio` is true, `dst` will be closed before returning, whether this\n function succeeds or not.\n\n \\param surface the SDL surface to save.\n \\param dst the SDL_IOStream to save the image data to.\n \\param closeio true to close/free the SDL_IOStream before returning, false\n                to leave it open.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_SavePNG"]
    pub fn IMG_SavePNG_IO(surface: *mut SDL_Surface, dst: *mut SDL_IOStream, closeio: bool)
        -> bool;
}
unsafe extern "C" {
    #[doc = " Save an SDL_Surface into a JPEG image file.\n\n If the file already exists, it will be overwritten.\n\n \\param surface the SDL surface to save.\n \\param file path on the filesystem to write new file to.\n \\param quality [0; 33] is Lowest quality, [34; 66] is Middle quality, [67;\n                100] is Highest quality.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_SaveJPG_IO"]
    pub fn IMG_SaveJPG(
        surface: *mut SDL_Surface,
        file: *const libc::c_char,
        quality: libc::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Save an SDL_Surface into JPEG image data, via an SDL_IOStream.\n\n If you just want to save to a filename, you can use IMG_SaveJPG() instead.\n\n If `closeio` is true, `dst` will be closed before returning, whether this\n function succeeds or not.\n\n \\param surface the SDL surface to save.\n \\param dst the SDL_IOStream to save the image data to.\n \\param closeio true to close/free the SDL_IOStream before returning, false\n                to leave it open.\n \\param quality [0; 33] is Lowest quality, [34; 66] is Middle quality, [67;\n                100] is Highest quality.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_SaveJPG"]
    pub fn IMG_SaveJPG_IO(
        surface: *mut SDL_Surface,
        dst: *mut SDL_IOStream,
        closeio: bool,
        quality: libc::c_int,
    ) -> bool;
}
#[doc = " Animated image support\n\n Currently only animated GIFs and WEBP images are supported."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMG_Animation {
    pub w: libc::c_int,
    pub h: libc::c_int,
    pub count: libc::c_int,
    pub frames: *mut *mut SDL_Surface,
    pub delays: *mut libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMG_Animation"][::core::mem::size_of::<IMG_Animation>() - 32usize];
    ["Alignment of IMG_Animation"][::core::mem::align_of::<IMG_Animation>() - 8usize];
    ["Offset of field: IMG_Animation::w"][::core::mem::offset_of!(IMG_Animation, w) - 0usize];
    ["Offset of field: IMG_Animation::h"][::core::mem::offset_of!(IMG_Animation, h) - 4usize];
    ["Offset of field: IMG_Animation::count"]
        [::core::mem::offset_of!(IMG_Animation, count) - 8usize];
    ["Offset of field: IMG_Animation::frames"]
        [::core::mem::offset_of!(IMG_Animation, frames) - 16usize];
    ["Offset of field: IMG_Animation::delays"]
        [::core::mem::offset_of!(IMG_Animation, delays) - 24usize];
};
unsafe extern "C" {
    #[doc = " Load an animation from a file.\n\n When done with the returned animation, the app should dispose of it with a\n call to IMG_FreeAnimation().\n\n \\param file path on the filesystem containing an animated image.\n \\returns a new IMG_Animation, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_FreeAnimation"]
    pub fn IMG_LoadAnimation(file: *const libc::c_char) -> *mut IMG_Animation;
}
unsafe extern "C" {
    #[doc = " Load an animation from an SDL_IOStream.\n\n If `closeio` is true, `src` will be closed before returning, whether this\n function succeeds or not. SDL_image reads everything it needs from `src`\n during this call in any case.\n\n When done with the returned animation, the app should dispose of it with a\n call to IMG_FreeAnimation().\n\n \\param src an SDL_IOStream that data will be read from.\n \\param closeio true to close/free the SDL_IOStream before returning, false\n                to leave it open.\n \\returns a new IMG_Animation, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_FreeAnimation"]
    pub fn IMG_LoadAnimation_IO(src: *mut SDL_IOStream, closeio: bool) -> *mut IMG_Animation;
}
unsafe extern "C" {
    #[doc = " Load an animation from an SDL datasource\n\n Even though this function accepts a file type, SDL_image may still try\n other decoders that are capable of detecting file type from the contents of\n the image data, but may rely on the caller-provided type string for formats\n that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on\n its ability to guess the format.\n\n If `closeio` is true, `src` will be closed before returning, whether this\n function succeeds or not. SDL_image reads everything it needs from `src`\n during this call in any case.\n\n When done with the returned animation, the app should dispose of it with a\n call to IMG_FreeAnimation().\n\n \\param src an SDL_IOStream that data will be read from.\n \\param closeio true to close/free the SDL_IOStream before returning, false\n                to leave it open.\n \\param type a filename extension that represent this data (\"GIF\", etc).\n \\returns a new IMG_Animation, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAnimation\n \\sa IMG_LoadAnimation_IO\n \\sa IMG_FreeAnimation"]
    pub fn IMG_LoadAnimationTyped_IO(
        src: *mut SDL_IOStream,
        closeio: bool,
        type_: *const libc::c_char,
    ) -> *mut IMG_Animation;
}
unsafe extern "C" {
    #[doc = " Dispose of an IMG_Animation and free its resources.\n\n The provided `anim` pointer is not valid once this call returns.\n\n \\param anim IMG_Animation to dispose of.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAnimation\n \\sa IMG_LoadAnimation_IO\n \\sa IMG_LoadAnimationTyped_IO"]
    pub fn IMG_FreeAnimation(anim: *mut IMG_Animation);
}
unsafe extern "C" {
    #[doc = " Load a GIF animation directly.\n\n If you know you definitely have a GIF image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream that data will be read from.\n \\returns a new IMG_Animation, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAnimation\n \\sa IMG_LoadAnimation_IO\n \\sa IMG_LoadAnimationTyped_IO\n \\sa IMG_FreeAnimation"]
    pub fn IMG_LoadGIFAnimation_IO(src: *mut SDL_IOStream) -> *mut IMG_Animation;
}
unsafe extern "C" {
    #[doc = " Load a WEBP animation directly.\n\n If you know you definitely have a WEBP image, you can call this function,\n which will skip SDL_image's file format detection routines. Generally it's\n better to use the abstract interfaces; also, there is only an SDL_IOStream\n interface available here.\n\n \\param src an SDL_IOStream that data will be read from.\n \\returns a new IMG_Animation, or NULL on error.\n\n \\since This function is available since SDL_image 3.0.0.\n\n \\sa IMG_LoadAnimation\n \\sa IMG_LoadAnimation_IO\n \\sa IMG_LoadAnimationTyped_IO\n \\sa IMG_FreeAnimation"]
    pub fn IMG_LoadWEBPAnimation_IO(src: *mut SDL_IOStream) -> *mut IMG_Animation;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::core::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::core::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::core::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::core::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::core::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::core::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
