/* automatically generated by rust-bindgen 0.71.1 */

pub const SDL_PLATFORM_LINUX: u32 = 1;
pub const SDL_PLATFORM_UNIX: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const SDL_SIZE_MAX: i32 = -1;
pub const SDL_PRIs64: &[u8; 3] = b"ld\0";
pub const SDL_PRIu64: &[u8; 3] = b"lu\0";
pub const SDL_PRIx64: &[u8; 3] = b"lx\0";
pub const SDL_PRIX64: &[u8; 3] = b"lX\0";
pub const SDL_PRIs32: &[u8; 2] = b"d\0";
pub const SDL_PRIu32: &[u8; 2] = b"u\0";
pub const SDL_PRIx32: &[u8; 2] = b"x\0";
pub const SDL_PRIX32: &[u8; 2] = b"X\0";
pub const SDL_PRILL_PREFIX: &[u8; 3] = b"ll\0";
pub const SDL_PRILLd: &[u8; 4] = b"lld\0";
pub const SDL_PRILLu: &[u8; 4] = b"llu\0";
pub const SDL_PRILLx: &[u8; 4] = b"llx\0";
pub const SDL_PRILLX: &[u8; 4] = b"llX\0";
pub const SDL_INVALID_UNICODE_CODEPOINT: u32 = 65533;
pub const SDL_PI_D: f64 = 3.141592653589793;
pub const SDL_PI_F: f64 = 3.141592653589793;
pub const SDL_LIL_ENDIAN: u32 = 1234;
pub const SDL_BIG_ENDIAN: u32 = 4321;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const SDL_BYTEORDER: u32 = 1234;
pub const SDL_FLOATWORDORDER: u32 = 1234;
pub const SDL_PROP_THREAD_CREATE_ENTRY_FUNCTION_POINTER: &[u8; 33] =
    b"SDL.thread.create.entry_function\0";
pub const SDL_PROP_THREAD_CREATE_NAME_STRING: &[u8; 23] = b"SDL.thread.create.name\0";
pub const SDL_PROP_THREAD_CREATE_USERDATA_POINTER: &[u8; 27] = b"SDL.thread.create.userdata\0";
pub const SDL_PROP_THREAD_CREATE_STACKSIZE_NUMBER: &[u8; 28] = b"SDL.thread.create.stacksize\0";
pub const SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER: &[u8; 28] = b"SDL.iostream.windows.handle\0";
pub const SDL_PROP_IOSTREAM_STDIO_FILE_POINTER: &[u8; 24] = b"SDL.iostream.stdio.file\0";
pub const SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER: &[u8; 29] = b"SDL.iostream.file_descriptor\0";
pub const SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER: &[u8; 28] = b"SDL.iostream.android.aasset\0";
pub const SDL_PROP_IOSTREAM_MEMORY_POINTER: &[u8; 25] = b"SDL.iostream.memory.base\0";
pub const SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER: &[u8; 25] = b"SDL.iostream.memory.size\0";
pub const SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER: &[u8; 28] = b"SDL.iostream.dynamic.memory\0";
pub const SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER: &[u8; 31] =
    b"SDL.iostream.dynamic.chunksize\0";
pub const SDL_AUDIO_MASK_BITSIZE: u32 = 255;
pub const SDL_AUDIO_MASK_FLOAT: u32 = 256;
pub const SDL_AUDIO_MASK_BIG_ENDIAN: u32 = 4096;
pub const SDL_AUDIO_MASK_SIGNED: u32 = 32768;
pub const SDL_ALPHA_OPAQUE: u32 = 255;
pub const SDL_ALPHA_OPAQUE_FLOAT: f64 = 1.0;
pub const SDL_ALPHA_TRANSPARENT: u32 = 0;
pub const SDL_ALPHA_TRANSPARENT_FLOAT: f64 = 0.0;
pub const SDL_BLENDMODE_NONE: u32 = 0;
pub const SDL_BLENDMODE_BLEND: u32 = 1;
pub const SDL_BLENDMODE_BLEND_PREMULTIPLIED: u32 = 16;
pub const SDL_BLENDMODE_ADD: u32 = 2;
pub const SDL_BLENDMODE_ADD_PREMULTIPLIED: u32 = 32;
pub const SDL_BLENDMODE_MOD: u32 = 4;
pub const SDL_BLENDMODE_MUL: u32 = 8;
pub const SDL_BLENDMODE_INVALID: u32 = 2147483647;
pub const SDL_SURFACE_PREALLOCATED: u32 = 1;
pub const SDL_SURFACE_LOCK_NEEDED: u32 = 2;
pub const SDL_SURFACE_LOCKED: u32 = 4;
pub const SDL_SURFACE_SIMD_ALIGNED: u32 = 8;
pub const SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT: &[u8; 28] = b"SDL.surface.SDR_white_point\0";
pub const SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT: &[u8; 25] = b"SDL.surface.HDR_headroom\0";
pub const SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING: &[u8; 20] = b"SDL.surface.tonemap\0";
pub const SDL_STANDARD_GRAVITY: f64 = 9.80665;
pub const SDL_JOYSTICK_AXIS_MAX: u32 = 32767;
pub const SDL_JOYSTICK_AXIS_MIN: i32 = -32768;
pub const SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN: &[u8; 26] = b"SDL.joystick.cap.mono_led\0";
pub const SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN: &[u8; 25] = b"SDL.joystick.cap.rgb_led\0";
pub const SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN: &[u8; 28] = b"SDL.joystick.cap.player_led\0";
pub const SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN: &[u8; 24] = b"SDL.joystick.cap.rumble\0";
pub const SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN: &[u8; 32] =
    b"SDL.joystick.cap.trigger_rumble\0";
pub const SDL_HAT_CENTERED: u32 = 0;
pub const SDL_HAT_UP: u32 = 1;
pub const SDL_HAT_RIGHT: u32 = 2;
pub const SDL_HAT_DOWN: u32 = 4;
pub const SDL_HAT_LEFT: u32 = 8;
pub const SDL_HAT_RIGHTUP: u32 = 3;
pub const SDL_HAT_RIGHTDOWN: u32 = 6;
pub const SDL_HAT_LEFTUP: u32 = 9;
pub const SDL_HAT_LEFTDOWN: u32 = 12;
pub const SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN: &[u8; 26] = b"SDL.joystick.cap.mono_led\0";
pub const SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN: &[u8; 25] = b"SDL.joystick.cap.rgb_led\0";
pub const SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN: &[u8; 28] = b"SDL.joystick.cap.player_led\0";
pub const SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN: &[u8; 24] = b"SDL.joystick.cap.rumble\0";
pub const SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN: &[u8; 32] =
    b"SDL.joystick.cap.trigger_rumble\0";
pub const SDLK_EXTENDED_MASK: u32 = 536870912;
pub const SDLK_SCANCODE_MASK: u32 = 1073741824;
pub const SDLK_UNKNOWN: u32 = 0;
pub const SDLK_RETURN: u32 = 13;
pub const SDLK_ESCAPE: u32 = 27;
pub const SDLK_BACKSPACE: u32 = 8;
pub const SDLK_TAB: u32 = 9;
pub const SDLK_SPACE: u32 = 32;
pub const SDLK_EXCLAIM: u32 = 33;
pub const SDLK_DBLAPOSTROPHE: u32 = 34;
pub const SDLK_HASH: u32 = 35;
pub const SDLK_DOLLAR: u32 = 36;
pub const SDLK_PERCENT: u32 = 37;
pub const SDLK_AMPERSAND: u32 = 38;
pub const SDLK_APOSTROPHE: u32 = 39;
pub const SDLK_LEFTPAREN: u32 = 40;
pub const SDLK_RIGHTPAREN: u32 = 41;
pub const SDLK_ASTERISK: u32 = 42;
pub const SDLK_PLUS: u32 = 43;
pub const SDLK_COMMA: u32 = 44;
pub const SDLK_MINUS: u32 = 45;
pub const SDLK_PERIOD: u32 = 46;
pub const SDLK_SLASH: u32 = 47;
pub const SDLK_0: u32 = 48;
pub const SDLK_1: u32 = 49;
pub const SDLK_2: u32 = 50;
pub const SDLK_3: u32 = 51;
pub const SDLK_4: u32 = 52;
pub const SDLK_5: u32 = 53;
pub const SDLK_6: u32 = 54;
pub const SDLK_7: u32 = 55;
pub const SDLK_8: u32 = 56;
pub const SDLK_9: u32 = 57;
pub const SDLK_COLON: u32 = 58;
pub const SDLK_SEMICOLON: u32 = 59;
pub const SDLK_LESS: u32 = 60;
pub const SDLK_EQUALS: u32 = 61;
pub const SDLK_GREATER: u32 = 62;
pub const SDLK_QUESTION: u32 = 63;
pub const SDLK_AT: u32 = 64;
pub const SDLK_LEFTBRACKET: u32 = 91;
pub const SDLK_BACKSLASH: u32 = 92;
pub const SDLK_RIGHTBRACKET: u32 = 93;
pub const SDLK_CARET: u32 = 94;
pub const SDLK_UNDERSCORE: u32 = 95;
pub const SDLK_GRAVE: u32 = 96;
pub const SDLK_A: u32 = 97;
pub const SDLK_B: u32 = 98;
pub const SDLK_C: u32 = 99;
pub const SDLK_D: u32 = 100;
pub const SDLK_E: u32 = 101;
pub const SDLK_F: u32 = 102;
pub const SDLK_G: u32 = 103;
pub const SDLK_H: u32 = 104;
pub const SDLK_I: u32 = 105;
pub const SDLK_J: u32 = 106;
pub const SDLK_K: u32 = 107;
pub const SDLK_L: u32 = 108;
pub const SDLK_M: u32 = 109;
pub const SDLK_N: u32 = 110;
pub const SDLK_O: u32 = 111;
pub const SDLK_P: u32 = 112;
pub const SDLK_Q: u32 = 113;
pub const SDLK_R: u32 = 114;
pub const SDLK_S: u32 = 115;
pub const SDLK_T: u32 = 116;
pub const SDLK_U: u32 = 117;
pub const SDLK_V: u32 = 118;
pub const SDLK_W: u32 = 119;
pub const SDLK_X: u32 = 120;
pub const SDLK_Y: u32 = 121;
pub const SDLK_Z: u32 = 122;
pub const SDLK_LEFTBRACE: u32 = 123;
pub const SDLK_PIPE: u32 = 124;
pub const SDLK_RIGHTBRACE: u32 = 125;
pub const SDLK_TILDE: u32 = 126;
pub const SDLK_DELETE: u32 = 127;
pub const SDLK_PLUSMINUS: u32 = 177;
pub const SDLK_CAPSLOCK: u32 = 1073741881;
pub const SDLK_F1: u32 = 1073741882;
pub const SDLK_F2: u32 = 1073741883;
pub const SDLK_F3: u32 = 1073741884;
pub const SDLK_F4: u32 = 1073741885;
pub const SDLK_F5: u32 = 1073741886;
pub const SDLK_F6: u32 = 1073741887;
pub const SDLK_F7: u32 = 1073741888;
pub const SDLK_F8: u32 = 1073741889;
pub const SDLK_F9: u32 = 1073741890;
pub const SDLK_F10: u32 = 1073741891;
pub const SDLK_F11: u32 = 1073741892;
pub const SDLK_F12: u32 = 1073741893;
pub const SDLK_PRINTSCREEN: u32 = 1073741894;
pub const SDLK_SCROLLLOCK: u32 = 1073741895;
pub const SDLK_PAUSE: u32 = 1073741896;
pub const SDLK_INSERT: u32 = 1073741897;
pub const SDLK_HOME: u32 = 1073741898;
pub const SDLK_PAGEUP: u32 = 1073741899;
pub const SDLK_END: u32 = 1073741901;
pub const SDLK_PAGEDOWN: u32 = 1073741902;
pub const SDLK_RIGHT: u32 = 1073741903;
pub const SDLK_LEFT: u32 = 1073741904;
pub const SDLK_DOWN: u32 = 1073741905;
pub const SDLK_UP: u32 = 1073741906;
pub const SDLK_NUMLOCKCLEAR: u32 = 1073741907;
pub const SDLK_KP_DIVIDE: u32 = 1073741908;
pub const SDLK_KP_MULTIPLY: u32 = 1073741909;
pub const SDLK_KP_MINUS: u32 = 1073741910;
pub const SDLK_KP_PLUS: u32 = 1073741911;
pub const SDLK_KP_ENTER: u32 = 1073741912;
pub const SDLK_KP_1: u32 = 1073741913;
pub const SDLK_KP_2: u32 = 1073741914;
pub const SDLK_KP_3: u32 = 1073741915;
pub const SDLK_KP_4: u32 = 1073741916;
pub const SDLK_KP_5: u32 = 1073741917;
pub const SDLK_KP_6: u32 = 1073741918;
pub const SDLK_KP_7: u32 = 1073741919;
pub const SDLK_KP_8: u32 = 1073741920;
pub const SDLK_KP_9: u32 = 1073741921;
pub const SDLK_KP_0: u32 = 1073741922;
pub const SDLK_KP_PERIOD: u32 = 1073741923;
pub const SDLK_APPLICATION: u32 = 1073741925;
pub const SDLK_POWER: u32 = 1073741926;
pub const SDLK_KP_EQUALS: u32 = 1073741927;
pub const SDLK_F13: u32 = 1073741928;
pub const SDLK_F14: u32 = 1073741929;
pub const SDLK_F15: u32 = 1073741930;
pub const SDLK_F16: u32 = 1073741931;
pub const SDLK_F17: u32 = 1073741932;
pub const SDLK_F18: u32 = 1073741933;
pub const SDLK_F19: u32 = 1073741934;
pub const SDLK_F20: u32 = 1073741935;
pub const SDLK_F21: u32 = 1073741936;
pub const SDLK_F22: u32 = 1073741937;
pub const SDLK_F23: u32 = 1073741938;
pub const SDLK_F24: u32 = 1073741939;
pub const SDLK_EXECUTE: u32 = 1073741940;
pub const SDLK_HELP: u32 = 1073741941;
pub const SDLK_MENU: u32 = 1073741942;
pub const SDLK_SELECT: u32 = 1073741943;
pub const SDLK_STOP: u32 = 1073741944;
pub const SDLK_AGAIN: u32 = 1073741945;
pub const SDLK_UNDO: u32 = 1073741946;
pub const SDLK_CUT: u32 = 1073741947;
pub const SDLK_COPY: u32 = 1073741948;
pub const SDLK_PASTE: u32 = 1073741949;
pub const SDLK_FIND: u32 = 1073741950;
pub const SDLK_MUTE: u32 = 1073741951;
pub const SDLK_VOLUMEUP: u32 = 1073741952;
pub const SDLK_VOLUMEDOWN: u32 = 1073741953;
pub const SDLK_KP_COMMA: u32 = 1073741957;
pub const SDLK_KP_EQUALSAS400: u32 = 1073741958;
pub const SDLK_ALTERASE: u32 = 1073741977;
pub const SDLK_SYSREQ: u32 = 1073741978;
pub const SDLK_CANCEL: u32 = 1073741979;
pub const SDLK_CLEAR: u32 = 1073741980;
pub const SDLK_PRIOR: u32 = 1073741981;
pub const SDLK_RETURN2: u32 = 1073741982;
pub const SDLK_SEPARATOR: u32 = 1073741983;
pub const SDLK_OUT: u32 = 1073741984;
pub const SDLK_OPER: u32 = 1073741985;
pub const SDLK_CLEARAGAIN: u32 = 1073741986;
pub const SDLK_CRSEL: u32 = 1073741987;
pub const SDLK_EXSEL: u32 = 1073741988;
pub const SDLK_KP_00: u32 = 1073742000;
pub const SDLK_KP_000: u32 = 1073742001;
pub const SDLK_THOUSANDSSEPARATOR: u32 = 1073742002;
pub const SDLK_DECIMALSEPARATOR: u32 = 1073742003;
pub const SDLK_CURRENCYUNIT: u32 = 1073742004;
pub const SDLK_CURRENCYSUBUNIT: u32 = 1073742005;
pub const SDLK_KP_LEFTPAREN: u32 = 1073742006;
pub const SDLK_KP_RIGHTPAREN: u32 = 1073742007;
pub const SDLK_KP_LEFTBRACE: u32 = 1073742008;
pub const SDLK_KP_RIGHTBRACE: u32 = 1073742009;
pub const SDLK_KP_TAB: u32 = 1073742010;
pub const SDLK_KP_BACKSPACE: u32 = 1073742011;
pub const SDLK_KP_A: u32 = 1073742012;
pub const SDLK_KP_B: u32 = 1073742013;
pub const SDLK_KP_C: u32 = 1073742014;
pub const SDLK_KP_D: u32 = 1073742015;
pub const SDLK_KP_E: u32 = 1073742016;
pub const SDLK_KP_F: u32 = 1073742017;
pub const SDLK_KP_XOR: u32 = 1073742018;
pub const SDLK_KP_POWER: u32 = 1073742019;
pub const SDLK_KP_PERCENT: u32 = 1073742020;
pub const SDLK_KP_LESS: u32 = 1073742021;
pub const SDLK_KP_GREATER: u32 = 1073742022;
pub const SDLK_KP_AMPERSAND: u32 = 1073742023;
pub const SDLK_KP_DBLAMPERSAND: u32 = 1073742024;
pub const SDLK_KP_VERTICALBAR: u32 = 1073742025;
pub const SDLK_KP_DBLVERTICALBAR: u32 = 1073742026;
pub const SDLK_KP_COLON: u32 = 1073742027;
pub const SDLK_KP_HASH: u32 = 1073742028;
pub const SDLK_KP_SPACE: u32 = 1073742029;
pub const SDLK_KP_AT: u32 = 1073742030;
pub const SDLK_KP_EXCLAM: u32 = 1073742031;
pub const SDLK_KP_MEMSTORE: u32 = 1073742032;
pub const SDLK_KP_MEMRECALL: u32 = 1073742033;
pub const SDLK_KP_MEMCLEAR: u32 = 1073742034;
pub const SDLK_KP_MEMADD: u32 = 1073742035;
pub const SDLK_KP_MEMSUBTRACT: u32 = 1073742036;
pub const SDLK_KP_MEMMULTIPLY: u32 = 1073742037;
pub const SDLK_KP_MEMDIVIDE: u32 = 1073742038;
pub const SDLK_KP_PLUSMINUS: u32 = 1073742039;
pub const SDLK_KP_CLEAR: u32 = 1073742040;
pub const SDLK_KP_CLEARENTRY: u32 = 1073742041;
pub const SDLK_KP_BINARY: u32 = 1073742042;
pub const SDLK_KP_OCTAL: u32 = 1073742043;
pub const SDLK_KP_DECIMAL: u32 = 1073742044;
pub const SDLK_KP_HEXADECIMAL: u32 = 1073742045;
pub const SDLK_LCTRL: u32 = 1073742048;
pub const SDLK_LSHIFT: u32 = 1073742049;
pub const SDLK_LALT: u32 = 1073742050;
pub const SDLK_LGUI: u32 = 1073742051;
pub const SDLK_RCTRL: u32 = 1073742052;
pub const SDLK_RSHIFT: u32 = 1073742053;
pub const SDLK_RALT: u32 = 1073742054;
pub const SDLK_RGUI: u32 = 1073742055;
pub const SDLK_MODE: u32 = 1073742081;
pub const SDLK_SLEEP: u32 = 1073742082;
pub const SDLK_WAKE: u32 = 1073742083;
pub const SDLK_CHANNEL_INCREMENT: u32 = 1073742084;
pub const SDLK_CHANNEL_DECREMENT: u32 = 1073742085;
pub const SDLK_MEDIA_PLAY: u32 = 1073742086;
pub const SDLK_MEDIA_PAUSE: u32 = 1073742087;
pub const SDLK_MEDIA_RECORD: u32 = 1073742088;
pub const SDLK_MEDIA_FAST_FORWARD: u32 = 1073742089;
pub const SDLK_MEDIA_REWIND: u32 = 1073742090;
pub const SDLK_MEDIA_NEXT_TRACK: u32 = 1073742091;
pub const SDLK_MEDIA_PREVIOUS_TRACK: u32 = 1073742092;
pub const SDLK_MEDIA_STOP: u32 = 1073742093;
pub const SDLK_MEDIA_EJECT: u32 = 1073742094;
pub const SDLK_MEDIA_PLAY_PAUSE: u32 = 1073742095;
pub const SDLK_MEDIA_SELECT: u32 = 1073742096;
pub const SDLK_AC_NEW: u32 = 1073742097;
pub const SDLK_AC_OPEN: u32 = 1073742098;
pub const SDLK_AC_CLOSE: u32 = 1073742099;
pub const SDLK_AC_EXIT: u32 = 1073742100;
pub const SDLK_AC_SAVE: u32 = 1073742101;
pub const SDLK_AC_PRINT: u32 = 1073742102;
pub const SDLK_AC_PROPERTIES: u32 = 1073742103;
pub const SDLK_AC_SEARCH: u32 = 1073742104;
pub const SDLK_AC_HOME: u32 = 1073742105;
pub const SDLK_AC_BACK: u32 = 1073742106;
pub const SDLK_AC_FORWARD: u32 = 1073742107;
pub const SDLK_AC_STOP: u32 = 1073742108;
pub const SDLK_AC_REFRESH: u32 = 1073742109;
pub const SDLK_AC_BOOKMARKS: u32 = 1073742110;
pub const SDLK_SOFTLEFT: u32 = 1073742111;
pub const SDLK_SOFTRIGHT: u32 = 1073742112;
pub const SDLK_CALL: u32 = 1073742113;
pub const SDLK_ENDCALL: u32 = 1073742114;
pub const SDLK_LEFT_TAB: u32 = 536870913;
pub const SDLK_LEVEL5_SHIFT: u32 = 536870914;
pub const SDLK_MULTI_KEY_COMPOSE: u32 = 536870915;
pub const SDLK_LMETA: u32 = 536870916;
pub const SDLK_RMETA: u32 = 536870917;
pub const SDLK_LHYPER: u32 = 536870918;
pub const SDLK_RHYPER: u32 = 536870919;
pub const SDL_KMOD_NONE: u32 = 0;
pub const SDL_KMOD_LSHIFT: u32 = 1;
pub const SDL_KMOD_RSHIFT: u32 = 2;
pub const SDL_KMOD_LEVEL5: u32 = 4;
pub const SDL_KMOD_LCTRL: u32 = 64;
pub const SDL_KMOD_RCTRL: u32 = 128;
pub const SDL_KMOD_LALT: u32 = 256;
pub const SDL_KMOD_RALT: u32 = 512;
pub const SDL_KMOD_LGUI: u32 = 1024;
pub const SDL_KMOD_RGUI: u32 = 2048;
pub const SDL_KMOD_NUM: u32 = 4096;
pub const SDL_KMOD_CAPS: u32 = 8192;
pub const SDL_KMOD_MODE: u32 = 16384;
pub const SDL_KMOD_SCROLL: u32 = 32768;
pub const SDL_KMOD_CTRL: u32 = 192;
pub const SDL_KMOD_SHIFT: u32 = 3;
pub const SDL_KMOD_ALT: u32 = 768;
pub const SDL_KMOD_GUI: u32 = 3072;
pub const SDL_PROP_GLOBAL_VIDEO_WAYLAND_WL_DISPLAY_POINTER: &[u8; 29] =
    b"SDL.video.wayland.wl_display\0";
pub const SDL_WINDOWPOS_UNDEFINED_MASK: u32 = 536805376;
pub const SDL_WINDOWPOS_CENTERED_MASK: u32 = 805240832;
pub const SDL_GL_CONTEXT_PROFILE_CORE: u32 = 1;
pub const SDL_GL_CONTEXT_PROFILE_COMPATIBILITY: u32 = 2;
pub const SDL_GL_CONTEXT_PROFILE_ES: u32 = 4;
pub const SDL_GL_CONTEXT_DEBUG_FLAG: u32 = 1;
pub const SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG: u32 = 2;
pub const SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG: u32 = 4;
pub const SDL_GL_CONTEXT_RESET_ISOLATION_FLAG: u32 = 8;
pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE: u32 = 0;
pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: u32 = 1;
pub const SDL_GL_CONTEXT_RESET_NO_NOTIFICATION: u32 = 0;
pub const SDL_GL_CONTEXT_RESET_LOSE_CONTEXT: u32 = 1;
pub const SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN: &[u8; 24] = b"SDL.display.HDR_enabled\0";
pub const SDL_PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER: &[u8; 37] =
    b"SDL.display.KMSDRM.panel_orientation\0";
pub const SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN: &[u8; 32] =
    b"SDL.window.create.always_on_top\0";
pub const SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN: &[u8; 29] = b"SDL.window.create.borderless\0";
pub const SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN: &[u8; 28] = b"SDL.window.create.focusable\0";
pub const SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN: &[u8; 44] =
    b"SDL.window.create.external_graphics_context\0";
pub const SDL_PROP_WINDOW_CREATE_FLAGS_NUMBER: &[u8; 24] = b"SDL.window.create.flags\0";
pub const SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN: &[u8; 29] = b"SDL.window.create.fullscreen\0";
pub const SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER: &[u8; 25] = b"SDL.window.create.height\0";
pub const SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN: &[u8; 25] = b"SDL.window.create.hidden\0";
pub const SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN: &[u8; 37] =
    b"SDL.window.create.high_pixel_density\0";
pub const SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN: &[u8; 28] = b"SDL.window.create.maximized\0";
pub const SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN: &[u8; 23] = b"SDL.window.create.menu\0";
pub const SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN: &[u8; 24] = b"SDL.window.create.metal\0";
pub const SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN: &[u8; 28] = b"SDL.window.create.minimized\0";
pub const SDL_PROP_WINDOW_CREATE_MODAL_BOOLEAN: &[u8; 24] = b"SDL.window.create.modal\0";
pub const SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN: &[u8; 32] =
    b"SDL.window.create.mouse_grabbed\0";
pub const SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN: &[u8; 25] = b"SDL.window.create.opengl\0";
pub const SDL_PROP_WINDOW_CREATE_PARENT_POINTER: &[u8; 25] = b"SDL.window.create.parent\0";
pub const SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN: &[u8; 28] = b"SDL.window.create.resizable\0";
pub const SDL_PROP_WINDOW_CREATE_TITLE_STRING: &[u8; 24] = b"SDL.window.create.title\0";
pub const SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN: &[u8; 30] =
    b"SDL.window.create.transparent\0";
pub const SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN: &[u8; 26] = b"SDL.window.create.tooltip\0";
pub const SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN: &[u8; 26] = b"SDL.window.create.utility\0";
pub const SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN: &[u8; 25] = b"SDL.window.create.vulkan\0";
pub const SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER: &[u8; 24] = b"SDL.window.create.width\0";
pub const SDL_PROP_WINDOW_CREATE_X_NUMBER: &[u8; 20] = b"SDL.window.create.x\0";
pub const SDL_PROP_WINDOW_CREATE_Y_NUMBER: &[u8; 20] = b"SDL.window.create.y\0";
pub const SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER: &[u8; 31] =
    b"SDL.window.create.cocoa.window\0";
pub const SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER: &[u8; 29] = b"SDL.window.create.cocoa.view\0";
pub const SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN: &[u8; 46] =
    b"SDL.window.create.wayland.surface_role_custom\0";
pub const SDL_PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN: &[u8; 44] =
    b"SDL.window.create.wayland.create_egl_window\0";
pub const SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER: &[u8; 37] =
    b"SDL.window.create.wayland.wl_surface\0";
pub const SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER: &[u8; 29] = b"SDL.window.create.win32.hwnd\0";
pub const SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER: &[u8; 42] =
    b"SDL.window.create.win32.pixel_format_hwnd\0";
pub const SDL_PROP_WINDOW_CREATE_X11_WINDOW_NUMBER: &[u8; 29] = b"SDL.window.create.x11.window\0";
pub const SDL_PROP_WINDOW_SHAPE_POINTER: &[u8; 17] = b"SDL.window.shape\0";
pub const SDL_PROP_WINDOW_HDR_ENABLED_BOOLEAN: &[u8; 23] = b"SDL.window.HDR_enabled\0";
pub const SDL_PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT: &[u8; 27] = b"SDL.window.SDR_white_level\0";
pub const SDL_PROP_WINDOW_HDR_HEADROOM_FLOAT: &[u8; 24] = b"SDL.window.HDR_headroom\0";
pub const SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER: &[u8; 26] = b"SDL.window.android.window\0";
pub const SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER: &[u8; 27] = b"SDL.window.android.surface\0";
pub const SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER: &[u8; 24] = b"SDL.window.uikit.window\0";
pub const SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER: &[u8; 32] =
    b"SDL.window.uikit.metal_view_tag\0";
pub const SDL_PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER: &[u8; 36] =
    b"SDL.window.uikit.opengl.framebuffer\0";
pub const SDL_PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER: &[u8; 37] =
    b"SDL.window.uikit.opengl.renderbuffer\0";
pub const SDL_PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER: &[u8; 44] =
    b"SDL.window.uikit.opengl.resolve_framebuffer\0";
pub const SDL_PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER: &[u8; 28] = b"SDL.window.kmsdrm.dev_index\0";
pub const SDL_PROP_WINDOW_KMSDRM_DRM_FD_NUMBER: &[u8; 25] = b"SDL.window.kmsdrm.drm_fd\0";
pub const SDL_PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER: &[u8; 26] = b"SDL.window.kmsdrm.gbm_dev\0";
pub const SDL_PROP_WINDOW_COCOA_WINDOW_POINTER: &[u8; 24] = b"SDL.window.cocoa.window\0";
pub const SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER: &[u8; 32] =
    b"SDL.window.cocoa.metal_view_tag\0";
pub const SDL_PROP_WINDOW_OPENVR_OVERLAY_ID: &[u8; 29] = b"SDL.window.openvr.overlay_id\0";
pub const SDL_PROP_WINDOW_VIVANTE_DISPLAY_POINTER: &[u8; 27] = b"SDL.window.vivante.display\0";
pub const SDL_PROP_WINDOW_VIVANTE_WINDOW_POINTER: &[u8; 26] = b"SDL.window.vivante.window\0";
pub const SDL_PROP_WINDOW_VIVANTE_SURFACE_POINTER: &[u8; 27] = b"SDL.window.vivante.surface\0";
pub const SDL_PROP_WINDOW_WIN32_HWND_POINTER: &[u8; 22] = b"SDL.window.win32.hwnd\0";
pub const SDL_PROP_WINDOW_WIN32_HDC_POINTER: &[u8; 21] = b"SDL.window.win32.hdc\0";
pub const SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER: &[u8; 26] = b"SDL.window.win32.instance\0";
pub const SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER: &[u8; 27] = b"SDL.window.wayland.display\0";
pub const SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER: &[u8; 27] = b"SDL.window.wayland.surface\0";
pub const SDL_PROP_WINDOW_WAYLAND_VIEWPORT_POINTER: &[u8; 28] = b"SDL.window.wayland.viewport\0";
pub const SDL_PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER: &[u8; 30] =
    b"SDL.window.wayland.egl_window\0";
pub const SDL_PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER: &[u8; 31] =
    b"SDL.window.wayland.xdg_surface\0";
pub const SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER: &[u8; 32] =
    b"SDL.window.wayland.xdg_toplevel\0";
pub const SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING: &[u8; 46] =
    b"SDL.window.wayland.xdg_toplevel_export_handle\0";
pub const SDL_PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER: &[u8; 29] = b"SDL.window.wayland.xdg_popup\0";
pub const SDL_PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER: &[u8; 34] =
    b"SDL.window.wayland.xdg_positioner\0";
pub const SDL_PROP_WINDOW_X11_DISPLAY_POINTER: &[u8; 23] = b"SDL.window.x11.display\0";
pub const SDL_PROP_WINDOW_X11_SCREEN_NUMBER: &[u8; 22] = b"SDL.window.x11.screen\0";
pub const SDL_PROP_WINDOW_X11_WINDOW_NUMBER: &[u8; 22] = b"SDL.window.x11.window\0";
pub const SDL_WINDOW_SURFACE_VSYNC_DISABLED: u32 = 0;
pub const SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE: i32 = -1;
pub const SDL_PROP_TEXTINPUT_TYPE_NUMBER: &[u8; 19] = b"SDL.textinput.type\0";
pub const SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER: &[u8; 29] = b"SDL.textinput.capitalization\0";
pub const SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN: &[u8; 26] = b"SDL.textinput.autocorrect\0";
pub const SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN: &[u8; 24] = b"SDL.textinput.multiline\0";
pub const SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER: &[u8; 32] =
    b"SDL.textinput.android.inputtype\0";
pub const SDL_BUTTON_LEFT: u32 = 1;
pub const SDL_BUTTON_MIDDLE: u32 = 2;
pub const SDL_BUTTON_RIGHT: u32 = 3;
pub const SDL_BUTTON_X1: u32 = 4;
pub const SDL_BUTTON_X2: u32 = 5;
pub const SDL_PEN_INPUT_DOWN: u32 = 1;
pub const SDL_PEN_INPUT_BUTTON_1: u32 = 2;
pub const SDL_PEN_INPUT_BUTTON_2: u32 = 4;
pub const SDL_PEN_INPUT_BUTTON_3: u32 = 8;
pub const SDL_PEN_INPUT_BUTTON_4: u32 = 16;
pub const SDL_PEN_INPUT_BUTTON_5: u32 = 32;
pub const SDL_PEN_INPUT_ERASER_TIP: u32 = 1073741824;
pub const SDL_INIT_AUDIO: u32 = 16;
pub const SDL_INIT_VIDEO: u32 = 32;
pub const SDL_INIT_JOYSTICK: u32 = 512;
pub const SDL_INIT_HAPTIC: u32 = 4096;
pub const SDL_INIT_GAMEPAD: u32 = 8192;
pub const SDL_INIT_EVENTS: u32 = 16384;
pub const SDL_INIT_SENSOR: u32 = 32768;
pub const SDL_INIT_CAMERA: u32 = 65536;
pub const SDL_PROP_APP_METADATA_NAME_STRING: &[u8; 22] = b"SDL.app.metadata.name\0";
pub const SDL_PROP_APP_METADATA_VERSION_STRING: &[u8; 25] = b"SDL.app.metadata.version\0";
pub const SDL_PROP_APP_METADATA_IDENTIFIER_STRING: &[u8; 28] = b"SDL.app.metadata.identifier\0";
pub const SDL_PROP_APP_METADATA_CREATOR_STRING: &[u8; 25] = b"SDL.app.metadata.creator\0";
pub const SDL_PROP_APP_METADATA_COPYRIGHT_STRING: &[u8; 27] = b"SDL.app.metadata.copyright\0";
pub const SDL_PROP_APP_METADATA_URL_STRING: &[u8; 21] = b"SDL.app.metadata.url\0";
pub const SDL_PROP_APP_METADATA_TYPE_STRING: &[u8; 22] = b"SDL.app.metadata.type\0";
pub const SDL_MAIN_CALLBACK_STANDARD: u32 = 1;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::core::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::core::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::core::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::core::ffi::c_ushort,
    pub __ctype_tolower: *const ::core::ffi::c_int,
    pub __ctype_toupper: *const ::core::ffi::c_int,
    pub __names: [*const ::core::ffi::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::core::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::core::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::core::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::core::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::core::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::core::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::core::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __l: locale_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::core::ffi::c_char,
        __reject: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcasestr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn memmem(
        __haystack: *const ::core::ffi::c_void,
        __haystacklen: usize,
        __needle: *const ::core::ffi::c_void,
        __needlelen: usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::core::ffi::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(__errnum: ::core::ffi::c_int, __l: locale_t) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::core::ffi::c_void,
        __dest: *mut ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::core::ffi::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strlcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type wchar_t = ::core::ffi::c_int;
pub type wint_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::core::ffi::c_uint,
    pub __wchb: [::core::ffi::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::core::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::core::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::core::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::core::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::core::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::core::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::core::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::core::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
pub type mbstate_t = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcslcpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcslcat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcscmp(
        __s1: *const ::core::ffi::c_int,
        __s2: *const ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsncmp(
        __s1: *const ::core::ffi::c_int,
        __s2: *const ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsncasecmp(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcscasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsncasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: usize,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcscoll_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsxfrm_l(
        __s1: *mut wchar_t,
        __s2: *const wchar_t,
        __n: usize,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcschr(
        __wcs: *const ::core::ffi::c_int,
        __wc: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> usize;
}
unsafe extern "C" {
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> usize;
}
unsafe extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcstok(
        __s: *mut wchar_t,
        __delim: *const wchar_t,
        __ptr: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcslen(__s: *const ::core::ffi::c_int) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn wmemchr(
        __s: *const ::core::ffi::c_int,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wmemcmp(
        __s1: *const ::core::ffi::c_int,
        __s2: *const ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wmemcpy(
        __s1: *mut ::core::ffi::c_int,
        __s2: *const ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wmemmove(
        __s1: *mut ::core::ffi::c_int,
        __s2: *const ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn btowc(__c: ::core::ffi::c_int) -> wint_t;
}
unsafe extern "C" {
    pub fn wctob(__c: wint_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mbrtowc(
        __pwc: *mut wchar_t,
        __s: *const ::core::ffi::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcrtomb(__s: *mut ::core::ffi::c_char, __wc: wchar_t, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn __mbrlen(__s: *const ::core::ffi::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn mbrlen(__s: *const ::core::ffi::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn mbsrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::core::ffi::c_char,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsrtombs(
        __dst: *mut ::core::ffi::c_char,
        __src: *mut *const wchar_t,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn mbsnrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::core::ffi::c_char,
        __nmc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsnrtombs(
        __dst: *mut ::core::ffi::c_char,
        __src: *mut *const wchar_t,
        __nwc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
unsafe extern "C" {
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
unsafe extern "C" {
    pub fn wcstold(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> u128;
}
unsafe extern "C" {
    pub fn wcstol(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn wcstoul(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn wcstoll(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn wcstoull(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut usize) -> *mut __FILE;
}
unsafe extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wprintf(__format: *const wchar_t, ...) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn swprintf(
        __s: *mut wchar_t,
        __n: usize,
        __format: *const wchar_t,
        ...
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vswprintf(
        __s: *mut wchar_t,
        __n: usize,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wscanf(__format: *const wchar_t, ...) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vswscanf(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfwscanf"]
    pub fn vfwscanf1(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vswscanf"]
    pub fn vswscanf1(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwchar() -> wint_t;
}
unsafe extern "C" {
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
unsafe extern "C" {
    pub fn fgetws(
        __ws: *mut wchar_t,
        __n: ::core::ffi::c_int,
        __stream: *mut __FILE,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn wcsftime(
        __s: *mut wchar_t,
        __maxsize: usize,
        __format: *const wchar_t,
        __tp: *const tm,
    ) -> usize;
}
pub type __gwchar_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::core::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::core::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::core::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::core::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::core::ffi::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::core::ffi::c_int,
    ) -> uintmax_t;
}
#[doc = " A signed 8-bit integer type.\n\n \\since This macro is available since SDL 3.2.0."]
pub type Sint8 = i8;
#[doc = " An unsigned 8-bit integer type.\n\n \\since This macro is available since SDL 3.2.0."]
pub type Uint8 = u8;
#[doc = " A signed 16-bit integer type.\n\n \\since This macro is available since SDL 3.2.0."]
pub type Sint16 = i16;
#[doc = " An unsigned 16-bit integer type.\n\n \\since This macro is available since SDL 3.2.0."]
pub type Uint16 = u16;
#[doc = " A signed 32-bit integer type.\n\n \\since This macro is available since SDL 3.2.0."]
pub type Sint32 = i32;
#[doc = " An unsigned 32-bit integer type.\n\n \\since This macro is available since SDL 3.2.0."]
pub type Uint32 = u32;
#[doc = " A signed 64-bit integer type.\n\n \\since This macro is available since SDL 3.2.0.\n\n \\sa SDL_SINT64_C"]
pub type Sint64 = i64;
#[doc = " An unsigned 64-bit integer type.\n\n \\since This macro is available since SDL 3.2.0.\n\n \\sa SDL_UINT64_C"]
pub type Uint64 = u64;
#[doc = " SDL times are signed, 64-bit integers representing nanoseconds since the\n Unix epoch (Jan 1, 1970).\n\n They can be converted between POSIX time_t values with SDL_NS_TO_SECONDS()\n and SDL_SECONDS_TO_NS(), and between Windows FILETIME values with\n SDL_TimeToWindows() and SDL_TimeFromWindows().\n\n \\since This macro is available since SDL 3.2.0.\n\n \\sa SDL_MAX_SINT64\n \\sa SDL_MIN_SINT64"]
pub type SDL_Time = Sint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_alignment_test {
    pub a: Uint8,
    pub b: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_alignment_test"][::core::mem::size_of::<SDL_alignment_test>() - 16usize];
    ["Alignment of SDL_alignment_test"][::core::mem::align_of::<SDL_alignment_test>() - 8usize];
    ["Offset of field: SDL_alignment_test::a"]
        [::core::mem::offset_of!(SDL_alignment_test, a) - 0usize];
    ["Offset of field: SDL_alignment_test::b"]
        [::core::mem::offset_of!(SDL_alignment_test, b) - 8usize];
};
pub const SDL_DUMMY_ENUM_DUMMY_ENUM_VALUE: SDL_DUMMY_ENUM = 0;
pub type SDL_DUMMY_ENUM = ::core::ffi::c_uint;
unsafe extern "C" {
    #[doc = " Allocate uninitialized memory.\n\n The allocated memory returned by this function must be freed with\n SDL_free().\n\n If `size` is 0, it will be set to 1.\n\n If you want to allocate memory aligned to a specific alignment, consider\n using SDL_aligned_alloc().\n\n \\param size the size to allocate.\n \\returns a pointer to the allocated memory, or NULL if allocation failed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_free\n \\sa SDL_calloc\n \\sa SDL_realloc\n \\sa SDL_aligned_alloc"]
    pub fn SDL_malloc(size: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Allocate a zero-initialized array.\n\n The memory returned by this function must be freed with SDL_free().\n\n If either of `nmemb` or `size` is 0, they will both be set to 1.\n\n \\param nmemb the number of elements in the array.\n \\param size the size of each element of the array.\n \\returns a pointer to the allocated array, or NULL if allocation failed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_free\n \\sa SDL_malloc\n \\sa SDL_realloc"]
    pub fn SDL_calloc(nmemb: usize, size: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Change the size of allocated memory.\n\n The memory returned by this function must be freed with SDL_free().\n\n If `size` is 0, it will be set to 1. Note that this is unlike some other C\n runtime `realloc` implementations, which may treat `realloc(mem, 0)` the\n same way as `free(mem)`.\n\n If `mem` is NULL, the behavior of this function is equivalent to\n SDL_malloc(). Otherwise, the function can have one of three possible\n outcomes:\n\n - If it returns the same pointer as `mem`, it means that `mem` was resized\n   in place without freeing.\n - If it returns a different non-NULL pointer, it means that `mem` was freed\n   and cannot be dereferenced anymore.\n - If it returns NULL (indicating failure), then `mem` will remain valid and\n   must still be freed with SDL_free().\n\n \\param mem a pointer to allocated memory to reallocate, or NULL.\n \\param size the new size of the memory.\n \\returns a pointer to the newly allocated memory, or NULL if allocation\n          failed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_free\n \\sa SDL_malloc\n \\sa SDL_calloc"]
    pub fn SDL_realloc(mem: *mut ::core::ffi::c_void, size: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Free allocated memory.\n\n The pointer is no longer valid after this call and cannot be dereferenced\n anymore.\n\n If `mem` is NULL, this function does nothing.\n\n \\param mem a pointer to allocated memory, or NULL.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_malloc\n \\sa SDL_calloc\n \\sa SDL_realloc"]
    pub fn SDL_free(mem: *mut ::core::ffi::c_void);
}
#[doc = " A callback used to implement SDL_malloc().\n\n SDL will always ensure that the passed `size` is greater than 0.\n\n \\param size the size to allocate.\n \\returns a pointer to the allocated memory, or NULL if allocation failed.\n\n \\threadsafety It should be safe to call this callback from any thread.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_malloc\n \\sa SDL_GetOriginalMemoryFunctions\n \\sa SDL_GetMemoryFunctions\n \\sa SDL_SetMemoryFunctions"]
pub type SDL_malloc_func =
    ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::core::ffi::c_void>;
#[doc = " A callback used to implement SDL_calloc().\n\n SDL will always ensure that the passed `nmemb` and `size` are both greater\n than 0.\n\n \\param nmemb the number of elements in the array.\n \\param size the size of each element of the array.\n \\returns a pointer to the allocated array, or NULL if allocation failed.\n\n \\threadsafety It should be safe to call this callback from any thread.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_calloc\n \\sa SDL_GetOriginalMemoryFunctions\n \\sa SDL_GetMemoryFunctions\n \\sa SDL_SetMemoryFunctions"]
pub type SDL_calloc_func = ::core::option::Option<
    unsafe extern "C" fn(nmemb: usize, size: usize) -> *mut ::core::ffi::c_void,
>;
#[doc = " A callback used to implement SDL_realloc().\n\n SDL will always ensure that the passed `size` is greater than 0.\n\n \\param mem a pointer to allocated memory to reallocate, or NULL.\n \\param size the new size of the memory.\n \\returns a pointer to the newly allocated memory, or NULL if allocation\n          failed.\n\n \\threadsafety It should be safe to call this callback from any thread.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_realloc\n \\sa SDL_GetOriginalMemoryFunctions\n \\sa SDL_GetMemoryFunctions\n \\sa SDL_SetMemoryFunctions"]
pub type SDL_realloc_func = ::core::option::Option<
    unsafe extern "C" fn(mem: *mut ::core::ffi::c_void, size: usize) -> *mut ::core::ffi::c_void,
>;
#[doc = " A callback used to implement SDL_free().\n\n SDL will always ensure that the passed `mem` is a non-NULL pointer.\n\n \\param mem a pointer to allocated memory.\n\n \\threadsafety It should be safe to call this callback from any thread.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_free\n \\sa SDL_GetOriginalMemoryFunctions\n \\sa SDL_GetMemoryFunctions\n \\sa SDL_SetMemoryFunctions"]
pub type SDL_free_func =
    ::core::option::Option<unsafe extern "C" fn(mem: *mut ::core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = " Get the original set of SDL memory functions.\n\n This is what SDL_malloc and friends will use by default, if there has been\n no call to SDL_SetMemoryFunctions. This is not necessarily using the C\n runtime's `malloc` functions behind the scenes! Different platforms and\n build configurations might do any number of unexpected things.\n\n \\param malloc_func filled with malloc function.\n \\param calloc_func filled with calloc function.\n \\param realloc_func filled with realloc function.\n \\param free_func filled with free function.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetOriginalMemoryFunctions(
        malloc_func: *mut SDL_malloc_func,
        calloc_func: *mut SDL_calloc_func,
        realloc_func: *mut SDL_realloc_func,
        free_func: *mut SDL_free_func,
    );
}
unsafe extern "C" {
    #[doc = " Get the current set of SDL memory functions.\n\n \\param malloc_func filled with malloc function.\n \\param calloc_func filled with calloc function.\n \\param realloc_func filled with realloc function.\n \\param free_func filled with free function.\n\n \\threadsafety This does not hold a lock, so do not call this in the\n               unlikely event of a background thread calling\n               SDL_SetMemoryFunctions simultaneously.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetMemoryFunctions\n \\sa SDL_GetOriginalMemoryFunctions"]
    pub fn SDL_GetMemoryFunctions(
        malloc_func: *mut SDL_malloc_func,
        calloc_func: *mut SDL_calloc_func,
        realloc_func: *mut SDL_realloc_func,
        free_func: *mut SDL_free_func,
    );
}
unsafe extern "C" {
    #[doc = " Replace SDL's memory allocation functions with a custom set.\n\n It is not safe to call this function once any allocations have been made,\n as future calls to SDL_free will use the new allocator, even if they came\n from an SDL_malloc made with the old one!\n\n If used, usually this needs to be the first call made into the SDL library,\n if not the very first thing done at program startup time.\n\n \\param malloc_func custom malloc function.\n \\param calloc_func custom calloc function.\n \\param realloc_func custom realloc function.\n \\param free_func custom free function.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread, but one\n               should not replace the memory functions once any allocations\n               are made!\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetMemoryFunctions\n \\sa SDL_GetOriginalMemoryFunctions"]
    pub fn SDL_SetMemoryFunctions(
        malloc_func: SDL_malloc_func,
        calloc_func: SDL_calloc_func,
        realloc_func: SDL_realloc_func,
        free_func: SDL_free_func,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Allocate memory aligned to a specific alignment.\n\n The memory returned by this function must be freed with SDL_aligned_free(),\n _not_ SDL_free().\n\n If `alignment` is less than the size of `void *`, it will be increased to\n match that.\n\n The returned memory address will be a multiple of the alignment value, and\n the size of the memory allocated will be a multiple of the alignment value.\n\n \\param alignment the alignment of the memory.\n \\param size the size to allocate.\n \\returns a pointer to the aligned memory, or NULL if allocation failed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_aligned_free"]
    pub fn SDL_aligned_alloc(alignment: usize, size: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Free memory allocated by SDL_aligned_alloc().\n\n The pointer is no longer valid after this call and cannot be dereferenced\n anymore.\n\n If `mem` is NULL, this function does nothing.\n\n \\param mem a pointer previously returned by SDL_aligned_alloc(), or NULL.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_aligned_alloc"]
    pub fn SDL_aligned_free(mem: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = " Get the number of outstanding (unfreed) allocations.\n\n \\returns the number of allocations or -1 if allocation counting is\n          disabled.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetNumAllocations() -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Environment {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Get the process environment.\n\n This is initialized at application start and is not affected by setenv()\n and unsetenv() calls after that point. Use SDL_SetEnvironmentVariable() and\n SDL_UnsetEnvironmentVariable() if you want to modify this environment, or\n SDL_setenv_unsafe() or SDL_unsetenv_unsafe() if you want changes to persist\n in the C runtime environment after SDL_Quit().\n\n \\returns a pointer to the environment for the process or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetEnvironmentVariable\n \\sa SDL_GetEnvironmentVariables\n \\sa SDL_SetEnvironmentVariable\n \\sa SDL_UnsetEnvironmentVariable"]
    pub fn SDL_GetEnvironment() -> *mut SDL_Environment;
}
unsafe extern "C" {
    #[doc = " Create a set of environment variables\n\n \\param populated true to initialize it from the C runtime environment,\n                  false to create an empty environment.\n \\returns a pointer to the new environment or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety If `populated` is false, it is safe to call this function\n               from any thread, otherwise it is safe if no other threads are\n               calling setenv() or unsetenv()\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetEnvironmentVariable\n \\sa SDL_GetEnvironmentVariables\n \\sa SDL_SetEnvironmentVariable\n \\sa SDL_UnsetEnvironmentVariable\n \\sa SDL_DestroyEnvironment"]
    pub fn SDL_CreateEnvironment(populated: bool) -> *mut SDL_Environment;
}
unsafe extern "C" {
    #[doc = " Get the value of a variable in the environment.\n\n \\param env the environment to query.\n \\param name the name of the variable to get.\n \\returns a pointer to the value of the variable or NULL if it can't be\n          found.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetEnvironment\n \\sa SDL_CreateEnvironment\n \\sa SDL_GetEnvironmentVariables\n \\sa SDL_SetEnvironmentVariable\n \\sa SDL_UnsetEnvironmentVariable"]
    pub fn SDL_GetEnvironmentVariable(
        env: *mut SDL_Environment,
        name: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get all variables in the environment.\n\n \\param env the environment to query.\n \\returns a NULL terminated array of pointers to environment variables in\n          the form \"variable=value\" or NULL on failure; call SDL_GetError()\n          for more information. This is a single allocation that should be\n          freed with SDL_free() when it is no longer needed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetEnvironment\n \\sa SDL_CreateEnvironment\n \\sa SDL_GetEnvironmentVariables\n \\sa SDL_SetEnvironmentVariable\n \\sa SDL_UnsetEnvironmentVariable"]
    pub fn SDL_GetEnvironmentVariables(env: *mut SDL_Environment) -> *mut *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Set the value of a variable in the environment.\n\n \\param env the environment to modify.\n \\param name the name of the variable to set.\n \\param value the value of the variable to set.\n \\param overwrite true to overwrite the variable if it exists, false to\n                  return success without setting the variable if it already\n                  exists.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetEnvironment\n \\sa SDL_CreateEnvironment\n \\sa SDL_GetEnvironmentVariable\n \\sa SDL_GetEnvironmentVariables\n \\sa SDL_UnsetEnvironmentVariable"]
    pub fn SDL_SetEnvironmentVariable(
        env: *mut SDL_Environment,
        name: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
        overwrite: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Clear a variable from the environment.\n\n \\param env the environment to modify.\n \\param name the name of the variable to unset.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetEnvironment\n \\sa SDL_CreateEnvironment\n \\sa SDL_GetEnvironmentVariable\n \\sa SDL_GetEnvironmentVariables\n \\sa SDL_SetEnvironmentVariable\n \\sa SDL_UnsetEnvironmentVariable"]
    pub fn SDL_UnsetEnvironmentVariable(
        env: *mut SDL_Environment,
        name: *const ::core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Destroy a set of environment variables.\n\n \\param env the environment to destroy.\n\n \\threadsafety It is safe to call this function from any thread, as long as\n               the environment is no longer in use.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateEnvironment"]
    pub fn SDL_DestroyEnvironment(env: *mut SDL_Environment);
}
unsafe extern "C" {
    #[doc = " Get the value of a variable in the environment.\n\n This function uses SDL's cached copy of the environment and is thread-safe.\n\n \\param name the name of the variable to get.\n \\returns a pointer to the value of the variable or NULL if it can't be\n          found.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_getenv(name: *const ::core::ffi::c_char) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the value of a variable in the environment.\n\n This function bypasses SDL's cached copy of the environment and is not\n thread-safe.\n\n \\param name the name of the variable to get.\n \\returns a pointer to the value of the variable or NULL if it can't be\n          found.\n\n \\threadsafety This function is not thread safe, consider using SDL_getenv()\n               instead.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_getenv"]
    pub fn SDL_getenv_unsafe(name: *const ::core::ffi::c_char) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Set the value of a variable in the environment.\n\n \\param name the name of the variable to set.\n \\param value the value of the variable to set.\n \\param overwrite 1 to overwrite the variable if it exists, 0 to return\n                  success without setting the variable if it already exists.\n \\returns 0 on success, -1 on error.\n\n \\threadsafety This function is not thread safe, consider using\n               SDL_SetEnvironmentVariable() instead.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetEnvironmentVariable"]
    pub fn SDL_setenv_unsafe(
        name: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
        overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Clear a variable from the environment.\n\n \\param name the name of the variable to unset.\n \\returns 0 on success, -1 on error.\n\n \\threadsafety This function is not thread safe, consider using\n               SDL_UnsetEnvironmentVariable() instead.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_UnsetEnvironmentVariable"]
    pub fn SDL_unsetenv_unsafe(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
#[doc = " A callback used with SDL sorting and binary search functions.\n\n \\param a a pointer to the first element being compared.\n \\param b a pointer to the second element being compared.\n \\returns -1 if `a` should be sorted before `b`, 1 if `b` should be sorted\n          before `a`, 0 if they are equal. If two elements are equal, their\n          order in the sorted array is undefined.\n\n \\since This callback is available since SDL 3.2.0.\n\n \\sa SDL_bsearch\n \\sa SDL_qsort"]
pub type SDL_CompareCallback = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const ::core::ffi::c_void,
        b: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
unsafe extern "C" {
    #[doc = " Sort an array.\n\n For example:\n\n ```c\n typedef struct {\n     int key;\n     const char *string;\n } data;\n\n int SDLCALL compare(const void *a, const void *b)\n {\n     const data *A = (const data *)a;\n     const data *B = (const data *)b;\n\n     if (A->n < B->n) {\n         return -1;\n     } else if (B->n < A->n) {\n         return 1;\n     } else {\n         return 0;\n     }\n }\n\n data values[] = {\n     { 3, \"third\" }, { 1, \"first\" }, { 2, \"second\" }\n };\n\n SDL_qsort(values, SDL_arraysize(values), sizeof(values[0]), compare);\n ```\n\n \\param base a pointer to the start of the array.\n \\param nmemb the number of elements in the array.\n \\param size the size of the elements in the array.\n \\param compare a function used to compare elements in the array.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_bsearch\n \\sa SDL_qsort_r"]
    pub fn SDL_qsort(
        base: *mut ::core::ffi::c_void,
        nmemb: usize,
        size: usize,
        compare: SDL_CompareCallback,
    );
}
unsafe extern "C" {
    #[doc = " Perform a binary search on a previously sorted array.\n\n For example:\n\n ```c\n typedef struct {\n     int key;\n     const char *string;\n } data;\n\n int SDLCALL compare(const void *a, const void *b)\n {\n     const data *A = (const data *)a;\n     const data *B = (const data *)b;\n\n     if (A->n < B->n) {\n         return -1;\n     } else if (B->n < A->n) {\n         return 1;\n     } else {\n         return 0;\n     }\n }\n\n data values[] = {\n     { 1, \"first\" }, { 2, \"second\" }, { 3, \"third\" }\n };\n data key = { 2, NULL };\n\n data *result = SDL_bsearch(&key, values, SDL_arraysize(values), sizeof(values[0]), compare);\n ```\n\n \\param key a pointer to a key equal to the element being searched for.\n \\param base a pointer to the start of the array.\n \\param nmemb the number of elements in the array.\n \\param size the size of the elements in the array.\n \\param compare a function used to compare elements in the array.\n \\returns a pointer to the matching element in the array, or NULL if not\n          found.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_bsearch_r\n \\sa SDL_qsort"]
    pub fn SDL_bsearch(
        key: *const ::core::ffi::c_void,
        base: *const ::core::ffi::c_void,
        nmemb: usize,
        size: usize,
        compare: SDL_CompareCallback,
    ) -> *mut ::core::ffi::c_void;
}
#[doc = " A callback used with SDL sorting and binary search functions.\n\n \\param userdata the `userdata` pointer passed to the sort function.\n \\param a a pointer to the first element being compared.\n \\param b a pointer to the second element being compared.\n \\returns -1 if `a` should be sorted before `b`, 1 if `b` should be sorted\n          before `a`, 0 if they are equal. If two elements are equal, their\n          order in the sorted array is undefined.\n\n \\since This callback is available since SDL 3.2.0.\n\n \\sa SDL_qsort_r\n \\sa SDL_bsearch_r"]
pub type SDL_CompareCallback_r = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::core::ffi::c_void,
        a: *const ::core::ffi::c_void,
        b: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
unsafe extern "C" {
    #[doc = " Sort an array, passing a userdata pointer to the compare function.\n\n For example:\n\n ```c\n typedef enum {\n     sort_increasing,\n     sort_decreasing,\n } sort_method;\n\n typedef struct {\n     int key;\n     const char *string;\n } data;\n\n int SDLCALL compare(const void *userdata, const void *a, const void *b)\n {\n     sort_method method = (sort_method)(uintptr_t)userdata;\n     const data *A = (const data *)a;\n     const data *B = (const data *)b;\n\n     if (A->key < B->key) {\n         return (method == sort_increasing) ? -1 : 1;\n     } else if (B->key < A->key) {\n         return (method == sort_increasing) ? 1 : -1;\n     } else {\n         return 0;\n     }\n }\n\n data values[] = {\n     { 3, \"third\" }, { 1, \"first\" }, { 2, \"second\" }\n };\n\n SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);\n ```\n\n \\param base a pointer to the start of the array.\n \\param nmemb the number of elements in the array.\n \\param size the size of the elements in the array.\n \\param compare a function used to compare elements in the array.\n \\param userdata a pointer to pass to the compare function.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_bsearch_r\n \\sa SDL_qsort"]
    pub fn SDL_qsort_r(
        base: *mut ::core::ffi::c_void,
        nmemb: usize,
        size: usize,
        compare: SDL_CompareCallback_r,
        userdata: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Perform a binary search on a previously sorted array, passing a userdata\n pointer to the compare function.\n\n For example:\n\n ```c\n typedef enum {\n     sort_increasing,\n     sort_decreasing,\n } sort_method;\n\n typedef struct {\n     int key;\n     const char *string;\n } data;\n\n int SDLCALL compare(const void *userdata, const void *a, const void *b)\n {\n     sort_method method = (sort_method)(uintptr_t)userdata;\n     const data *A = (const data *)a;\n     const data *B = (const data *)b;\n\n     if (A->key < B->key) {\n         return (method == sort_increasing) ? -1 : 1;\n     } else if (B->key < A->key) {\n         return (method == sort_increasing) ? 1 : -1;\n     } else {\n         return 0;\n     }\n }\n\n data values[] = {\n     { 1, \"first\" }, { 2, \"second\" }, { 3, \"third\" }\n };\n data key = { 2, NULL };\n\n data *result = SDL_bsearch_r(&key, values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);\n ```\n\n \\param key a pointer to a key equal to the element being searched for.\n \\param base a pointer to the start of the array.\n \\param nmemb the number of elements in the array.\n \\param size the size of the elements in the array.\n \\param compare a function used to compare elements in the array.\n \\param userdata a pointer to pass to the compare function.\n \\returns a pointer to the matching element in the array, or NULL if not\n          found.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_bsearch\n \\sa SDL_qsort_r"]
    pub fn SDL_bsearch_r(
        key: *const ::core::ffi::c_void,
        base: *const ::core::ffi::c_void,
        nmemb: usize,
        size: usize,
        compare: SDL_CompareCallback_r,
        userdata: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Compute the absolute value of `x`.\n\n \\param x an integer value.\n \\returns the absolute value of x.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_abs(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Query if a character is alphabetic (a letter).\n\n **WARNING**: Regardless of system locale, this will only treat ASCII values\n for English 'a-z' and 'A-Z' as true.\n\n \\param x character value to check.\n \\returns non-zero if x falls within the character class, zero otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_isalpha(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Query if a character is alphabetic (a letter) or a number.\n\n **WARNING**: Regardless of system locale, this will only treat ASCII values\n for English 'a-z', 'A-Z', and '0-9' as true.\n\n \\param x character value to check.\n \\returns non-zero if x falls within the character class, zero otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_isalnum(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Report if a character is blank (a space or tab).\n\n **WARNING**: Regardless of system locale, this will only treat ASCII values\n 0x20 (space) or 0x9 (tab) as true.\n\n \\param x character value to check.\n \\returns non-zero if x falls within the character class, zero otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_isblank(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Report if a character is a control character.\n\n **WARNING**: Regardless of system locale, this will only treat ASCII values\n 0 through 0x1F, and 0x7F, as true.\n\n \\param x character value to check.\n \\returns non-zero if x falls within the character class, zero otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_iscntrl(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Report if a character is a numeric digit.\n\n **WARNING**: Regardless of system locale, this will only treat ASCII values\n '0' (0x30) through '9' (0x39), as true.\n\n \\param x character value to check.\n \\returns non-zero if x falls within the character class, zero otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_isdigit(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Report if a character is a hexadecimal digit.\n\n **WARNING**: Regardless of system locale, this will only treat ASCII values\n 'A' through 'F', 'a' through 'f', and '0' through '9', as true.\n\n \\param x character value to check.\n \\returns non-zero if x falls within the character class, zero otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_isxdigit(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Report if a character is a punctuation mark.\n\n **WARNING**: Regardless of system locale, this is equivalent to\n `((SDL_isgraph(x)) && (!SDL_isalnum(x)))`.\n\n \\param x character value to check.\n \\returns non-zero if x falls within the character class, zero otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_isgraph\n \\sa SDL_isalnum"]
    pub fn SDL_ispunct(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Report if a character is whitespace.\n\n **WARNING**: Regardless of system locale, this will only treat the\n following ASCII values as true:\n\n - space (0x20)\n - tab (0x09)\n - newline (0x0A)\n - vertical tab (0x0B)\n - form feed (0x0C)\n - return (0x0D)\n\n \\param x character value to check.\n \\returns non-zero if x falls within the character class, zero otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_isspace(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Report if a character is upper case.\n\n **WARNING**: Regardless of system locale, this will only treat ASCII values\n 'A' through 'Z' as true.\n\n \\param x character value to check.\n \\returns non-zero if x falls within the character class, zero otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_isupper(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Report if a character is lower case.\n\n **WARNING**: Regardless of system locale, this will only treat ASCII values\n 'a' through 'z' as true.\n\n \\param x character value to check.\n \\returns non-zero if x falls within the character class, zero otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_islower(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Report if a character is \"printable\".\n\n Be advised that \"printable\" has a definition that goes back to text\n terminals from the dawn of computing, making this a sort of special case\n function that is not suitable for Unicode (or most any) text management.\n\n **WARNING**: Regardless of system locale, this will only treat ASCII values\n ' ' (0x20) through '~' (0x7E) as true.\n\n \\param x character value to check.\n \\returns non-zero if x falls within the character class, zero otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_isprint(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Report if a character is any \"printable\" except space.\n\n Be advised that \"printable\" has a definition that goes back to text\n terminals from the dawn of computing, making this a sort of special case\n function that is not suitable for Unicode (or most any) text management.\n\n **WARNING**: Regardless of system locale, this is equivalent to\n `(SDL_isprint(x)) && ((x) != ' ')`.\n\n \\param x character value to check.\n \\returns non-zero if x falls within the character class, zero otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_isprint"]
    pub fn SDL_isgraph(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Convert low-ASCII English letters to uppercase.\n\n **WARNING**: Regardless of system locale, this will only convert ASCII\n values 'a' through 'z' to uppercase.\n\n This function returns the uppercase equivalent of `x`. If a character\n cannot be converted, or is already uppercase, this function returns `x`.\n\n \\param x character value to check.\n \\returns capitalized version of x, or x if no conversion available.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_toupper(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Convert low-ASCII English letters to lowercase.\n\n **WARNING**: Regardless of system locale, this will only convert ASCII\n values 'A' through 'Z' to lowercase.\n\n This function returns the lowercase equivalent of `x`. If a character\n cannot be converted, or is already lowercase, this function returns `x`.\n\n \\param x character value to check.\n \\returns lowercase version of x, or x if no conversion available.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_tolower(x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Calculate a CRC-16 value.\n\n https://en.wikipedia.org/wiki/Cyclic_redundancy_check\n\n This function can be called multiple times, to stream data to be\n checksummed in blocks. Each call must provide the previous CRC-16 return\n value to be updated with the next block. The first call to this function\n for a set of blocks should pass in a zero CRC value.\n\n \\param crc the current checksum for this data set, or 0 for a new data set.\n \\param data a new block of data to add to the checksum.\n \\param len the size, in bytes, of the new block of data.\n \\returns a CRC-16 checksum value of all blocks in the data set.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_crc16(crc: Uint16, data: *const ::core::ffi::c_void, len: usize) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Calculate a CRC-32 value.\n\n https://en.wikipedia.org/wiki/Cyclic_redundancy_check\n\n This function can be called multiple times, to stream data to be\n checksummed in blocks. Each call must provide the previous CRC-32 return\n value to be updated with the next block. The first call to this function\n for a set of blocks should pass in a zero CRC value.\n\n \\param crc the current checksum for this data set, or 0 for a new data set.\n \\param data a new block of data to add to the checksum.\n \\param len the size, in bytes, of the new block of data.\n \\returns a CRC-32 checksum value of all blocks in the data set.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_crc32(crc: Uint32, data: *const ::core::ffi::c_void, len: usize) -> Uint32;
}
unsafe extern "C" {
    #[doc = " Calculate a 32-bit MurmurHash3 value for a block of data.\n\n https://en.wikipedia.org/wiki/MurmurHash\n\n A seed may be specified, which changes the final results consistently, but\n this does not work like SDL_crc16 and SDL_crc32: you can't feed a previous\n result from this function back into itself as the next seed value to\n calculate a hash in chunks; it won't produce the same hash as it would if\n the same data was provided in a single call.\n\n If you aren't sure what to provide for a seed, zero is fine. Murmur3 is not\n cryptographically secure, so it shouldn't be used for hashing top-secret\n data.\n\n \\param data the data to be hashed.\n \\param len the size of data, in bytes.\n \\param seed a value that alters the final hash value.\n \\returns a Murmur3 32-bit hash value.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_murmur3_32(data: *const ::core::ffi::c_void, len: usize, seed: Uint32) -> Uint32;
}
unsafe extern "C" {
    #[doc = " Copy non-overlapping memory.\n\n The memory regions must not overlap. If they do, use SDL_memmove() instead.\n\n \\param dst The destination memory region. Must not be NULL, and must not\n            overlap with `src`.\n \\param src The source memory region. Must not be NULL, and must not overlap\n            with `dst`.\n \\param len The length in bytes of both `dst` and `src`.\n \\returns `dst`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_memmove"]
    pub fn SDL_memcpy(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        len: usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Copy memory ranges that might overlap.\n\n It is okay for the memory regions to overlap. If you are confident that the\n regions never overlap, using SDL_memcpy() may improve performance.\n\n \\param dst The destination memory region. Must not be NULL.\n \\param src The source memory region. Must not be NULL.\n \\param len The length in bytes of both `dst` and `src`.\n \\returns `dst`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_memcpy"]
    pub fn SDL_memmove(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        len: usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Initialize all bytes of buffer of memory to a specific value.\n\n This function will set `len` bytes, pointed to by `dst`, to the value\n specified in `c`.\n\n Despite `c` being an `int` instead of a `char`, this only operates on\n bytes; `c` must be a value between 0 and 255, inclusive.\n\n \\param dst the destination memory region. Must not be NULL.\n \\param c the byte value to set.\n \\param len the length, in bytes, to set in `dst`.\n \\returns `dst`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_memset(
        dst: *mut ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        len: usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Initialize all 32-bit words of buffer of memory to a specific value.\n\n This function will set a buffer of `dwords` Uint32 values, pointed to by\n `dst`, to the value specified in `val`.\n\n Unlike SDL_memset, this sets 32-bit values, not bytes, so it's not limited\n to a range of 0-255.\n\n \\param dst the destination memory region. Must not be NULL.\n \\param val the Uint32 value to set.\n \\param dwords the number of Uint32 values to set in `dst`.\n \\returns `dst`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_memset4(
        dst: *mut ::core::ffi::c_void,
        val: Uint32,
        dwords: usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Compare two buffers of memory.\n\n \\param s1 the first buffer to compare. NULL is not permitted!\n \\param s2 the second buffer to compare. NULL is not permitted!\n \\param len the number of bytes to compare between the buffers.\n \\returns less than zero if s1 is \"less than\" s2, greater than zero if s1 is\n          \"greater than\" s2, and zero if the buffers match exactly for `len`\n          bytes.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_memcmp(
        s1: *const ::core::ffi::c_void,
        s2: *const ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " This works exactly like wcslen() but doesn't require access to a C runtime.\n\n Counts the number of wchar_t values in `wstr`, excluding the null\n terminator.\n\n Like SDL_strlen only counts bytes and not codepoints in a UTF-8 string,\n this counts wchar_t values in a string, even if the string's encoding is of\n variable width, like UTF-16.\n\n Also be aware that wchar_t is different sizes on different platforms (4\n bytes on Linux, 2 on Windows, etc).\n\n \\param wstr The null-terminated wide string to read. Must not be NULL.\n \\returns the length (in wchar_t values, excluding the null terminator) of\n          `wstr`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_wcsnlen\n \\sa SDL_utf8strlen\n \\sa SDL_utf8strnlen"]
    pub fn SDL_wcslen(wstr: *const wchar_t) -> usize;
}
unsafe extern "C" {
    #[doc = " This works exactly like wcsnlen() but doesn't require access to a C\n runtime.\n\n Counts up to a maximum of `maxlen` wchar_t values in `wstr`, excluding the\n null terminator.\n\n Like SDL_strnlen only counts bytes and not codepoints in a UTF-8 string,\n this counts wchar_t values in a string, even if the string's encoding is of\n variable width, like UTF-16.\n\n Also be aware that wchar_t is different sizes on different platforms (4\n bytes on Linux, 2 on Windows, etc).\n\n Also, `maxlen` is a count of wide characters, not bytes!\n\n \\param wstr The null-terminated wide string to read. Must not be NULL.\n \\param maxlen The maximum amount of wide characters to count.\n \\returns the length (in wide characters, excluding the null terminator) of\n          `wstr` but never more than `maxlen`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_wcslen\n \\sa SDL_utf8strlen\n \\sa SDL_utf8strnlen"]
    pub fn SDL_wcsnlen(wstr: *const wchar_t, maxlen: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " Copy a wide string.\n\n This function copies `maxlen` - 1 wide characters from `src` to `dst`, then\n appends a null terminator.\n\n `src` and `dst` must not overlap.\n\n If `maxlen` is 0, no wide characters are copied and no null terminator is\n written.\n\n \\param dst The destination buffer. Must not be NULL, and must not overlap\n            with `src`.\n \\param src The null-terminated wide string to copy. Must not be NULL, and\n            must not overlap with `dst`.\n \\param maxlen The length (in wide characters) of the destination buffer.\n \\returns the length (in wide characters, excluding the null terminator) of\n          `src`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_wcslcat"]
    pub fn SDL_wcslcpy(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " Concatenate wide strings.\n\n This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters\n from `src` to the end of the wide string in `dst`, then appends a null\n terminator.\n\n `src` and `dst` must not overlap.\n\n If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is\n unmodified.\n\n \\param dst The destination buffer already containing the first\n            null-terminated wide string. Must not be NULL and must not\n            overlap with `src`.\n \\param src The second null-terminated wide string. Must not be NULL, and\n            must not overlap with `dst`.\n \\param maxlen The length (in wide characters) of the destination buffer.\n \\returns the length (in wide characters, excluding the null terminator) of\n          the string in `dst` plus the length of `src`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_wcslcpy"]
    pub fn SDL_wcslcat(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " Allocate a copy of a wide string.\n\n This allocates enough space for a null-terminated copy of `wstr`, using\n SDL_malloc, and then makes a copy of the string into this space.\n\n The returned string is owned by the caller, and should be passed to\n SDL_free when no longer needed.\n\n \\param wstr the string to copy.\n \\returns a pointer to the newly-allocated wide string.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_wcsdup(wstr: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Search a wide string for the first instance of a specific substring.\n\n The search ends once it finds the requested substring, or a null terminator\n byte to end the string.\n\n Note that this looks for strings of _wide characters_, not _codepoints_, so\n it's legal to search for malformed and incomplete UTF-16 sequences.\n\n \\param haystack the wide string to search. Must not be NULL.\n \\param needle the wide string to search for. Must not be NULL.\n \\returns a pointer to the first instance of `needle` in the string, or NULL\n          if not found.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_wcsstr(haystack: *const wchar_t, needle: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Search a wide string, up to n wide chars, for the first instance of a\n specific substring.\n\n The search ends once it finds the requested substring, or a null terminator\n value to end the string, or `maxlen` wide character have been examined. It\n is possible to use this function on a wide string without a null\n terminator.\n\n Note that this looks for strings of _wide characters_, not _codepoints_, so\n it's legal to search for malformed and incomplete UTF-16 sequences.\n\n \\param haystack the wide string to search. Must not be NULL.\n \\param needle the wide string to search for. Must not be NULL.\n \\param maxlen the maximum number of wide characters to search in\n               `haystack`.\n \\returns a pointer to the first instance of `needle` in the string, or NULL\n          if not found.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_wcsnstr(
        haystack: *const wchar_t,
        needle: *const wchar_t,
        maxlen: usize,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    #[doc = " Compare two null-terminated wide strings.\n\n This only compares wchar_t values until it hits a null-terminating\n character; it does not care if the string is well-formed UTF-16 (or UTF-32,\n depending on your platform's wchar_t size), or uses valid Unicode values.\n\n \\param str1 the first string to compare. NULL is not permitted!\n \\param str2 the second string to compare. NULL is not permitted!\n \\returns less than zero if str1 is \"less than\" str2, greater than zero if\n          str1 is \"greater than\" str2, and zero if the strings match\n          exactly.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_wcscmp(str1: *const wchar_t, str2: *const wchar_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two wide strings up to a number of wchar_t values.\n\n This only compares wchar_t values; it does not care if the string is\n well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),\n or uses valid Unicode values.\n\n Note that while this function is intended to be used with UTF-16 (or\n UTF-32, depending on your platform's definition of wchar_t), it is\n comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies\n a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16\n sequence, it will only compare a portion of the final character.\n\n `maxlen` specifies a maximum number of wchar_t to compare; if the strings\n match to this number of wide chars (or both have matched to a\n null-terminator character before this count), they will be considered\n equal.\n\n \\param str1 the first string to compare. NULL is not permitted!\n \\param str2 the second string to compare. NULL is not permitted!\n \\param maxlen the maximum number of wchar_t to compare.\n \\returns less than zero if str1 is \"less than\" str2, greater than zero if\n          str1 is \"greater than\" str2, and zero if the strings match\n          exactly.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_wcsncmp(
        str1: *const wchar_t,
        str2: *const wchar_t,
        maxlen: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two null-terminated wide strings, case-insensitively.\n\n This will work with Unicode strings, using a technique called\n \"case-folding\" to handle the vast majority of case-sensitive human\n languages regardless of system locale. It can deal with expanding values: a\n German Eszett character can compare against two ASCII 's' chars and be\n considered a match, for example. A notable exception: it does not handle\n the Turkish 'i' character; human language is complicated!\n\n Depending on your platform, \"wchar_t\" might be 2 bytes, and expected to be\n UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this\n handles Unicode, it expects the string to be well-formed and not a\n null-terminated string of arbitrary bytes. Characters that are not valid\n UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT\n CHARACTER), which is to say two strings of random bits may turn out to\n match if they convert to the same amount of replacement characters.\n\n \\param str1 the first string to compare. NULL is not permitted!\n \\param str2 the second string to compare. NULL is not permitted!\n \\returns less than zero if str1 is \"less than\" str2, greater than zero if\n          str1 is \"greater than\" str2, and zero if the strings match\n          exactly.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_wcscasecmp(str1: *const wchar_t, str2: *const wchar_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two wide strings, case-insensitively, up to a number of wchar_t.\n\n This will work with Unicode strings, using a technique called\n \"case-folding\" to handle the vast majority of case-sensitive human\n languages regardless of system locale. It can deal with expanding values: a\n German Eszett character can compare against two ASCII 's' chars and be\n considered a match, for example. A notable exception: it does not handle\n the Turkish 'i' character; human language is complicated!\n\n Depending on your platform, \"wchar_t\" might be 2 bytes, and expected to be\n UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this\n handles Unicode, it expects the string to be well-formed and not a\n null-terminated string of arbitrary bytes. Characters that are not valid\n UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT\n CHARACTER), which is to say two strings of random bits may turn out to\n match if they convert to the same amount of replacement characters.\n\n Note that while this function might deal with variable-sized characters,\n `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a\n multi-byte UTF-16 sequence, it may convert a portion of the final character\n to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not\n to overflow a buffer.\n\n `maxlen` specifies a maximum number of wchar_t values to compare; if the\n strings match to this number of wchar_t (or both have matched to a\n null-terminator character before this number of bytes), they will be\n considered equal.\n\n \\param str1 the first string to compare. NULL is not permitted!\n \\param str2 the second string to compare. NULL is not permitted!\n \\param maxlen the maximum number of wchar_t values to compare.\n \\returns less than zero if str1 is \"less than\" str2, greater than zero if\n          str1 is \"greater than\" str2, and zero if the strings match\n          exactly.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_wcsncasecmp(
        str1: *const wchar_t,
        str2: *const wchar_t,
        maxlen: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Parse a `long` from a wide string.\n\n If `str` starts with whitespace, then those whitespace characters are\n skipped before attempting to parse the number.\n\n If the parsed number does not fit inside a `long`, the result is clamped to\n the minimum and maximum representable `long` values.\n\n \\param str The null-terminated wide string to read. Must not be NULL.\n \\param endp If not NULL, the address of the first invalid wide character\n             (i.e. the next character after the parsed number) will be\n             written to this pointer.\n \\param base The base of the integer to read. Supported values are 0 and 2\n             to 36 inclusive. If 0, the base will be inferred from the\n             number's prefix (0x for hexadecimal, 0 for octal, decimal\n             otherwise).\n \\returns the parsed `long`, or 0 if no number could be parsed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_strtol"]
    pub fn SDL_wcstol(
        str_: *const wchar_t,
        endp: *mut *mut wchar_t,
        base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    #[doc = " This works exactly like strlen() but doesn't require access to a C runtime.\n\n Counts the bytes in `str`, excluding the null terminator.\n\n If you need the length of a UTF-8 string, consider using SDL_utf8strlen().\n\n \\param str The null-terminated string to read. Must not be NULL.\n \\returns the length (in bytes, excluding the null terminator) of `src`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_strnlen\n \\sa SDL_utf8strlen\n \\sa SDL_utf8strnlen"]
    pub fn SDL_strlen(str_: *const ::core::ffi::c_char) -> usize;
}
unsafe extern "C" {
    #[doc = " This works exactly like strnlen() but doesn't require access to a C\n runtime.\n\n Counts up to a maximum of `maxlen` bytes in `str`, excluding the null\n terminator.\n\n If you need the length of a UTF-8 string, consider using SDL_utf8strnlen().\n\n \\param str The null-terminated string to read. Must not be NULL.\n \\param maxlen The maximum amount of bytes to count.\n \\returns the length (in bytes, excluding the null terminator) of `src` but\n          never more than `maxlen`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_strlen\n \\sa SDL_utf8strlen\n \\sa SDL_utf8strnlen"]
    pub fn SDL_strnlen(str_: *const ::core::ffi::c_char, maxlen: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " Copy a string.\n\n This function copies up to `maxlen` - 1 characters from `src` to `dst`,\n then appends a null terminator.\n\n If `maxlen` is 0, no characters are copied and no null terminator is\n written.\n\n If you want to copy an UTF-8 string but need to ensure that multi-byte\n sequences are not truncated, consider using SDL_utf8strlcpy().\n\n \\param dst The destination buffer. Must not be NULL, and must not overlap\n            with `src`.\n \\param src The null-terminated string to copy. Must not be NULL, and must\n            not overlap with `dst`.\n \\param maxlen The length (in characters) of the destination buffer.\n \\returns the length (in characters, excluding the null terminator) of\n          `src`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_strlcat\n \\sa SDL_utf8strlcpy"]
    pub fn SDL_strlcpy(
        dst: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        maxlen: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Copy an UTF-8 string.\n\n This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while\n also ensuring that the string written to `dst` does not end in a truncated\n multi-byte sequence. Finally, it appends a null terminator.\n\n `src` and `dst` must not overlap.\n\n Note that unlike SDL_strlcpy(), this function returns the number of bytes\n written, not the length of `src`.\n\n \\param dst The destination buffer. Must not be NULL, and must not overlap\n            with `src`.\n \\param src The null-terminated UTF-8 string to copy. Must not be NULL, and\n            must not overlap with `dst`.\n \\param dst_bytes The length (in bytes) of the destination buffer. Must not\n                  be 0.\n \\returns the number of bytes written, excluding the null terminator.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_strlcpy"]
    pub fn SDL_utf8strlcpy(
        dst: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        dst_bytes: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Concatenate strings.\n\n This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from\n `src` to the end of the string in `dst`, then appends a null terminator.\n\n `src` and `dst` must not overlap.\n\n If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is\n unmodified.\n\n \\param dst The destination buffer already containing the first\n            null-terminated string. Must not be NULL and must not overlap\n            with `src`.\n \\param src The second null-terminated string. Must not be NULL, and must\n            not overlap with `dst`.\n \\param maxlen The length (in characters) of the destination buffer.\n \\returns the length (in characters, excluding the null terminator) of the\n          string in `dst` plus the length of `src`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_strlcpy"]
    pub fn SDL_strlcat(
        dst: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        maxlen: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Allocate a copy of a string.\n\n This allocates enough space for a null-terminated copy of `str`, using\n SDL_malloc, and then makes a copy of the string into this space.\n\n The returned string is owned by the caller, and should be passed to\n SDL_free when no longer needed.\n\n \\param str the string to copy.\n \\returns a pointer to the newly-allocated string.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strdup(str_: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Allocate a copy of a string, up to n characters.\n\n This allocates enough space for a null-terminated copy of `str`, up to\n `maxlen` bytes, using SDL_malloc, and then makes a copy of the string into\n this space.\n\n If the string is longer than `maxlen` bytes, the returned string will be\n `maxlen` bytes long, plus a null-terminator character that isn't included\n in the count.\n\n The returned string is owned by the caller, and should be passed to\n SDL_free when no longer needed.\n\n \\param str the string to copy.\n \\param maxlen the maximum length of the copied string, not counting the\n               null-terminator character.\n \\returns a pointer to the newly-allocated string.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strndup(str_: *const ::core::ffi::c_char, maxlen: usize)
        -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Reverse a string's contents.\n\n This reverses a null-terminated string in-place. Only the content of the\n string is reversed; the null-terminator character remains at the end of the\n reversed string.\n\n **WARNING**: This function reverses the _bytes_ of the string, not the\n codepoints. If `str` is a UTF-8 string with Unicode codepoints > 127, this\n will ruin the string data. You should only use this function on strings\n that are completely comprised of low ASCII characters.\n\n \\param str the string to reverse.\n \\returns `str`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strrev(str_: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Convert a string to uppercase.\n\n **WARNING**: Regardless of system locale, this will only convert ASCII\n values 'A' through 'Z' to uppercase.\n\n This function operates on a null-terminated string of bytes--even if it is\n malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their\n uppercase equivalents in-place, returning the original `str` pointer.\n\n \\param str the string to convert in-place. Can not be NULL.\n \\returns the `str` pointer passed into this function.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_strlwr"]
    pub fn SDL_strupr(str_: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Convert a string to lowercase.\n\n **WARNING**: Regardless of system locale, this will only convert ASCII\n values 'A' through 'Z' to lowercase.\n\n This function operates on a null-terminated string of bytes--even if it is\n malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their\n lowercase equivalents in-place, returning the original `str` pointer.\n\n \\param str the string to convert in-place. Can not be NULL.\n \\returns the `str` pointer passed into this function.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_strupr"]
    pub fn SDL_strlwr(str_: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Search a string for the first instance of a specific byte.\n\n The search ends once it finds the requested byte value, or a null\n terminator byte to end the string.\n\n Note that this looks for _bytes_, not _characters_, so you cannot match\n against a Unicode codepoint > 255, regardless of character encoding.\n\n \\param str the string to search. Must not be NULL.\n \\param c the byte value to search for.\n \\returns a pointer to the first instance of `c` in the string, or NULL if\n          not found.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strchr(
        str_: *const ::core::ffi::c_char,
        c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Search a string for the last instance of a specific byte.\n\n The search must go until it finds a null terminator byte to end the string.\n\n Note that this looks for _bytes_, not _characters_, so you cannot match\n against a Unicode codepoint > 255, regardless of character encoding.\n\n \\param str the string to search. Must not be NULL.\n \\param c the byte value to search for.\n \\returns a pointer to the last instance of `c` in the string, or NULL if\n          not found.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strrchr(
        str_: *const ::core::ffi::c_char,
        c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Search a string for the first instance of a specific substring.\n\n The search ends once it finds the requested substring, or a null terminator\n byte to end the string.\n\n Note that this looks for strings of _bytes_, not _characters_, so it's\n legal to search for malformed and incomplete UTF-8 sequences.\n\n \\param haystack the string to search. Must not be NULL.\n \\param needle the string to search for. Must not be NULL.\n \\returns a pointer to the first instance of `needle` in the string, or NULL\n          if not found.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strstr(
        haystack: *const ::core::ffi::c_char,
        needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Search a string, up to n bytes, for the first instance of a specific\n substring.\n\n The search ends once it finds the requested substring, or a null terminator\n byte to end the string, or `maxlen` bytes have been examined. It is\n possible to use this function on a string without a null terminator.\n\n Note that this looks for strings of _bytes_, not _characters_, so it's\n legal to search for malformed and incomplete UTF-8 sequences.\n\n \\param haystack the string to search. Must not be NULL.\n \\param needle the string to search for. Must not be NULL.\n \\param maxlen the maximum number of bytes to search in `haystack`.\n \\returns a pointer to the first instance of `needle` in the string, or NULL\n          if not found.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strnstr(
        haystack: *const ::core::ffi::c_char,
        needle: *const ::core::ffi::c_char,
        maxlen: usize,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Search a UTF-8 string for the first instance of a specific substring,\n case-insensitively.\n\n This will work with Unicode strings, using a technique called\n \"case-folding\" to handle the vast majority of case-sensitive human\n languages regardless of system locale. It can deal with expanding values: a\n German Eszett character can compare against two ASCII 's' chars and be\n considered a match, for example. A notable exception: it does not handle\n the Turkish 'i' character; human language is complicated!\n\n Since this handles Unicode, it expects the strings to be well-formed UTF-8\n and not a null-terminated string of arbitrary bytes. Bytes that are not\n valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\n CHARACTER), which is to say two strings of random bits may turn out to\n match if they convert to the same amount of replacement characters.\n\n \\param haystack the string to search. Must not be NULL.\n \\param needle the string to search for. Must not be NULL.\n \\returns a pointer to the first instance of `needle` in the string, or NULL\n          if not found.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strcasestr(
        haystack: *const ::core::ffi::c_char,
        needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " This works exactly like strtok_r() but doesn't require access to a C\n runtime.\n\n Break a string up into a series of tokens.\n\n To start tokenizing a new string, `str` should be the non-NULL address of\n the string to start tokenizing. Future calls to get the next token from the\n same string should specify a NULL.\n\n Note that this function will overwrite pieces of `str` with null chars to\n split it into tokens. This function cannot be used with const/read-only\n strings!\n\n `saveptr` just needs to point to a `char *` that can be overwritten; SDL\n will use this to save tokenizing state between calls. It is initialized if\n `str` is non-NULL, and used to resume tokenizing when `str` is NULL.\n\n \\param str the string to tokenize, or NULL to continue tokenizing.\n \\param delim the delimiter string that separates tokens.\n \\param saveptr pointer to a char *, used for ongoing state.\n \\returns A pointer to the next token, or NULL if no tokens remain.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strtok_r(
        str_: *mut ::core::ffi::c_char,
        delim: *const ::core::ffi::c_char,
        saveptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Count the number of codepoints in a UTF-8 string.\n\n Counts the _codepoints_, not _bytes_, in `str`, excluding the null\n terminator.\n\n If you need to count the bytes in a string instead, consider using\n SDL_strlen().\n\n Since this handles Unicode, it expects the strings to be well-formed UTF-8\n and not a null-terminated string of arbitrary bytes. Bytes that are not\n valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\n CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the\n count by several replacement characters.\n\n \\param str The null-terminated UTF-8 string to read. Must not be NULL.\n \\returns The length (in codepoints, excluding the null terminator) of\n          `src`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_utf8strnlen\n \\sa SDL_strlen"]
    pub fn SDL_utf8strlen(str_: *const ::core::ffi::c_char) -> usize;
}
unsafe extern "C" {
    #[doc = " Count the number of codepoints in a UTF-8 string, up to n bytes.\n\n Counts the _codepoints_, not _bytes_, in `str`, excluding the null\n terminator.\n\n If you need to count the bytes in a string instead, consider using\n SDL_strnlen().\n\n The counting stops at `bytes` bytes (not codepoints!). This seems\n counterintuitive, but makes it easy to express the total size of the\n string's buffer.\n\n Since this handles Unicode, it expects the strings to be well-formed UTF-8\n and not a null-terminated string of arbitrary bytes. Bytes that are not\n valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\n CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the\n count by several replacement characters.\n\n \\param str The null-terminated UTF-8 string to read. Must not be NULL.\n \\param bytes The maximum amount of bytes to count.\n \\returns The length (in codepoints, excluding the null terminator) of `src`\n          but never more than `maxlen`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_utf8strlen\n \\sa SDL_strnlen"]
    pub fn SDL_utf8strnlen(str_: *const ::core::ffi::c_char, bytes: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " Convert an integer into a string.\n\n This requires a radix to specified for string format. Specifying 10\n produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\n to 36.\n\n Note that this function will overflow a buffer if `str` is not large enough\n to hold the output! It may be safer to use SDL_snprintf to clamp output, or\n SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\n much more space than you expect to use (and don't forget possible negative\n signs, null terminator bytes, etc).\n\n \\param value the integer to convert.\n \\param str the buffer to write the string into.\n \\param radix the radix to use for string generation.\n \\returns `str`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_uitoa\n \\sa SDL_ltoa\n \\sa SDL_lltoa"]
    pub fn SDL_itoa(
        value: ::core::ffi::c_int,
        str_: *mut ::core::ffi::c_char,
        radix: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Convert an unsigned integer into a string.\n\n This requires a radix to specified for string format. Specifying 10\n produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\n to 36.\n\n Note that this function will overflow a buffer if `str` is not large enough\n to hold the output! It may be safer to use SDL_snprintf to clamp output, or\n SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\n much more space than you expect to use (and don't forget null terminator\n bytes, etc).\n\n \\param value the unsigned integer to convert.\n \\param str the buffer to write the string into.\n \\param radix the radix to use for string generation.\n \\returns `str`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_itoa\n \\sa SDL_ultoa\n \\sa SDL_ulltoa"]
    pub fn SDL_uitoa(
        value: ::core::ffi::c_uint,
        str_: *mut ::core::ffi::c_char,
        radix: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Convert a long integer into a string.\n\n This requires a radix to specified for string format. Specifying 10\n produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\n to 36.\n\n Note that this function will overflow a buffer if `str` is not large enough\n to hold the output! It may be safer to use SDL_snprintf to clamp output, or\n SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\n much more space than you expect to use (and don't forget possible negative\n signs, null terminator bytes, etc).\n\n \\param value the long integer to convert.\n \\param str the buffer to write the string into.\n \\param radix the radix to use for string generation.\n \\returns `str`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ultoa\n \\sa SDL_itoa\n \\sa SDL_lltoa"]
    pub fn SDL_ltoa(
        value: ::core::ffi::c_long,
        str_: *mut ::core::ffi::c_char,
        radix: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Convert an unsigned long integer into a string.\n\n This requires a radix to specified for string format. Specifying 10\n produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\n to 36.\n\n Note that this function will overflow a buffer if `str` is not large enough\n to hold the output! It may be safer to use SDL_snprintf to clamp output, or\n SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\n much more space than you expect to use (and don't forget null terminator\n bytes, etc).\n\n \\param value the unsigned long integer to convert.\n \\param str the buffer to write the string into.\n \\param radix the radix to use for string generation.\n \\returns `str`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ltoa\n \\sa SDL_uitoa\n \\sa SDL_ulltoa"]
    pub fn SDL_ultoa(
        value: ::core::ffi::c_ulong,
        str_: *mut ::core::ffi::c_char,
        radix: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Convert a long long integer into a string.\n\n This requires a radix to specified for string format. Specifying 10\n produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\n to 36.\n\n Note that this function will overflow a buffer if `str` is not large enough\n to hold the output! It may be safer to use SDL_snprintf to clamp output, or\n SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\n much more space than you expect to use (and don't forget possible negative\n signs, null terminator bytes, etc).\n\n \\param value the long long integer to convert.\n \\param str the buffer to write the string into.\n \\param radix the radix to use for string generation.\n \\returns `str`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ulltoa\n \\sa SDL_itoa\n \\sa SDL_ltoa"]
    pub fn SDL_lltoa(
        value: ::core::ffi::c_longlong,
        str_: *mut ::core::ffi::c_char,
        radix: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Convert an unsigned long long integer into a string.\n\n This requires a radix to specified for string format. Specifying 10\n produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2\n to 36.\n\n Note that this function will overflow a buffer if `str` is not large enough\n to hold the output! It may be safer to use SDL_snprintf to clamp output, or\n SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate\n much more space than you expect to use (and don't forget null terminator\n bytes, etc).\n\n \\param value the unsigned long long integer to convert.\n \\param str the buffer to write the string into.\n \\param radix the radix to use for string generation.\n \\returns `str`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_lltoa\n \\sa SDL_uitoa\n \\sa SDL_ultoa"]
    pub fn SDL_ulltoa(
        value: ::core::ffi::c_ulonglong,
        str_: *mut ::core::ffi::c_char,
        radix: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Parse an `int` from a string.\n\n The result of calling `SDL_atoi(str)` is equivalent to\n `(int)SDL_strtol(str, NULL, 10)`.\n\n \\param str The null-terminated string to read. Must not be NULL.\n \\returns the parsed `int`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_atof\n \\sa SDL_strtol\n \\sa SDL_strtoul\n \\sa SDL_strtoll\n \\sa SDL_strtoull\n \\sa SDL_strtod\n \\sa SDL_itoa"]
    pub fn SDL_atoi(str_: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Parse a `double` from a string.\n\n The result of calling `SDL_atof(str)` is equivalent to `SDL_strtod(str,\n NULL)`.\n\n \\param str The null-terminated string to read. Must not be NULL.\n \\returns the parsed `double`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_atoi\n \\sa SDL_strtol\n \\sa SDL_strtoul\n \\sa SDL_strtoll\n \\sa SDL_strtoull\n \\sa SDL_strtod"]
    pub fn SDL_atof(str_: *const ::core::ffi::c_char) -> f64;
}
unsafe extern "C" {
    #[doc = " Parse a `long` from a string.\n\n If `str` starts with whitespace, then those whitespace characters are\n skipped before attempting to parse the number.\n\n If the parsed number does not fit inside a `long`, the result is clamped to\n the minimum and maximum representable `long` values.\n\n \\param str The null-terminated string to read. Must not be NULL.\n \\param endp If not NULL, the address of the first invalid character (i.e.\n             the next character after the parsed number) will be written to\n             this pointer.\n \\param base The base of the integer to read. Supported values are 0 and 2\n             to 36 inclusive. If 0, the base will be inferred from the\n             number's prefix (0x for hexadecimal, 0 for octal, decimal\n             otherwise).\n \\returns the parsed `long`, or 0 if no number could be parsed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_atoi\n \\sa SDL_atof\n \\sa SDL_strtoul\n \\sa SDL_strtoll\n \\sa SDL_strtoull\n \\sa SDL_strtod\n \\sa SDL_ltoa\n \\sa SDL_wcstol"]
    pub fn SDL_strtol(
        str_: *const ::core::ffi::c_char,
        endp: *mut *mut ::core::ffi::c_char,
        base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    #[doc = " Parse an `unsigned long` from a string.\n\n If `str` starts with whitespace, then those whitespace characters are\n skipped before attempting to parse the number.\n\n If the parsed number does not fit inside an `unsigned long`, the result is\n clamped to the maximum representable `unsigned long` value.\n\n \\param str The null-terminated string to read. Must not be NULL.\n \\param endp If not NULL, the address of the first invalid character (i.e.\n             the next character after the parsed number) will be written to\n             this pointer.\n \\param base The base of the integer to read. Supported values are 0 and 2\n             to 36 inclusive. If 0, the base will be inferred from the\n             number's prefix (0x for hexadecimal, 0 for octal, decimal\n             otherwise).\n \\returns the parsed `unsigned long`, or 0 if no number could be parsed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_atoi\n \\sa SDL_atof\n \\sa SDL_strtol\n \\sa SDL_strtoll\n \\sa SDL_strtoull\n \\sa SDL_strtod\n \\sa SDL_ultoa"]
    pub fn SDL_strtoul(
        str_: *const ::core::ffi::c_char,
        endp: *mut *mut ::core::ffi::c_char,
        base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    #[doc = " Parse a `long long` from a string.\n\n If `str` starts with whitespace, then those whitespace characters are\n skipped before attempting to parse the number.\n\n If the parsed number does not fit inside a `long long`, the result is\n clamped to the minimum and maximum representable `long long` values.\n\n \\param str The null-terminated string to read. Must not be NULL.\n \\param endp If not NULL, the address of the first invalid character (i.e.\n             the next character after the parsed number) will be written to\n             this pointer.\n \\param base The base of the integer to read. Supported values are 0 and 2\n             to 36 inclusive. If 0, the base will be inferred from the\n             number's prefix (0x for hexadecimal, 0 for octal, decimal\n             otherwise).\n \\returns the parsed `long long`, or 0 if no number could be parsed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_atoi\n \\sa SDL_atof\n \\sa SDL_strtol\n \\sa SDL_strtoul\n \\sa SDL_strtoull\n \\sa SDL_strtod\n \\sa SDL_lltoa"]
    pub fn SDL_strtoll(
        str_: *const ::core::ffi::c_char,
        endp: *mut *mut ::core::ffi::c_char,
        base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    #[doc = " Parse an `unsigned long long` from a string.\n\n If `str` starts with whitespace, then those whitespace characters are\n skipped before attempting to parse the number.\n\n If the parsed number does not fit inside an `unsigned long long`, the\n result is clamped to the maximum representable `unsigned long long` value.\n\n \\param str The null-terminated string to read. Must not be NULL.\n \\param endp If not NULL, the address of the first invalid character (i.e.\n             the next character after the parsed number) will be written to\n             this pointer.\n \\param base The base of the integer to read. Supported values are 0 and 2\n             to 36 inclusive. If 0, the base will be inferred from the\n             number's prefix (0x for hexadecimal, 0 for octal, decimal\n             otherwise).\n \\returns the parsed `unsigned long long`, or 0 if no number could be\n          parsed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_atoi\n \\sa SDL_atof\n \\sa SDL_strtol\n \\sa SDL_strtoll\n \\sa SDL_strtoul\n \\sa SDL_strtod\n \\sa SDL_ulltoa"]
    pub fn SDL_strtoull(
        str_: *const ::core::ffi::c_char,
        endp: *mut *mut ::core::ffi::c_char,
        base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
unsafe extern "C" {
    #[doc = " Parse a `double` from a string.\n\n This function makes fewer guarantees than the C runtime `strtod`:\n\n - Only decimal notation is guaranteed to be supported. The handling of\n   scientific and hexadecimal notation is unspecified.\n - Whether or not INF and NAN can be parsed is unspecified.\n - The precision of the result is unspecified.\n\n \\param str the null-terminated string to read. Must not be NULL.\n \\param endp if not NULL, the address of the first invalid character (i.e.\n             the next character after the parsed number) will be written to\n             this pointer.\n \\returns the parsed `double`, or 0 if no number could be parsed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_atoi\n \\sa SDL_atof\n \\sa SDL_strtol\n \\sa SDL_strtoll\n \\sa SDL_strtoul\n \\sa SDL_strtoull"]
    pub fn SDL_strtod(str_: *const ::core::ffi::c_char, endp: *mut *mut ::core::ffi::c_char)
        -> f64;
}
unsafe extern "C" {
    #[doc = " Compare two null-terminated UTF-8 strings.\n\n Due to the nature of UTF-8 encoding, this will work with Unicode strings,\n since effectively this function just compares bytes until it hits a\n null-terminating character. Also due to the nature of UTF-8, this can be\n used with SDL_qsort() to put strings in (roughly) alphabetical order.\n\n \\param str1 the first string to compare. NULL is not permitted!\n \\param str2 the second string to compare. NULL is not permitted!\n \\returns less than zero if str1 is \"less than\" str2, greater than zero if\n          str1 is \"greater than\" str2, and zero if the strings match\n          exactly.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strcmp(
        str1: *const ::core::ffi::c_char,
        str2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two UTF-8 strings up to a number of bytes.\n\n Due to the nature of UTF-8 encoding, this will work with Unicode strings,\n since effectively this function just compares bytes until it hits a\n null-terminating character. Also due to the nature of UTF-8, this can be\n used with SDL_qsort() to put strings in (roughly) alphabetical order.\n\n Note that while this function is intended to be used with UTF-8, it is\n doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the\n limit lands in the middle of a multi-byte UTF-8 sequence, it will only\n compare a portion of the final character.\n\n `maxlen` specifies a maximum number of bytes to compare; if the strings\n match to this number of bytes (or both have matched to a null-terminator\n character before this number of bytes), they will be considered equal.\n\n \\param str1 the first string to compare. NULL is not permitted!\n \\param str2 the second string to compare. NULL is not permitted!\n \\param maxlen the maximum number of _bytes_ to compare.\n \\returns less than zero if str1 is \"less than\" str2, greater than zero if\n          str1 is \"greater than\" str2, and zero if the strings match\n          exactly.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strncmp(
        str1: *const ::core::ffi::c_char,
        str2: *const ::core::ffi::c_char,
        maxlen: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two null-terminated UTF-8 strings, case-insensitively.\n\n This will work with Unicode strings, using a technique called\n \"case-folding\" to handle the vast majority of case-sensitive human\n languages regardless of system locale. It can deal with expanding values: a\n German Eszett character can compare against two ASCII 's' chars and be\n considered a match, for example. A notable exception: it does not handle\n the Turkish 'i' character; human language is complicated!\n\n Since this handles Unicode, it expects the string to be well-formed UTF-8\n and not a null-terminated string of arbitrary bytes. Bytes that are not\n valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\n CHARACTER), which is to say two strings of random bits may turn out to\n match if they convert to the same amount of replacement characters.\n\n \\param str1 the first string to compare. NULL is not permitted!\n \\param str2 the second string to compare. NULL is not permitted!\n \\returns less than zero if str1 is \"less than\" str2, greater than zero if\n          str1 is \"greater than\" str2, and zero if the strings match\n          exactly.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strcasecmp(
        str1: *const ::core::ffi::c_char,
        str2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two UTF-8 strings, case-insensitively, up to a number of bytes.\n\n This will work with Unicode strings, using a technique called\n \"case-folding\" to handle the vast majority of case-sensitive human\n languages regardless of system locale. It can deal with expanding values: a\n German Eszett character can compare against two ASCII 's' chars and be\n considered a match, for example. A notable exception: it does not handle\n the Turkish 'i' character; human language is complicated!\n\n Since this handles Unicode, it expects the string to be well-formed UTF-8\n and not a null-terminated string of arbitrary bytes. Bytes that are not\n valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT\n CHARACTER), which is to say two strings of random bits may turn out to\n match if they convert to the same amount of replacement characters.\n\n Note that while this function is intended to be used with UTF-8, `maxlen`\n specifies a _byte_ limit! If the limit lands in the middle of a multi-byte\n UTF-8 sequence, it may convert a portion of the final character to one or\n more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow\n a buffer.\n\n `maxlen` specifies a maximum number of bytes to compare; if the strings\n match to this number of bytes (or both have matched to a null-terminator\n character before this number of bytes), they will be considered equal.\n\n \\param str1 the first string to compare. NULL is not permitted!\n \\param str2 the second string to compare. NULL is not permitted!\n \\param maxlen the maximum number of bytes to compare.\n \\returns less than zero if str1 is \"less than\" str2, greater than zero if\n          str1 is \"greater than\" str2, and zero if the strings match\n          exactly.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strncasecmp(
        str1: *const ::core::ffi::c_char,
        str2: *const ::core::ffi::c_char,
        maxlen: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Searches a string for the first occurence of any character contained in a\n breakset, and returns a pointer from the string to that character.\n\n \\param str The null-terminated string to be searched. Must not be NULL, and\n            must not overlap with `breakset`.\n \\param breakset A null-terminated string containing the list of characters\n                 to look for. Must not be NULL, and must not overlap with\n                 `str`.\n \\returns A pointer to the location, in str, of the first occurence of a\n          character present in the breakset, or NULL if none is found.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_strpbrk(
        str_: *const ::core::ffi::c_char,
        breakset: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Decode a UTF-8 string, one Unicode codepoint at a time.\n\n This will return the first Unicode codepoint in the UTF-8 encoded string in\n `*pstr`, and then advance `*pstr` past any consumed bytes before returning.\n\n It will not access more than `*pslen` bytes from the string. `*pslen` will\n be adjusted, as well, subtracting the number of bytes consumed.\n\n `pslen` is allowed to be NULL, in which case the string _must_ be\n NULL-terminated, as the function will blindly read until it sees the NULL\n char.\n\n if `*pslen` is zero, it assumes the end of string is reached and returns a\n zero codepoint regardless of the contents of the string buffer.\n\n If the resulting codepoint is zero (a NULL terminator), or `*pslen` is\n zero, it will not advance `*pstr` or `*pslen` at all.\n\n Generally this function is called in a loop until it returns zero,\n adjusting its parameters each iteration.\n\n If an invalid UTF-8 sequence is encountered, this function returns\n SDL_INVALID_UNICODE_CODEPOINT and advances the string/length by one byte\n (which is to say, a multibyte sequence might produce several\n SDL_INVALID_UNICODE_CODEPOINT returns before it syncs to the next valid\n UTF-8 sequence).\n\n Several things can generate invalid UTF-8 sequences, including overlong\n encodings, the use of UTF-16 surrogate values, and truncated data. Please\n refer to\n [RFC3629](https://www.ietf.org/rfc/rfc3629.txt)\n for details.\n\n \\param pstr a pointer to a UTF-8 string pointer to be read and adjusted.\n \\param pslen a pointer to the number of bytes in the string, to be read and\n              adjusted. NULL is allowed.\n \\returns the first Unicode codepoint in the string.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_StepUTF8(pstr: *mut *const ::core::ffi::c_char, pslen: *mut usize) -> Uint32;
}
unsafe extern "C" {
    #[doc = " Decode a UTF-8 string in reverse, one Unicode codepoint at a time.\n\n This will go to the start of the previous Unicode codepoint in the string,\n move `*pstr` to that location and return that codepoint.\n\n If `*pstr` is already at the start of the string), it will not advance\n `*pstr` at all.\n\n Generally this function is called in a loop until it returns zero,\n adjusting its parameter each iteration.\n\n If an invalid UTF-8 sequence is encountered, this function returns\n SDL_INVALID_UNICODE_CODEPOINT.\n\n Several things can generate invalid UTF-8 sequences, including overlong\n encodings, the use of UTF-16 surrogate values, and truncated data. Please\n refer to\n [RFC3629](https://www.ietf.org/rfc/rfc3629.txt)\n for details.\n\n \\param start a pointer to the beginning of the UTF-8 string.\n \\param pstr a pointer to a UTF-8 string pointer to be read and adjusted.\n \\returns the previous Unicode codepoint in the string.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_StepBackUTF8(
        start: *const ::core::ffi::c_char,
        pstr: *mut *const ::core::ffi::c_char,
    ) -> Uint32;
}
unsafe extern "C" {
    #[doc = " Convert a single Unicode codepoint to UTF-8.\n\n The buffer pointed to by `dst` must be at least 4 bytes long, as this\n function may generate between 1 and 4 bytes of output.\n\n This function returns the first byte _after_ the newly-written UTF-8\n sequence, which is useful for encoding multiple codepoints in a loop, or\n knowing where to write a NULL-terminator character to end the string (in\n either case, plan to have a buffer of _more_ than 4 bytes!).\n\n If `codepoint` is an invalid value (outside the Unicode range, or a UTF-16\n surrogate value, etc), this will use U+FFFD (REPLACEMENT CHARACTER) for the\n codepoint instead, and not set an error.\n\n If `dst` is NULL, this returns NULL immediately without writing to the\n pointer and without setting an error.\n\n \\param codepoint a Unicode codepoint to convert to UTF-8.\n \\param dst the location to write the encoded UTF-8. Must point to at least\n            4 bytes!\n \\returns the first byte past the newly-written UTF-8 sequence.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_UCS4ToUTF8(
        codepoint: Uint32,
        dst: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " This works exactly like sscanf() but doesn't require access to a C runtime.\n\n Scan a string, matching a format string, converting each '%' item and\n storing it to pointers provided through variable arguments.\n\n \\param text the string to scan. Must not be NULL.\n \\param fmt a printf-style format string. Must not be NULL.\n \\param ... a list of pointers to values to be filled in with scanned items.\n \\returns the number of items that matched the format string.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_sscanf(
        text: *const ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " This works exactly like vsscanf() but doesn't require access to a C\n runtime.\n\n Functions identically to SDL_sscanf(), except it takes a `va_list` instead\n of using `...` variable arguments.\n\n \\param text the string to scan. Must not be NULL.\n \\param fmt a printf-style format string. Must not be NULL.\n \\param ap a `va_list` of pointers to values to be filled in with scanned\n           items.\n \\returns the number of items that matched the format string.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_vsscanf(
        text: *const ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " This works exactly like snprintf() but doesn't require access to a C\n runtime.\n\n Format a string of up to `maxlen`-1 bytes, converting each '%' item with\n values provided through variable arguments.\n\n While some C runtimes differ on how to deal with too-large strings, this\n function null-terminates the output, by treating the null-terminator as\n part of the `maxlen` count. Note that if `maxlen` is zero, however, no\n bytes will be written at all.\n\n This function returns the number of _bytes_ (not _characters_) that should\n be written, excluding the null-terminator character. If this returns a\n number >= `maxlen`, it means the output string was truncated. A negative\n return value means an error occurred.\n\n Referencing the output string's pointer with a format item is undefined\n behavior.\n\n \\param text the buffer to write the string into. Must not be NULL.\n \\param maxlen the maximum bytes to write, including the null-terminator.\n \\param fmt a printf-style format string. Must not be NULL.\n \\param ... a list of values to be used with the format string.\n \\returns the number of bytes that should be written, not counting the\n          null-terminator char, or a negative value on error.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_snprintf(
        text: *mut ::core::ffi::c_char,
        maxlen: usize,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " This works exactly like swprintf() but doesn't require access to a C\n runtime.\n\n Format a wide string of up to `maxlen`-1 wchar_t values, converting each\n '%' item with values provided through variable arguments.\n\n While some C runtimes differ on how to deal with too-large strings, this\n function null-terminates the output, by treating the null-terminator as\n part of the `maxlen` count. Note that if `maxlen` is zero, however, no wide\n characters will be written at all.\n\n This function returns the number of _wide characters_ (not _codepoints_)\n that should be written, excluding the null-terminator character. If this\n returns a number >= `maxlen`, it means the output string was truncated. A\n negative return value means an error occurred.\n\n Referencing the output string's pointer with a format item is undefined\n behavior.\n\n \\param text the buffer to write the wide string into. Must not be NULL.\n \\param maxlen the maximum wchar_t values to write, including the\n               null-terminator.\n \\param fmt a printf-style format string. Must not be NULL.\n \\param ... a list of values to be used with the format string.\n \\returns the number of wide characters that should be written, not counting\n          the null-terminator char, or a negative value on error.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_swprintf(
        text: *mut wchar_t,
        maxlen: usize,
        fmt: *const wchar_t,
        ...
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " This works exactly like vsnprintf() but doesn't require access to a C\n runtime.\n\n Functions identically to SDL_snprintf(), except it takes a `va_list`\n instead of using `...` variable arguments.\n\n \\param text the buffer to write the string into. Must not be NULL.\n \\param maxlen the maximum bytes to write, including the null-terminator.\n \\param fmt a printf-style format string. Must not be NULL.\n \\param ap a `va_list` values to be used with the format string.\n \\returns the number of bytes that should be written, not counting the\n          null-terminator char, or a negative value on error.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_vsnprintf(
        text: *mut ::core::ffi::c_char,
        maxlen: usize,
        fmt: *const ::core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " This works exactly like vswprintf() but doesn't require access to a C\n runtime.\n\n Functions identically to SDL_swprintf(), except it takes a `va_list`\n instead of using `...` variable arguments.\n\n \\param text the buffer to write the string into. Must not be NULL.\n \\param maxlen the maximum wide characters to write, including the\n               null-terminator.\n \\param fmt a printf-style format wide string. Must not be NULL.\n \\param ap a `va_list` values to be used with the format string.\n \\returns the number of wide characters that should be written, not counting\n          the null-terminator char, or a negative value on error.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_vswprintf(
        text: *mut wchar_t,
        maxlen: usize,
        fmt: *const wchar_t,
        ap: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " This works exactly like asprintf() but doesn't require access to a C\n runtime.\n\n Functions identically to SDL_snprintf(), except it allocates a buffer large\n enough to hold the output string on behalf of the caller.\n\n On success, this function returns the number of bytes (not characters)\n comprising the output string, not counting the null-terminator character,\n and sets `*strp` to the newly-allocated string.\n\n On error, this function returns a negative number, and the value of `*strp`\n is undefined.\n\n The returned string is owned by the caller, and should be passed to\n SDL_free when no longer needed.\n\n \\param strp on output, is set to the new string. Must not be NULL.\n \\param fmt a printf-style format string. Must not be NULL.\n \\param ... a list of values to be used with the format string.\n \\returns the number of bytes in the newly-allocated string, not counting\n          the null-terminator char, or a negative value on error.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_asprintf(
        strp: *mut *mut ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " This works exactly like vasprintf() but doesn't require access to a C\n runtime.\n\n Functions identically to SDL_asprintf(), except it takes a `va_list`\n instead of using `...` variable arguments.\n\n \\param strp on output, is set to the new string. Must not be NULL.\n \\param fmt a printf-style format string. Must not be NULL.\n \\param ap a `va_list` values to be used with the format string.\n \\returns the number of bytes in the newly-allocated string, not counting\n          the null-terminator char, or a negative value on error.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_vasprintf(
        strp: *mut *mut ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Seeds the pseudo-random number generator.\n\n Reusing the seed number will cause SDL_rand_*() to repeat the same stream\n of 'random' numbers.\n\n \\param seed the value to use as a random number seed, or 0 to use\n             SDL_GetPerformanceCounter().\n\n \\threadsafety This should be called on the same thread that calls\n               SDL_rand*()\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_rand\n \\sa SDL_rand_bits\n \\sa SDL_randf"]
    pub fn SDL_srand(seed: Uint64);
}
unsafe extern "C" {
    #[doc = " Generate a pseudo-random number less than n for positive n\n\n The method used is faster and of better quality than `rand() % n`. Odds are\n roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and\n much worse as n gets bigger.\n\n Example: to simulate a d6 use `SDL_rand(6) + 1` The +1 converts 0..5 to\n 1..6\n\n If you want to generate a pseudo-random number in the full range of Sint32,\n you should use: (Sint32)SDL_rand_bits()\n\n If you want reproducible output, be sure to initialize with SDL_srand()\n first.\n\n There are no guarantees as to the quality of the random sequence produced,\n and this should not be used for security (cryptography, passwords) or where\n money is on the line (loot-boxes, casinos). There are many random number\n libraries available with different characteristics and you should pick one\n of those to meet any serious needs.\n\n \\param n the number of possible outcomes. n must be positive.\n \\returns a random value in the range of [0 .. n-1].\n\n \\threadsafety All calls should be made from a single thread\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_srand\n \\sa SDL_randf"]
    pub fn SDL_rand(n: Sint32) -> Sint32;
}
unsafe extern "C" {
    #[doc = " Generate a uniform pseudo-random floating point number less than 1.0\n\n If you want reproducible output, be sure to initialize with SDL_srand()\n first.\n\n There are no guarantees as to the quality of the random sequence produced,\n and this should not be used for security (cryptography, passwords) or where\n money is on the line (loot-boxes, casinos). There are many random number\n libraries available with different characteristics and you should pick one\n of those to meet any serious needs.\n\n \\returns a random value in the range of [0.0, 1.0).\n\n \\threadsafety All calls should be made from a single thread\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_srand\n \\sa SDL_rand"]
    pub fn SDL_randf() -> f32;
}
unsafe extern "C" {
    #[doc = " Generate 32 pseudo-random bits.\n\n You likely want to use SDL_rand() to get a psuedo-random number instead.\n\n There are no guarantees as to the quality of the random sequence produced,\n and this should not be used for security (cryptography, passwords) or where\n money is on the line (loot-boxes, casinos). There are many random number\n libraries available with different characteristics and you should pick one\n of those to meet any serious needs.\n\n \\returns a random value in the range of [0-SDL_MAX_UINT32].\n\n \\threadsafety All calls should be made from a single thread\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_rand\n \\sa SDL_randf\n \\sa SDL_srand"]
    pub fn SDL_rand_bits() -> Uint32;
}
unsafe extern "C" {
    #[doc = " Generate a pseudo-random number less than n for positive n\n\n The method used is faster and of better quality than `rand() % n`. Odds are\n roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and\n much worse as n gets bigger.\n\n Example: to simulate a d6 use `SDL_rand_r(state, 6) + 1` The +1 converts\n 0..5 to 1..6\n\n If you want to generate a pseudo-random number in the full range of Sint32,\n you should use: (Sint32)SDL_rand_bits_r(state)\n\n There are no guarantees as to the quality of the random sequence produced,\n and this should not be used for security (cryptography, passwords) or where\n money is on the line (loot-boxes, casinos). There are many random number\n libraries available with different characteristics and you should pick one\n of those to meet any serious needs.\n\n \\param state a pointer to the current random number state, this may not be\n              NULL.\n \\param n the number of possible outcomes. n must be positive.\n \\returns a random value in the range of [0 .. n-1].\n\n \\threadsafety This function is thread-safe, as long as the state pointer\n               isn't shared between threads.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_rand\n \\sa SDL_rand_bits_r\n \\sa SDL_randf_r"]
    pub fn SDL_rand_r(state: *mut Uint64, n: Sint32) -> Sint32;
}
unsafe extern "C" {
    #[doc = " Generate a uniform pseudo-random floating point number less than 1.0\n\n If you want reproducible output, be sure to initialize with SDL_srand()\n first.\n\n There are no guarantees as to the quality of the random sequence produced,\n and this should not be used for security (cryptography, passwords) or where\n money is on the line (loot-boxes, casinos). There are many random number\n libraries available with different characteristics and you should pick one\n of those to meet any serious needs.\n\n \\param state a pointer to the current random number state, this may not be\n              NULL.\n \\returns a random value in the range of [0.0, 1.0).\n\n \\threadsafety This function is thread-safe, as long as the state pointer\n               isn't shared between threads.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_rand_bits_r\n \\sa SDL_rand_r\n \\sa SDL_randf"]
    pub fn SDL_randf_r(state: *mut Uint64) -> f32;
}
unsafe extern "C" {
    #[doc = " Generate 32 pseudo-random bits.\n\n You likely want to use SDL_rand_r() to get a psuedo-random number instead.\n\n There are no guarantees as to the quality of the random sequence produced,\n and this should not be used for security (cryptography, passwords) or where\n money is on the line (loot-boxes, casinos). There are many random number\n libraries available with different characteristics and you should pick one\n of those to meet any serious needs.\n\n \\param state a pointer to the current random number state, this may not be\n              NULL.\n \\returns a random value in the range of [0-SDL_MAX_UINT32].\n\n \\threadsafety This function is thread-safe, as long as the state pointer\n               isn't shared between threads.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_rand_r\n \\sa SDL_randf_r"]
    pub fn SDL_rand_bits_r(state: *mut Uint64) -> Uint32;
}
unsafe extern "C" {
    #[doc = " Compute the arc cosine of `x`.\n\n The definition of `y = acos(x)` is `x = cos(y)`.\n\n Domain: `-1 <= x <= 1`\n\n Range: `0 <= y <= Pi`\n\n This function operates on double-precision floating point values, use\n SDL_acosf for single-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value.\n \\returns arc cosine of `x`, in radians.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_acosf\n \\sa SDL_asin\n \\sa SDL_cos"]
    pub fn SDL_acos(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the arc cosine of `x`.\n\n The definition of `y = acos(x)` is `x = cos(y)`.\n\n Domain: `-1 <= x <= 1`\n\n Range: `0 <= y <= Pi`\n\n This function operates on single-precision floating point values, use\n SDL_acos for double-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value.\n \\returns arc cosine of `x`, in radians.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_acos\n \\sa SDL_asinf\n \\sa SDL_cosf"]
    pub fn SDL_acosf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the arc sine of `x`.\n\n The definition of `y = asin(x)` is `x = sin(y)`.\n\n Domain: `-1 <= x <= 1`\n\n Range: `-Pi/2 <= y <= Pi/2`\n\n This function operates on double-precision floating point values, use\n SDL_asinf for single-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value.\n \\returns arc sine of `x`, in radians.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_asinf\n \\sa SDL_acos\n \\sa SDL_sin"]
    pub fn SDL_asin(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the arc sine of `x`.\n\n The definition of `y = asin(x)` is `x = sin(y)`.\n\n Domain: `-1 <= x <= 1`\n\n Range: `-Pi/2 <= y <= Pi/2`\n\n This function operates on single-precision floating point values, use\n SDL_asin for double-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value.\n \\returns arc sine of `x`, in radians.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_asin\n \\sa SDL_acosf\n \\sa SDL_sinf"]
    pub fn SDL_asinf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the arc tangent of `x`.\n\n The definition of `y = atan(x)` is `x = tan(y)`.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-Pi/2 <= y <= Pi/2`\n\n This function operates on double-precision floating point values, use\n SDL_atanf for single-precision floats.\n\n To calculate the arc tangent of y / x, use SDL_atan2.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value.\n \\returns arc tangent of of `x` in radians, or 0 if `x = 0`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_atanf\n \\sa SDL_atan2\n \\sa SDL_tan"]
    pub fn SDL_atan(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the arc tangent of `x`.\n\n The definition of `y = atan(x)` is `x = tan(y)`.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-Pi/2 <= y <= Pi/2`\n\n This function operates on single-precision floating point values, use\n SDL_atan for dboule-precision floats.\n\n To calculate the arc tangent of y / x, use SDL_atan2f.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value.\n \\returns arc tangent of of `x` in radians, or 0 if `x = 0`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_atan\n \\sa SDL_atan2f\n \\sa SDL_tanf"]
    pub fn SDL_atanf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the arc tangent of `y / x`, using the signs of x and y to adjust\n the result's quadrant.\n\n The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant\n of z is determined based on the signs of x and y.\n\n Domain: `-INF <= x <= INF`, `-INF <= y <= INF`\n\n Range: `-Pi/2 <= y <= Pi/2`\n\n This function operates on double-precision floating point values, use\n SDL_atan2f for single-precision floats.\n\n To calculate the arc tangent of a single value, use SDL_atan.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param y floating point value of the numerator (y coordinate).\n \\param x floating point value of the denominator (x coordinate).\n \\returns arc tangent of of `y / x` in radians, or, if `x = 0`, either\n          `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_atan2f\n \\sa SDL_atan\n \\sa SDL_tan"]
    pub fn SDL_atan2(y: f64, x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the arc tangent of `y / x`, using the signs of x and y to adjust\n the result's quadrant.\n\n The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant\n of z is determined based on the signs of x and y.\n\n Domain: `-INF <= x <= INF`, `-INF <= y <= INF`\n\n Range: `-Pi/2 <= y <= Pi/2`\n\n This function operates on single-precision floating point values, use\n SDL_atan2 for double-precision floats.\n\n To calculate the arc tangent of a single value, use SDL_atanf.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param y floating point value of the numerator (y coordinate).\n \\param x floating point value of the denominator (x coordinate).\n \\returns arc tangent of of `y / x` in radians, or, if `x = 0`, either\n          `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_atan2\n \\sa SDL_atan\n \\sa SDL_tan"]
    pub fn SDL_atan2f(y: f32, x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the ceiling of `x`.\n\n The ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`\n rounded up to the nearest integer.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-INF <= y <= INF`, y integer\n\n This function operates on double-precision floating point values, use\n SDL_ceilf for single-precision floats.\n\n \\param x floating point value.\n \\returns the ceiling of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ceilf\n \\sa SDL_floor\n \\sa SDL_trunc\n \\sa SDL_round\n \\sa SDL_lround"]
    pub fn SDL_ceil(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the ceiling of `x`.\n\n The ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`\n rounded up to the nearest integer.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-INF <= y <= INF`, y integer\n\n This function operates on single-precision floating point values, use\n SDL_ceil for double-precision floats.\n\n \\param x floating point value.\n \\returns the ceiling of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ceil\n \\sa SDL_floorf\n \\sa SDL_truncf\n \\sa SDL_roundf\n \\sa SDL_lroundf"]
    pub fn SDL_ceilf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Copy the sign of one floating-point value to another.\n\n The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.\n\n Domain: `-INF <= x <= INF`, ``-INF <= y <= f``\n\n Range: `-INF <= z <= INF`\n\n This function operates on double-precision floating point values, use\n SDL_copysignf for single-precision floats.\n\n \\param x floating point value to use as the magnitude.\n \\param y floating point value to use as the sign.\n \\returns the floating point value with the sign of y and the magnitude of\n          x.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_copysignf\n \\sa SDL_fabs"]
    pub fn SDL_copysign(x: f64, y: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Copy the sign of one floating-point value to another.\n\n The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.\n\n Domain: `-INF <= x <= INF`, ``-INF <= y <= f``\n\n Range: `-INF <= z <= INF`\n\n This function operates on single-precision floating point values, use\n SDL_copysign for double-precision floats.\n\n \\param x floating point value to use as the magnitude.\n \\param y floating point value to use as the sign.\n \\returns the floating point value with the sign of y and the magnitude of\n          x.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_copysign\n \\sa SDL_fabsf"]
    pub fn SDL_copysignf(x: f32, y: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the cosine of `x`.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-1 <= y <= 1`\n\n This function operates on double-precision floating point values, use\n SDL_cosf for single-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value, in radians.\n \\returns cosine of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_cosf\n \\sa SDL_acos\n \\sa SDL_sin"]
    pub fn SDL_cos(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the cosine of `x`.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-1 <= y <= 1`\n\n This function operates on single-precision floating point values, use\n SDL_cos for double-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value, in radians.\n \\returns cosine of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_cos\n \\sa SDL_acosf\n \\sa SDL_sinf"]
    pub fn SDL_cosf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the exponential of `x`.\n\n The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the\n natural logarithm. The inverse is the natural logarithm, SDL_log.\n\n Domain: `-INF <= x <= INF`\n\n Range: `0 <= y <= INF`\n\n The output will overflow if `exp(x)` is too large to be represented.\n\n This function operates on double-precision floating point values, use\n SDL_expf for single-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value.\n \\returns value of `e^x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_expf\n \\sa SDL_log"]
    pub fn SDL_exp(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the exponential of `x`.\n\n The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the\n natural logarithm. The inverse is the natural logarithm, SDL_logf.\n\n Domain: `-INF <= x <= INF`\n\n Range: `0 <= y <= INF`\n\n The output will overflow if `exp(x)` is too large to be represented.\n\n This function operates on single-precision floating point values, use\n SDL_exp for double-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value.\n \\returns value of `e^x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_exp\n \\sa SDL_logf"]
    pub fn SDL_expf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the absolute value of `x`\n\n Domain: `-INF <= x <= INF`\n\n Range: `0 <= y <= INF`\n\n This function operates on double-precision floating point values, use\n SDL_fabsf for single-precision floats.\n\n \\param x floating point value to use as the magnitude.\n \\returns the absolute value of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_fabsf"]
    pub fn SDL_fabs(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the absolute value of `x`\n\n Domain: `-INF <= x <= INF`\n\n Range: `0 <= y <= INF`\n\n This function operates on single-precision floating point values, use\n SDL_fabs for double-precision floats.\n\n \\param x floating point value to use as the magnitude.\n \\returns the absolute value of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_fabs"]
    pub fn SDL_fabsf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the floor of `x`.\n\n The floor of `x` is the largest integer `y` such that `y > x`, i.e `x`\n rounded down to the nearest integer.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-INF <= y <= INF`, y integer\n\n This function operates on double-precision floating point values, use\n SDL_floorf for single-precision floats.\n\n \\param x floating point value.\n \\returns the floor of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_floorf\n \\sa SDL_ceil\n \\sa SDL_trunc\n \\sa SDL_round\n \\sa SDL_lround"]
    pub fn SDL_floor(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the floor of `x`.\n\n The floor of `x` is the largest integer `y` such that `y > x`, i.e `x`\n rounded down to the nearest integer.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-INF <= y <= INF`, y integer\n\n This function operates on single-precision floating point values, use\n SDL_floor for double-precision floats.\n\n \\param x floating point value.\n \\returns the floor of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_floor\n \\sa SDL_ceilf\n \\sa SDL_truncf\n \\sa SDL_roundf\n \\sa SDL_lroundf"]
    pub fn SDL_floorf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Truncate `x` to an integer.\n\n Rounds `x` to the next closest integer to 0. This is equivalent to removing\n the fractional part of `x`, leaving only the integer part.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-INF <= y <= INF`, y integer\n\n This function operates on double-precision floating point values, use\n SDL_truncf for single-precision floats.\n\n \\param x floating point value.\n \\returns `x` truncated to an integer.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_truncf\n \\sa SDL_fmod\n \\sa SDL_ceil\n \\sa SDL_floor\n \\sa SDL_round\n \\sa SDL_lround"]
    pub fn SDL_trunc(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Truncate `x` to an integer.\n\n Rounds `x` to the next closest integer to 0. This is equivalent to removing\n the fractional part of `x`, leaving only the integer part.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-INF <= y <= INF`, y integer\n\n This function operates on single-precision floating point values, use\n SDL_trunc for double-precision floats.\n\n \\param x floating point value.\n \\returns `x` truncated to an integer.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_trunc\n \\sa SDL_fmodf\n \\sa SDL_ceilf\n \\sa SDL_floorf\n \\sa SDL_roundf\n \\sa SDL_lroundf"]
    pub fn SDL_truncf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Return the floating-point remainder of `x / y`\n\n Divides `x` by `y`, and returns the remainder.\n\n Domain: `-INF <= x <= INF`, `-INF <= y <= INF`, `y != 0`\n\n Range: `-y <= z <= y`\n\n This function operates on double-precision floating point values, use\n SDL_fmodf for single-precision floats.\n\n \\param x the numerator.\n \\param y the denominator. Must not be 0.\n \\returns the remainder of `x / y`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_fmodf\n \\sa SDL_modf\n \\sa SDL_trunc\n \\sa SDL_ceil\n \\sa SDL_floor\n \\sa SDL_round\n \\sa SDL_lround"]
    pub fn SDL_fmod(x: f64, y: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Return the floating-point remainder of `x / y`\n\n Divides `x` by `y`, and returns the remainder.\n\n Domain: `-INF <= x <= INF`, `-INF <= y <= INF`, `y != 0`\n\n Range: `-y <= z <= y`\n\n This function operates on single-precision floating point values, use\n SDL_fmod for double-precision floats.\n\n \\param x the numerator.\n \\param y the denominator. Must not be 0.\n \\returns the remainder of `x / y`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_fmod\n \\sa SDL_truncf\n \\sa SDL_modff\n \\sa SDL_ceilf\n \\sa SDL_floorf\n \\sa SDL_roundf\n \\sa SDL_lroundf"]
    pub fn SDL_fmodf(x: f32, y: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Return whether the value is infinity.\n\n \\param x double-precision floating point value.\n \\returns non-zero if the value is infinity, 0 otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_isinff"]
    pub fn SDL_isinf(x: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Return whether the value is infinity.\n\n \\param x floating point value.\n \\returns non-zero if the value is infinity, 0 otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_isinf"]
    pub fn SDL_isinff(x: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Return whether the value is NaN.\n\n \\param x double-precision floating point value.\n \\returns non-zero if the value is NaN, 0 otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_isnanf"]
    pub fn SDL_isnan(x: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Return whether the value is NaN.\n\n \\param x floating point value.\n \\returns non-zero if the value is NaN, 0 otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_isnan"]
    pub fn SDL_isnanf(x: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Compute the natural logarithm of `x`.\n\n Domain: `0 < x <= INF`\n\n Range: `-INF <= y <= INF`\n\n It is an error for `x` to be less than or equal to 0.\n\n This function operates on double-precision floating point values, use\n SDL_logf for single-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value. Must be greater than 0.\n \\returns the natural logarithm of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_logf\n \\sa SDL_log10\n \\sa SDL_exp"]
    pub fn SDL_log(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the natural logarithm of `x`.\n\n Domain: `0 < x <= INF`\n\n Range: `-INF <= y <= INF`\n\n It is an error for `x` to be less than or equal to 0.\n\n This function operates on single-precision floating point values, use\n SDL_log for double-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value. Must be greater than 0.\n \\returns the natural logarithm of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_log\n \\sa SDL_expf"]
    pub fn SDL_logf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the base-10 logarithm of `x`.\n\n Domain: `0 < x <= INF`\n\n Range: `-INF <= y <= INF`\n\n It is an error for `x` to be less than or equal to 0.\n\n This function operates on double-precision floating point values, use\n SDL_log10f for single-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value. Must be greater than 0.\n \\returns the logarithm of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_log10f\n \\sa SDL_log\n \\sa SDL_pow"]
    pub fn SDL_log10(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the base-10 logarithm of `x`.\n\n Domain: `0 < x <= INF`\n\n Range: `-INF <= y <= INF`\n\n It is an error for `x` to be less than or equal to 0.\n\n This function operates on single-precision floating point values, use\n SDL_log10 for double-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value. Must be greater than 0.\n \\returns the logarithm of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_log10\n \\sa SDL_logf\n \\sa SDL_powf"]
    pub fn SDL_log10f(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Split `x` into integer and fractional parts\n\n This function operates on double-precision floating point values, use\n SDL_modff for single-precision floats.\n\n \\param x floating point value.\n \\param y output pointer to store the integer part of `x`.\n \\returns the fractional part of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_modff\n \\sa SDL_trunc\n \\sa SDL_fmod"]
    pub fn SDL_modf(x: f64, y: *mut f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Split `x` into integer and fractional parts\n\n This function operates on single-precision floating point values, use\n SDL_modf for double-precision floats.\n\n \\param x floating point value.\n \\param y output pointer to store the integer part of `x`.\n \\returns the fractional part of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_modf\n \\sa SDL_truncf\n \\sa SDL_fmodf"]
    pub fn SDL_modff(x: f32, y: *mut f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Raise `x` to the power `y`\n\n Domain: `-INF <= x <= INF`, `-INF <= y <= INF`\n\n Range: `-INF <= z <= INF`\n\n If `y` is the base of the natural logarithm (e), consider using SDL_exp\n instead.\n\n This function operates on double-precision floating point values, use\n SDL_powf for single-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x the base.\n \\param y the exponent.\n \\returns `x` raised to the power `y`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_powf\n \\sa SDL_exp\n \\sa SDL_log"]
    pub fn SDL_pow(x: f64, y: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Raise `x` to the power `y`\n\n Domain: `-INF <= x <= INF`, `-INF <= y <= INF`\n\n Range: `-INF <= z <= INF`\n\n If `y` is the base of the natural logarithm (e), consider using SDL_exp\n instead.\n\n This function operates on single-precision floating point values, use\n SDL_pow for double-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x the base.\n \\param y the exponent.\n \\returns `x` raised to the power `y`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_pow\n \\sa SDL_expf\n \\sa SDL_logf"]
    pub fn SDL_powf(x: f32, y: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Round `x` to the nearest integer.\n\n Rounds `x` to the nearest integer. Values halfway between integers will be\n rounded away from zero.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-INF <= y <= INF`, y integer\n\n This function operates on double-precision floating point values, use\n SDL_roundf for single-precision floats. To get the result as an integer\n type, use SDL_lround.\n\n \\param x floating point value.\n \\returns the nearest integer to `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_roundf\n \\sa SDL_lround\n \\sa SDL_floor\n \\sa SDL_ceil\n \\sa SDL_trunc"]
    pub fn SDL_round(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Round `x` to the nearest integer.\n\n Rounds `x` to the nearest integer. Values halfway between integers will be\n rounded away from zero.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-INF <= y <= INF`, y integer\n\n This function operates on single-precision floating point values, use\n SDL_round for double-precision floats. To get the result as an integer\n type, use SDL_lroundf.\n\n \\param x floating point value.\n \\returns the nearest integer to `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_round\n \\sa SDL_lroundf\n \\sa SDL_floorf\n \\sa SDL_ceilf\n \\sa SDL_truncf"]
    pub fn SDL_roundf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Round `x` to the nearest integer representable as a long\n\n Rounds `x` to the nearest integer. Values halfway between integers will be\n rounded away from zero.\n\n Domain: `-INF <= x <= INF`\n\n Range: `MIN_LONG <= y <= MAX_LONG`\n\n This function operates on double-precision floating point values, use\n SDL_lroundf for single-precision floats. To get the result as a\n floating-point type, use SDL_round.\n\n \\param x floating point value.\n \\returns the nearest integer to `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_lroundf\n \\sa SDL_round\n \\sa SDL_floor\n \\sa SDL_ceil\n \\sa SDL_trunc"]
    pub fn SDL_lround(x: f64) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    #[doc = " Round `x` to the nearest integer representable as a long\n\n Rounds `x` to the nearest integer. Values halfway between integers will be\n rounded away from zero.\n\n Domain: `-INF <= x <= INF`\n\n Range: `MIN_LONG <= y <= MAX_LONG`\n\n This function operates on single-precision floating point values, use\n SDL_lround for double-precision floats. To get the result as a\n floating-point type, use SDL_roundf.\n\n \\param x floating point value.\n \\returns the nearest integer to `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_lround\n \\sa SDL_roundf\n \\sa SDL_floorf\n \\sa SDL_ceilf\n \\sa SDL_truncf"]
    pub fn SDL_lroundf(x: f32) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    #[doc = " Scale `x` by an integer power of two.\n\n Multiplies `x` by the `n`th power of the floating point radix (always 2).\n\n Domain: `-INF <= x <= INF`, `n` integer\n\n Range: `-INF <= y <= INF`\n\n This function operates on double-precision floating point values, use\n SDL_scalbnf for single-precision floats.\n\n \\param x floating point value to be scaled.\n \\param n integer exponent.\n \\returns `x * 2^n`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_scalbnf\n \\sa SDL_pow"]
    pub fn SDL_scalbn(x: f64, n: ::core::ffi::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " Scale `x` by an integer power of two.\n\n Multiplies `x` by the `n`th power of the floating point radix (always 2).\n\n Domain: `-INF <= x <= INF`, `n` integer\n\n Range: `-INF <= y <= INF`\n\n This function operates on single-precision floating point values, use\n SDL_scalbn for double-precision floats.\n\n \\param x floating point value to be scaled.\n \\param n integer exponent.\n \\returns `x * 2^n`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_scalbn\n \\sa SDL_powf"]
    pub fn SDL_scalbnf(x: f32, n: ::core::ffi::c_int) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the sine of `x`.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-1 <= y <= 1`\n\n This function operates on double-precision floating point values, use\n SDL_sinf for single-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value, in radians.\n \\returns sine of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_sinf\n \\sa SDL_asin\n \\sa SDL_cos"]
    pub fn SDL_sin(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the sine of `x`.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-1 <= y <= 1`\n\n This function operates on single-precision floating point values, use\n SDL_sin for double-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value, in radians.\n \\returns sine of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_sin\n \\sa SDL_asinf\n \\sa SDL_cosf"]
    pub fn SDL_sinf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the square root of `x`.\n\n Domain: `0 <= x <= INF`\n\n Range: `0 <= y <= INF`\n\n This function operates on double-precision floating point values, use\n SDL_sqrtf for single-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value. Must be greater than or equal to 0.\n \\returns square root of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_sqrtf"]
    pub fn SDL_sqrt(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the square root of `x`.\n\n Domain: `0 <= x <= INF`\n\n Range: `0 <= y <= INF`\n\n This function operates on single-precision floating point values, use\n SDL_sqrt for double-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value. Must be greater than or equal to 0.\n \\returns square root of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_sqrt"]
    pub fn SDL_sqrtf(x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the tangent of `x`.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-INF <= y <= INF`\n\n This function operates on double-precision floating point values, use\n SDL_tanf for single-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value, in radians.\n \\returns tangent of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_tanf\n \\sa SDL_sin\n \\sa SDL_cos\n \\sa SDL_atan\n \\sa SDL_atan2"]
    pub fn SDL_tan(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " Compute the tangent of `x`.\n\n Domain: `-INF <= x <= INF`\n\n Range: `-INF <= y <= INF`\n\n This function operates on single-precision floating point values, use\n SDL_tan for double-precision floats.\n\n This function may use a different approximation across different versions,\n platforms and configurations. i.e, it can return a different value given\n the same input on different machines or operating systems, or if SDL is\n updated.\n\n \\param x floating point value, in radians.\n \\returns tangent of `x`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_tan\n \\sa SDL_sinf\n \\sa SDL_cosf\n \\sa SDL_atanf\n \\sa SDL_atan2f"]
    pub fn SDL_tanf(x: f32) -> f32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_iconv_data_t {
    _unused: [u8; 0],
}
#[doc = " An opaque handle representing string encoding conversion state.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_iconv_open"]
pub type SDL_iconv_t = *mut SDL_iconv_data_t;
unsafe extern "C" {
    #[doc = " This function allocates a context for the specified character set\n conversion.\n\n \\param tocode The target character encoding, must not be NULL.\n \\param fromcode The source character encoding, must not be NULL.\n \\returns a handle that must be freed with SDL_iconv_close, or\n          SDL_ICONV_ERROR on failure.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_iconv\n \\sa SDL_iconv_close\n \\sa SDL_iconv_string"]
    pub fn SDL_iconv_open(
        tocode: *const ::core::ffi::c_char,
        fromcode: *const ::core::ffi::c_char,
    ) -> SDL_iconv_t;
}
unsafe extern "C" {
    #[doc = " This function frees a context used for character set conversion.\n\n \\param cd The character set conversion handle.\n \\returns 0 on success, or -1 on failure.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_iconv\n \\sa SDL_iconv_open\n \\sa SDL_iconv_string"]
    pub fn SDL_iconv_close(cd: SDL_iconv_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " This function converts text between encodings, reading from and writing to\n a buffer.\n\n It returns the number of succesful conversions on success. On error,\n SDL_ICONV_E2BIG is returned when the output buffer is too small, or\n SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,\n or SDL_ICONV_EINVAL is returned when an incomplete input sequence is\n encountered.\n\n On exit:\n\n - inbuf will point to the beginning of the next multibyte sequence. On\n   error, this is the location of the problematic input sequence. On\n   success, this is the end of the input sequence.\n - inbytesleft will be set to the number of bytes left to convert, which\n   will be 0 on success.\n - outbuf will point to the location where to store the next output byte.\n - outbytesleft will be set to the number of bytes left in the output\n   buffer.\n\n \\param cd The character set conversion context, created in\n           SDL_iconv_open().\n \\param inbuf Address of variable that points to the first character of the\n              input sequence.\n \\param inbytesleft The number of bytes in the input buffer.\n \\param outbuf Address of variable that points to the output buffer.\n \\param outbytesleft The number of bytes in the output buffer.\n \\returns the number of conversions on success, or a negative error code.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_iconv_open\n \\sa SDL_iconv_close\n \\sa SDL_iconv_string"]
    pub fn SDL_iconv(
        cd: SDL_iconv_t,
        inbuf: *mut *const ::core::ffi::c_char,
        inbytesleft: *mut usize,
        outbuf: *mut *mut ::core::ffi::c_char,
        outbytesleft: *mut usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Helper function to convert a string's encoding in one call.\n\n This function converts a buffer or string between encodings in one pass.\n\n The string does not need to be NULL-terminated; this function operates on\n the number of bytes specified in `inbytesleft` whether there is a NULL\n character anywhere in the buffer.\n\n The returned string is owned by the caller, and should be passed to\n SDL_free when no longer needed.\n\n \\param tocode the character encoding of the output string. Examples are\n               \"UTF-8\", \"UCS-4\", etc.\n \\param fromcode the character encoding of data in `inbuf`.\n \\param inbuf the string to convert to a different encoding.\n \\param inbytesleft the size of the input string _in bytes_.\n \\returns a new string, converted to the new encoding, or NULL on error.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_iconv_open\n \\sa SDL_iconv_close\n \\sa SDL_iconv"]
    pub fn SDL_iconv_string(
        tocode: *const ::core::ffi::c_char,
        fromcode: *const ::core::ffi::c_char,
        inbuf: *const ::core::ffi::c_char,
        inbytesleft: usize,
    ) -> *mut ::core::ffi::c_char;
}
pub type SDL_FunctionPointer = ::core::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    #[doc = " Set the SDL error message for the current thread.\n\n Calling this function will replace any previous error message that was set.\n\n This function always returns false, since SDL frequently uses false to\n signify a failing result, leading to this idiom:\n\n ```c\n if (error_code) {\n     return SDL_SetError(\"This operation has failed: %d\", error_code);\n }\n ```\n\n \\param fmt a printf()-style message format string.\n \\param ... additional parameters matching % tokens in the `fmt` string, if\n            any.\n \\returns false.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ClearError\n \\sa SDL_GetError\n \\sa SDL_SetErrorV"]
    pub fn SDL_SetError(fmt: *const ::core::ffi::c_char, ...) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the SDL error message for the current thread.\n\n Calling this function will replace any previous error message that was set.\n\n \\param fmt a printf()-style message format string.\n \\param ap a variable argument list.\n \\returns false.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ClearError\n \\sa SDL_GetError\n \\sa SDL_SetError"]
    pub fn SDL_SetErrorV(fmt: *const ::core::ffi::c_char, ap: *mut __va_list_tag) -> bool;
}
unsafe extern "C" {
    #[doc = " Set an error indicating that memory allocation failed.\n\n This function does not do any memory allocation.\n\n \\returns false.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_OutOfMemory() -> bool;
}
unsafe extern "C" {
    #[doc = " Retrieve a message about the last error that occurred on the current\n thread.\n\n It is possible for multiple errors to occur before calling SDL_GetError().\n Only the last error is returned.\n\n The message is only applicable when an SDL function has signaled an error.\n You must check the return values of SDL function calls to determine when to\n appropriately call SDL_GetError(). You should *not* use the results of\n SDL_GetError() to decide if an error has occurred! Sometimes SDL will set\n an error string even when reporting success.\n\n SDL will *not* clear the error string for successful API calls. You *must*\n check return values for failure cases before you can assume the error\n string applies.\n\n Error strings are set per-thread, so an error set in a different thread\n will not interfere with the current thread's operation.\n\n The returned value is a thread-local string which will remain valid until\n the current thread's error string is changed. The caller should make a copy\n if the value is needed after the next SDL API call.\n\n \\returns a message with information about the specific error that occurred,\n          or an empty string if there hasn't been an error message set since\n          the last call to SDL_ClearError().\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ClearError\n \\sa SDL_SetError"]
    pub fn SDL_GetError() -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Clear any previous error message for this thread.\n\n \\returns true.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetError\n \\sa SDL_SetError"]
    pub fn SDL_ClearError() -> bool;
}
#[doc = " An atomic spinlock.\n\n The atomic locks are efficient spinlocks using CPU instructions, but are\n vulnerable to starvation and can spin forever if a thread holding a lock\n has been terminated. For this reason you should minimize the code executed\n inside an atomic lock and never do expensive things like API or system\n calls while holding them.\n\n They are also vulnerable to starvation if the thread holding the lock is\n lower priority than other threads and doesn't get scheduled. In general you\n should use mutexes instead, since they have better performance and\n contention behavior.\n\n The atomic locks are not safe to lock recursively.\n\n Porting Note: The spin lock functions and type are required and can not be\n emulated because they are used in the atomic emulation code."]
pub type SDL_SpinLock = ::core::ffi::c_int;
unsafe extern "C" {
    #[doc = " Try to lock a spin lock by setting it to a non-zero value.\n\n ***Please note that spinlocks are dangerous if you don't know what you're\n doing. Please be careful using any sort of spinlock!***\n\n \\param lock a pointer to a lock variable.\n \\returns true if the lock succeeded, false if the lock is already held.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LockSpinlock\n \\sa SDL_UnlockSpinlock"]
    pub fn SDL_TryLockSpinlock(lock: *mut SDL_SpinLock) -> bool;
}
unsafe extern "C" {
    #[doc = " Lock a spin lock by setting it to a non-zero value.\n\n ***Please note that spinlocks are dangerous if you don't know what you're\n doing. Please be careful using any sort of spinlock!***\n\n \\param lock a pointer to a lock variable.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_TryLockSpinlock\n \\sa SDL_UnlockSpinlock"]
    pub fn SDL_LockSpinlock(lock: *mut SDL_SpinLock);
}
unsafe extern "C" {
    #[doc = " Unlock a spin lock by setting it to 0.\n\n Always returns immediately.\n\n ***Please note that spinlocks are dangerous if you don't know what you're\n doing. Please be careful using any sort of spinlock!***\n\n \\param lock a pointer to a lock variable.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LockSpinlock\n \\sa SDL_TryLockSpinlock"]
    pub fn SDL_UnlockSpinlock(lock: *mut SDL_SpinLock);
}
unsafe extern "C" {
    #[doc = " Insert a memory release barrier (function version).\n\n Please refer to SDL_MemoryBarrierRelease for details. This is a function\n version, which might be useful if you need to use this functionality from a\n scripting language, etc. Also, some of the macro versions call this\n function behind the scenes, where more heavy lifting can happen inside of\n SDL. Generally, though, an app written in C/C++/etc should use the macro\n version, as it will be more efficient.\n\n \\threadsafety Obviously this function is safe to use from any thread at any\n               time, but if you find yourself needing this, you are probably\n               dealing with some very sensitive code; be careful!\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_MemoryBarrierRelease"]
    pub fn SDL_MemoryBarrierReleaseFunction();
}
unsafe extern "C" {
    #[doc = " Insert a memory acquire barrier (function version).\n\n Please refer to SDL_MemoryBarrierRelease for details. This is a function\n version, which might be useful if you need to use this functionality from a\n scripting language, etc. Also, some of the macro versions call this\n function behind the scenes, where more heavy lifting can happen inside of\n SDL. Generally, though, an app written in C/C++/etc should use the macro\n version, as it will be more efficient.\n\n \\threadsafety Obviously this function is safe to use from any thread at any\n               time, but if you find yourself needing this, you are probably\n               dealing with some very sensitive code; be careful!\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_MemoryBarrierAcquire"]
    pub fn SDL_MemoryBarrierAcquireFunction();
}
#[doc = " A type representing an atomic integer value.\n\n This can be used to manage a value that is synchronized across multiple\n CPUs without a race condition; when an app sets a value with\n SDL_SetAtomicInt all other threads, regardless of the CPU it is running on,\n will see that value when retrieved with SDL_GetAtomicInt, regardless of CPU\n caches, etc.\n\n This is also useful for atomic compare-and-swap operations: a thread can\n change the value as long as its current value matches expectations. When\n done in a loop, one can guarantee data consistency across threads without a\n lock (but the usual warnings apply: if you don't know what you're doing, or\n you don't do it carefully, you can confidently cause any number of\n disasters with this, so in most cases, you _should_ use a mutex instead of\n this!).\n\n This is a struct so people don't accidentally use numeric operations on it\n directly. You have to use SDL atomic functions.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_CompareAndSwapAtomicInt\n \\sa SDL_GetAtomicInt\n \\sa SDL_SetAtomicInt\n \\sa SDL_AddAtomicInt"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AtomicInt {
    pub value: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_AtomicInt"][::core::mem::size_of::<SDL_AtomicInt>() - 4usize];
    ["Alignment of SDL_AtomicInt"][::core::mem::align_of::<SDL_AtomicInt>() - 4usize];
    ["Offset of field: SDL_AtomicInt::value"]
        [::core::mem::offset_of!(SDL_AtomicInt, value) - 0usize];
};
unsafe extern "C" {
    #[doc = " Set an atomic variable to a new value if it is currently an old value.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to an SDL_AtomicInt variable to be modified.\n \\param oldval the old value.\n \\param newval the new value.\n \\returns true if the atomic variable was set, false otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAtomicInt\n \\sa SDL_SetAtomicInt"]
    pub fn SDL_CompareAndSwapAtomicInt(
        a: *mut SDL_AtomicInt,
        oldval: ::core::ffi::c_int,
        newval: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set an atomic variable to a value.\n\n This function also acts as a full memory barrier.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to an SDL_AtomicInt variable to be modified.\n \\param v the desired value.\n \\returns the previous value of the atomic variable.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAtomicInt"]
    pub fn SDL_SetAtomicInt(a: *mut SDL_AtomicInt, v: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the value of an atomic variable.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to an SDL_AtomicInt variable.\n \\returns the current value of an atomic variable.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAtomicInt"]
    pub fn SDL_GetAtomicInt(a: *mut SDL_AtomicInt) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Add to an atomic variable.\n\n This function also acts as a full memory barrier.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to an SDL_AtomicInt variable to be modified.\n \\param v the desired value to add.\n \\returns the previous value of the atomic variable.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AtomicDecRef\n \\sa SDL_AtomicIncRef"]
    pub fn SDL_AddAtomicInt(a: *mut SDL_AtomicInt, v: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[doc = " A type representing an atomic unsigned 32-bit value.\n\n This can be used to manage a value that is synchronized across multiple\n CPUs without a race condition; when an app sets a value with\n SDL_SetAtomicU32 all other threads, regardless of the CPU it is running on,\n will see that value when retrieved with SDL_GetAtomicU32, regardless of CPU\n caches, etc.\n\n This is also useful for atomic compare-and-swap operations: a thread can\n change the value as long as its current value matches expectations. When\n done in a loop, one can guarantee data consistency across threads without a\n lock (but the usual warnings apply: if you don't know what you're doing, or\n you don't do it carefully, you can confidently cause any number of\n disasters with this, so in most cases, you _should_ use a mutex instead of\n this!).\n\n This is a struct so people don't accidentally use numeric operations on it\n directly. You have to use SDL atomic functions.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_CompareAndSwapAtomicU32\n \\sa SDL_GetAtomicU32\n \\sa SDL_SetAtomicU32"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AtomicU32 {
    pub value: Uint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_AtomicU32"][::core::mem::size_of::<SDL_AtomicU32>() - 4usize];
    ["Alignment of SDL_AtomicU32"][::core::mem::align_of::<SDL_AtomicU32>() - 4usize];
    ["Offset of field: SDL_AtomicU32::value"]
        [::core::mem::offset_of!(SDL_AtomicU32, value) - 0usize];
};
unsafe extern "C" {
    #[doc = " Set an atomic variable to a new value if it is currently an old value.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to an SDL_AtomicU32 variable to be modified.\n \\param oldval the old value.\n \\param newval the new value.\n \\returns true if the atomic variable was set, false otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAtomicU32\n \\sa SDL_SetAtomicU32"]
    pub fn SDL_CompareAndSwapAtomicU32(
        a: *mut SDL_AtomicU32,
        oldval: Uint32,
        newval: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set an atomic variable to a value.\n\n This function also acts as a full memory barrier.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to an SDL_AtomicU32 variable to be modified.\n \\param v the desired value.\n \\returns the previous value of the atomic variable.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAtomicU32"]
    pub fn SDL_SetAtomicU32(a: *mut SDL_AtomicU32, v: Uint32) -> Uint32;
}
unsafe extern "C" {
    #[doc = " Get the value of an atomic variable.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to an SDL_AtomicU32 variable.\n \\returns the current value of an atomic variable.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAtomicU32"]
    pub fn SDL_GetAtomicU32(a: *mut SDL_AtomicU32) -> Uint32;
}
unsafe extern "C" {
    #[doc = " Set a pointer to a new value if it is currently an old value.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to a pointer.\n \\param oldval the old pointer value.\n \\param newval the new pointer value.\n \\returns true if the pointer was set, false otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CompareAndSwapAtomicInt\n \\sa SDL_GetAtomicPointer\n \\sa SDL_SetAtomicPointer"]
    pub fn SDL_CompareAndSwapAtomicPointer(
        a: *mut *mut ::core::ffi::c_void,
        oldval: *mut ::core::ffi::c_void,
        newval: *mut ::core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set a pointer to a value atomically.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to a pointer.\n \\param v the desired pointer value.\n \\returns the previous value of the pointer.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CompareAndSwapAtomicPointer\n \\sa SDL_GetAtomicPointer"]
    pub fn SDL_SetAtomicPointer(
        a: *mut *mut ::core::ffi::c_void,
        v: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Get the value of a pointer atomically.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to a pointer.\n \\returns the current value of a pointer.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CompareAndSwapAtomicPointer\n \\sa SDL_SetAtomicPointer"]
    pub fn SDL_GetAtomicPointer(a: *mut *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void;
}
#[doc = " SDL properties ID\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_PropertiesID = Uint32;
pub const SDL_PropertyType_SDL_PROPERTY_TYPE_INVALID: SDL_PropertyType = 0;
pub const SDL_PropertyType_SDL_PROPERTY_TYPE_POINTER: SDL_PropertyType = 1;
pub const SDL_PropertyType_SDL_PROPERTY_TYPE_STRING: SDL_PropertyType = 2;
pub const SDL_PropertyType_SDL_PROPERTY_TYPE_NUMBER: SDL_PropertyType = 3;
pub const SDL_PropertyType_SDL_PROPERTY_TYPE_FLOAT: SDL_PropertyType = 4;
pub const SDL_PropertyType_SDL_PROPERTY_TYPE_BOOLEAN: SDL_PropertyType = 5;
#[doc = " SDL property type\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_PropertyType = ::core::ffi::c_uint;
unsafe extern "C" {
    #[doc = " Get the global SDL properties.\n\n \\returns a valid property ID on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGlobalProperties() -> SDL_PropertiesID;
}
unsafe extern "C" {
    #[doc = " Create a group of properties.\n\n All properties are automatically destroyed when SDL_Quit() is called.\n\n \\returns an ID for a new group of properties, or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DestroyProperties"]
    pub fn SDL_CreateProperties() -> SDL_PropertiesID;
}
unsafe extern "C" {
    #[doc = " Copy a group of properties.\n\n Copy all the properties from one group of properties to another, with the\n exception of properties requiring cleanup (set using\n SDL_SetPointerPropertyWithCleanup()), which will not be copied. Any\n property that already exists on `dst` will be overwritten.\n\n \\param src the properties to copy.\n \\param dst the destination properties.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_CopyProperties(src: SDL_PropertiesID, dst: SDL_PropertiesID) -> bool;
}
unsafe extern "C" {
    #[doc = " Lock a group of properties.\n\n Obtain a multi-threaded lock for these properties. Other threads will wait\n while trying to lock these properties until they are unlocked. Properties\n must be unlocked before they are destroyed.\n\n The lock is automatically taken when setting individual properties, this\n function is only needed when you want to set several properties atomically\n or want to guarantee that properties being queried aren't freed in another\n thread.\n\n \\param props the properties to lock.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_UnlockProperties"]
    pub fn SDL_LockProperties(props: SDL_PropertiesID) -> bool;
}
unsafe extern "C" {
    #[doc = " Unlock a group of properties.\n\n \\param props the properties to unlock.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LockProperties"]
    pub fn SDL_UnlockProperties(props: SDL_PropertiesID);
}
#[doc = " A callback used to free resources when a property is deleted.\n\n This should release any resources associated with `value` that are no\n longer needed.\n\n This callback is set per-property. Different properties in the same group\n can have different cleanup callbacks.\n\n This callback will be called _during_ SDL_SetPointerPropertyWithCleanup if\n the function fails for any reason.\n\n \\param userdata an app-defined pointer passed to the callback.\n \\param value the pointer assigned to the property to clean up.\n\n \\threadsafety This callback may fire without any locks held; if this is a\n               concern, the app should provide its own locking.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_SetPointerPropertyWithCleanup"]
pub type SDL_CleanupPropertyCallback = ::core::option::Option<
    unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void),
>;
unsafe extern "C" {
    #[doc = " Set a pointer property in a group of properties with a cleanup function\n that is called when the property is deleted.\n\n The cleanup function is also called if setting the property fails for any\n reason.\n\n For simply setting basic data types, like numbers, bools, or strings, use\n SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty\n instead, as those functions will handle cleanup on your behalf. This\n function is only for more complex, custom data.\n\n \\param props the properties to modify.\n \\param name the name of the property to modify.\n \\param value the new value of the property, or NULL to delete the property.\n \\param cleanup the function to call when this property is deleted, or NULL\n                if no cleanup is necessary.\n \\param userdata a pointer that is passed to the cleanup function.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetPointerProperty\n \\sa SDL_SetPointerProperty\n \\sa SDL_CleanupPropertyCallback"]
    pub fn SDL_SetPointerPropertyWithCleanup(
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
        value: *mut ::core::ffi::c_void,
        cleanup: SDL_CleanupPropertyCallback,
        userdata: *mut ::core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set a pointer property in a group of properties.\n\n \\param props the properties to modify.\n \\param name the name of the property to modify.\n \\param value the new value of the property, or NULL to delete the property.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetPointerProperty\n \\sa SDL_HasProperty\n \\sa SDL_SetBooleanProperty\n \\sa SDL_SetFloatProperty\n \\sa SDL_SetNumberProperty\n \\sa SDL_SetPointerPropertyWithCleanup\n \\sa SDL_SetStringProperty"]
    pub fn SDL_SetPointerProperty(
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
        value: *mut ::core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set a string property in a group of properties.\n\n This function makes a copy of the string; the caller does not have to\n preserve the data after this call completes.\n\n \\param props the properties to modify.\n \\param name the name of the property to modify.\n \\param value the new value of the property, or NULL to delete the property.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetStringProperty"]
    pub fn SDL_SetStringProperty(
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set an integer property in a group of properties.\n\n \\param props the properties to modify.\n \\param name the name of the property to modify.\n \\param value the new value of the property.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetNumberProperty"]
    pub fn SDL_SetNumberProperty(
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
        value: Sint64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set a floating point property in a group of properties.\n\n \\param props the properties to modify.\n \\param name the name of the property to modify.\n \\param value the new value of the property.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetFloatProperty"]
    pub fn SDL_SetFloatProperty(
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
        value: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set a boolean property in a group of properties.\n\n \\param props the properties to modify.\n \\param name the name of the property to modify.\n \\param value the new value of the property.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetBooleanProperty"]
    pub fn SDL_SetBooleanProperty(
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
        value: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Return whether a property exists in a group of properties.\n\n \\param props the properties to query.\n \\param name the name of the property to query.\n \\returns true if the property exists, or false if it doesn't.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetPropertyType"]
    pub fn SDL_HasProperty(props: SDL_PropertiesID, name: *const ::core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the type of a property in a group of properties.\n\n \\param props the properties to query.\n \\param name the name of the property to query.\n \\returns the type of the property, or SDL_PROPERTY_TYPE_INVALID if it is\n          not set.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_HasProperty"]
    pub fn SDL_GetPropertyType(
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
    ) -> SDL_PropertyType;
}
unsafe extern "C" {
    #[doc = " Get a pointer property from a group of properties.\n\n By convention, the names of properties that SDL exposes on objects will\n start with \"SDL.\", and properties that SDL uses internally will start with\n \"SDL.internal.\". These should be considered read-only and should not be\n modified by applications.\n\n \\param props the properties to query.\n \\param name the name of the property to query.\n \\param default_value the default value of the property.\n \\returns the value of the property, or `default_value` if it is not set or\n          not a pointer property.\n\n \\threadsafety It is safe to call this function from any thread, although\n               the data returned is not protected and could potentially be\n               freed if you call SDL_SetPointerProperty() or\n               SDL_ClearProperty() on these properties from another thread.\n               If you need to avoid this, use SDL_LockProperties() and\n               SDL_UnlockProperties().\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetBooleanProperty\n \\sa SDL_GetFloatProperty\n \\sa SDL_GetNumberProperty\n \\sa SDL_GetPropertyType\n \\sa SDL_GetStringProperty\n \\sa SDL_HasProperty\n \\sa SDL_SetPointerProperty"]
    pub fn SDL_GetPointerProperty(
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
        default_value: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Get a string property from a group of properties.\n\n \\param props the properties to query.\n \\param name the name of the property to query.\n \\param default_value the default value of the property.\n \\returns the value of the property, or `default_value` if it is not set or\n          not a string property.\n\n \\threadsafety It is safe to call this function from any thread, although\n               the data returned is not protected and could potentially be\n               freed if you call SDL_SetStringProperty() or\n               SDL_ClearProperty() on these properties from another thread.\n               If you need to avoid this, use SDL_LockProperties() and\n               SDL_UnlockProperties().\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetPropertyType\n \\sa SDL_HasProperty\n \\sa SDL_SetStringProperty"]
    pub fn SDL_GetStringProperty(
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
        default_value: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get a number property from a group of properties.\n\n You can use SDL_GetPropertyType() to query whether the property exists and\n is a number property.\n\n \\param props the properties to query.\n \\param name the name of the property to query.\n \\param default_value the default value of the property.\n \\returns the value of the property, or `default_value` if it is not set or\n          not a number property.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetPropertyType\n \\sa SDL_HasProperty\n \\sa SDL_SetNumberProperty"]
    pub fn SDL_GetNumberProperty(
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
        default_value: Sint64,
    ) -> Sint64;
}
unsafe extern "C" {
    #[doc = " Get a floating point property from a group of properties.\n\n You can use SDL_GetPropertyType() to query whether the property exists and\n is a floating point property.\n\n \\param props the properties to query.\n \\param name the name of the property to query.\n \\param default_value the default value of the property.\n \\returns the value of the property, or `default_value` if it is not set or\n          not a float property.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetPropertyType\n \\sa SDL_HasProperty\n \\sa SDL_SetFloatProperty"]
    pub fn SDL_GetFloatProperty(
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
        default_value: f32,
    ) -> f32;
}
unsafe extern "C" {
    #[doc = " Get a boolean property from a group of properties.\n\n You can use SDL_GetPropertyType() to query whether the property exists and\n is a boolean property.\n\n \\param props the properties to query.\n \\param name the name of the property to query.\n \\param default_value the default value of the property.\n \\returns the value of the property, or `default_value` if it is not set or\n          not a boolean property.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetPropertyType\n \\sa SDL_HasProperty\n \\sa SDL_SetBooleanProperty"]
    pub fn SDL_GetBooleanProperty(
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
        default_value: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Clear a property from a group of properties.\n\n \\param props the properties to modify.\n \\param name the name of the property to clear.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ClearProperty(props: SDL_PropertiesID, name: *const ::core::ffi::c_char) -> bool;
}
#[doc = " A callback used to enumerate all the properties in a group of properties.\n\n This callback is called from SDL_EnumerateProperties(), and is called once\n per property in the set.\n\n \\param userdata an app-defined pointer passed to the callback.\n \\param props the SDL_PropertiesID that is being enumerated.\n \\param name the next property name in the enumeration.\n\n \\threadsafety SDL_EnumerateProperties holds a lock on `props` during this\n               callback.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_EnumerateProperties"]
pub type SDL_EnumeratePropertiesCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::core::ffi::c_void,
        props: SDL_PropertiesID,
        name: *const ::core::ffi::c_char,
    ),
>;
unsafe extern "C" {
    #[doc = " Enumerate the properties contained in a group of properties.\n\n The callback function is called for each property in the group of\n properties. The properties are locked during enumeration.\n\n \\param props the properties to query.\n \\param callback the function to call for each property.\n \\param userdata a pointer that is passed to `callback`.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_EnumerateProperties(
        props: SDL_PropertiesID,
        callback: SDL_EnumeratePropertiesCallback,
        userdata: *mut ::core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Destroy a group of properties.\n\n All properties are deleted and their cleanup functions will be called, if\n any.\n\n \\param props the properties to destroy.\n\n \\threadsafety This function should not be called while these properties are\n               locked or other threads might be setting or getting values\n               from these properties.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateProperties"]
    pub fn SDL_DestroyProperties(props: SDL_PropertiesID);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Thread {
    _unused: [u8; 0],
}
#[doc = " A unique numeric ID that identifies a thread.\n\n These are different from SDL_Thread objects, which are generally what an\n application will operate on, but having a way to uniquely identify a thread\n can be useful at times.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_GetThreadID\n \\sa SDL_GetCurrentThreadID"]
pub type SDL_ThreadID = Uint64;
#[doc = " Thread local storage ID.\n\n 0 is the invalid ID. An app can create these and then set data for these\n IDs that is unique to each thread.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_GetTLS\n \\sa SDL_SetTLS"]
pub type SDL_TLSID = SDL_AtomicInt;
pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_LOW: SDL_ThreadPriority = 0;
pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_NORMAL: SDL_ThreadPriority = 1;
pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_HIGH: SDL_ThreadPriority = 2;
pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_TIME_CRITICAL: SDL_ThreadPriority = 3;
#[doc = " The SDL thread priority.\n\n SDL will make system changes as necessary in order to apply the thread\n priority. Code which attempts to control thread state related to priority\n should be aware that calling SDL_SetCurrentThreadPriority may alter such\n state. SDL_HINT_THREAD_PRIORITY_POLICY can be used to control aspects of\n this behavior.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_ThreadPriority = ::core::ffi::c_uint;
#[doc = "< The thread is not valid"]
pub const SDL_ThreadState_SDL_THREAD_UNKNOWN: SDL_ThreadState = 0;
#[doc = "< The thread is currently running"]
pub const SDL_ThreadState_SDL_THREAD_ALIVE: SDL_ThreadState = 1;
#[doc = "< The thread is detached and can't be waited on"]
pub const SDL_ThreadState_SDL_THREAD_DETACHED: SDL_ThreadState = 2;
#[doc = "< The thread has finished and should be cleaned up with SDL_WaitThread()"]
pub const SDL_ThreadState_SDL_THREAD_COMPLETE: SDL_ThreadState = 3;
#[doc = " The SDL thread state.\n\n The current state of a thread can be checked by calling SDL_GetThreadState.\n\n \\since This enum is available since SDL 3.2.0.\n\n \\sa SDL_GetThreadState"]
pub type SDL_ThreadState = ::core::ffi::c_uint;
#[doc = " The function passed to SDL_CreateThread() as the new thread's entry point.\n\n \\param data what was passed as `data` to SDL_CreateThread().\n \\returns a value that can be reported through SDL_WaitThread().\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_ThreadFunction = ::core::option::Option<
    unsafe extern "C" fn(data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
unsafe extern "C" {
    #[doc = " The actual entry point for SDL_CreateThread.\n\n \\param fn the SDL_ThreadFunction function to call in the new thread\n \\param name the name of the thread\n \\param data a pointer that is passed to `fn`\n \\param pfnBeginThread the C runtime's _beginthreadex (or whatnot). Can be NULL.\n \\param pfnEndThread the C runtime's _endthreadex (or whatnot). Can be NULL.\n \\returns an opaque pointer to the new thread object on success, NULL if the\n          new thread could not be created; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_CreateThreadRuntime(
        fn_: SDL_ThreadFunction,
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_void,
        pfnBeginThread: SDL_FunctionPointer,
        pfnEndThread: SDL_FunctionPointer,
    ) -> *mut SDL_Thread;
}
unsafe extern "C" {
    #[doc = " The actual entry point for SDL_CreateThreadWithProperties.\n\n \\param props the properties to use\n \\param pfnBeginThread the C runtime's _beginthreadex (or whatnot). Can be NULL.\n \\param pfnEndThread the C runtime's _endthreadex (or whatnot). Can be NULL.\n \\returns an opaque pointer to the new thread object on success, NULL if the\n          new thread could not be created; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_CreateThreadWithPropertiesRuntime(
        props: SDL_PropertiesID,
        pfnBeginThread: SDL_FunctionPointer,
        pfnEndThread: SDL_FunctionPointer,
    ) -> *mut SDL_Thread;
}
unsafe extern "C" {
    #[doc = " Get the thread name as it was specified in SDL_CreateThread().\n\n \\param thread the thread to query.\n \\returns a pointer to a UTF-8 string that names the specified thread, or\n          NULL if it doesn't have a name.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetThreadName(thread: *mut SDL_Thread) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the thread identifier for the current thread.\n\n This thread identifier is as reported by the underlying operating system.\n If SDL is running on a platform that does not support threads the return\n value will always be zero.\n\n This function also returns a valid thread ID when called from the main\n thread.\n\n \\returns the ID of the current thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetThreadID"]
    pub fn SDL_GetCurrentThreadID() -> SDL_ThreadID;
}
unsafe extern "C" {
    #[doc = " Get the thread identifier for the specified thread.\n\n This thread identifier is as reported by the underlying operating system.\n If SDL is running on a platform that does not support threads the return\n value will always be zero.\n\n \\param thread the thread to query.\n \\returns the ID of the specified thread, or the ID of the current thread if\n          `thread` is NULL.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetCurrentThreadID"]
    pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> SDL_ThreadID;
}
unsafe extern "C" {
    #[doc = " Set the priority for the current thread.\n\n Note that some platforms will not let you alter the priority (or at least,\n promote the thread to a higher priority) at all, and some require you to be\n an administrator account. Be prepared for this to fail.\n\n \\param priority the SDL_ThreadPriority to set.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetCurrentThreadPriority(priority: SDL_ThreadPriority) -> bool;
}
unsafe extern "C" {
    #[doc = " Wait for a thread to finish.\n\n Threads that haven't been detached will remain until this function cleans\n them up. Not doing so is a resource leak.\n\n Once a thread has been cleaned up through this function, the SDL_Thread\n that references it becomes invalid and should not be referenced again. As\n such, only one thread may call SDL_WaitThread() on another.\n\n The return code from the thread function is placed in the area pointed to\n by `status`, if `status` is not NULL.\n\n You may not wait on a thread that has been used in a call to\n SDL_DetachThread(). Use either that function or this one, but not both, or\n behavior is undefined.\n\n It is safe to pass a NULL thread to this function; it is a no-op.\n\n Note that the thread pointer is freed by this function and is not valid\n afterward.\n\n \\param thread the SDL_Thread pointer that was returned from the\n               SDL_CreateThread() call that started this thread.\n \\param status a pointer filled in with the value returned from the thread\n               function by its 'return', or -1 if the thread has been\n               detached or isn't valid, may be NULL.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateThread\n \\sa SDL_DetachThread"]
    pub fn SDL_WaitThread(thread: *mut SDL_Thread, status: *mut ::core::ffi::c_int);
}
unsafe extern "C" {
    #[doc = " Get the current state of a thread.\n\n \\param thread the thread to query.\n \\returns the current state of a thread, or SDL_THREAD_UNKNOWN if the thread\n          isn't valid.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ThreadState"]
    pub fn SDL_GetThreadState(thread: *mut SDL_Thread) -> SDL_ThreadState;
}
unsafe extern "C" {
    #[doc = " Let a thread clean up on exit without intervention.\n\n A thread may be \"detached\" to signify that it should not remain until\n another thread has called SDL_WaitThread() on it. Detaching a thread is\n useful for long-running threads that nothing needs to synchronize with or\n further manage. When a detached thread is done, it simply goes away.\n\n There is no way to recover the return code of a detached thread. If you\n need this, don't detach the thread and instead use SDL_WaitThread().\n\n Once a thread is detached, you should usually assume the SDL_Thread isn't\n safe to reference again, as it will become invalid immediately upon the\n detached thread's exit, instead of remaining until someone has called\n SDL_WaitThread() to finally clean it up. As such, don't detach the same\n thread more than once.\n\n If a thread has already exited when passed to SDL_DetachThread(), it will\n stop waiting for a call to SDL_WaitThread() and clean up immediately. It is\n not safe to detach a thread that might be used with SDL_WaitThread().\n\n You may not call SDL_WaitThread() on a thread that has been detached. Use\n either that function or this one, but not both, or behavior is undefined.\n\n It is safe to pass NULL to this function; it is a no-op.\n\n \\param thread the SDL_Thread pointer that was returned from the\n               SDL_CreateThread() call that started this thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateThread\n \\sa SDL_WaitThread"]
    pub fn SDL_DetachThread(thread: *mut SDL_Thread);
}
unsafe extern "C" {
    #[doc = " Get the current thread's value associated with a thread local storage ID.\n\n \\param id a pointer to the thread local storage ID, may not be NULL.\n \\returns the value associated with the ID for the current thread or NULL if\n          no value has been set; call SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetTLS"]
    pub fn SDL_GetTLS(id: *mut SDL_TLSID) -> *mut ::core::ffi::c_void;
}
#[doc = " The callback used to cleanup data passed to SDL_SetTLS.\n\n This is called when a thread exits, to allow an app to free any resources.\n\n \\param value a pointer previously handed to SDL_SetTLS.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_SetTLS"]
pub type SDL_TLSDestructorCallback =
    ::core::option::Option<unsafe extern "C" fn(value: *mut ::core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = " Set the current thread's value associated with a thread local storage ID.\n\n If the thread local storage ID is not initialized (the value is 0), a new\n ID will be created in a thread-safe way, so all calls using a pointer to\n the same ID will refer to the same local storage.\n\n Note that replacing a value from a previous call to this function on the\n same thread does _not_ call the previous value's destructor!\n\n `destructor` can be NULL; it is assumed that `value` does not need to be\n cleaned up if so.\n\n \\param id a pointer to the thread local storage ID, may not be NULL.\n \\param value the value to associate with the ID for the current thread.\n \\param destructor a function called when the thread exits, to free the\n                   value, may be NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetTLS"]
    pub fn SDL_SetTLS(
        id: *mut SDL_TLSID,
        value: *const ::core::ffi::c_void,
        destructor: SDL_TLSDestructorCallback,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Cleanup all TLS data for this thread.\n\n If you are creating your threads outside of SDL and then calling SDL\n functions, you should call this function before your thread exits, to\n properly clean up SDL memory.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_CleanupTLS();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Mutex {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Create a new mutex.\n\n All newly-created mutexes begin in the _unlocked_ state.\n\n Calls to SDL_LockMutex() will not return while the mutex is locked by\n another thread. See SDL_TryLockMutex() to attempt to lock without blocking.\n\n SDL mutexes are reentrant.\n\n \\returns the initialized and unlocked mutex or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DestroyMutex\n \\sa SDL_LockMutex\n \\sa SDL_TryLockMutex\n \\sa SDL_UnlockMutex"]
    pub fn SDL_CreateMutex() -> *mut SDL_Mutex;
}
unsafe extern "C" {
    #[doc = " Lock the mutex.\n\n This will block until the mutex is available, which is to say it is in the\n unlocked state and the OS has chosen the caller as the next thread to lock\n it. Of all threads waiting to lock the mutex, only one may do so at a time.\n\n It is legal for the owning thread to lock an already-locked mutex. It must\n unlock it the same number of times before it is actually made available for\n other threads in the system (this is known as a \"recursive mutex\").\n\n This function does not fail; if mutex is NULL, it will return immediately\n having locked nothing. If the mutex is valid, this function will always\n block until it can lock the mutex, and return with it locked.\n\n \\param mutex the mutex to lock.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_TryLockMutex\n \\sa SDL_UnlockMutex"]
    pub fn SDL_LockMutex(mutex: *mut SDL_Mutex);
}
unsafe extern "C" {
    #[doc = " Try to lock a mutex without blocking.\n\n This works just like SDL_LockMutex(), but if the mutex is not available,\n this function returns false immediately.\n\n This technique is useful if you need exclusive access to a resource but\n don't want to wait for it, and will return to it to try again later.\n\n This function returns true if passed a NULL mutex.\n\n \\param mutex the mutex to try to lock.\n \\returns true on success, false if the mutex would block.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LockMutex\n \\sa SDL_UnlockMutex"]
    pub fn SDL_TryLockMutex(mutex: *mut SDL_Mutex) -> bool;
}
unsafe extern "C" {
    #[doc = " Unlock the mutex.\n\n It is legal for the owning thread to lock an already-locked mutex. It must\n unlock it the same number of times before it is actually made available for\n other threads in the system (this is known as a \"recursive mutex\").\n\n It is illegal to unlock a mutex that has not been locked by the current\n thread, and doing so results in undefined behavior.\n\n \\param mutex the mutex to unlock.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LockMutex\n \\sa SDL_TryLockMutex"]
    pub fn SDL_UnlockMutex(mutex: *mut SDL_Mutex);
}
unsafe extern "C" {
    #[doc = " Destroy a mutex created with SDL_CreateMutex().\n\n This function must be called on any mutex that is no longer needed. Failure\n to destroy a mutex will result in a system memory or resource leak. While\n it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt\n to destroy a locked mutex, and may result in undefined behavior depending\n on the platform.\n\n \\param mutex the mutex to destroy.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateMutex"]
    pub fn SDL_DestroyMutex(mutex: *mut SDL_Mutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWLock {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Create a new read/write lock.\n\n A read/write lock is useful for situations where you have multiple threads\n trying to access a resource that is rarely updated. All threads requesting\n a read-only lock will be allowed to run in parallel; if a thread requests a\n write lock, it will be provided exclusive access. This makes it safe for\n multiple threads to use a resource at the same time if they promise not to\n change it, and when it has to be changed, the rwlock will serve as a\n gateway to make sure those changes can be made safely.\n\n In the right situation, a rwlock can be more efficient than a mutex, which\n only lets a single thread proceed at a time, even if it won't be modifying\n the data.\n\n All newly-created read/write locks begin in the _unlocked_ state.\n\n Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not\n return while the rwlock is locked _for writing_ by another thread. See\n SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt\n to lock without blocking.\n\n SDL read/write locks are only recursive for read-only locks! They are not\n guaranteed to be fair, or provide access in a FIFO manner! They are not\n guaranteed to favor writers. You may not lock a rwlock for both read-only\n and write access at the same time from the same thread (so you can't\n promote your read-only lock to a write lock without unlocking first).\n\n \\returns the initialized and unlocked read/write lock or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DestroyRWLock\n \\sa SDL_LockRWLockForReading\n \\sa SDL_LockRWLockForWriting\n \\sa SDL_TryLockRWLockForReading\n \\sa SDL_TryLockRWLockForWriting\n \\sa SDL_UnlockRWLock"]
    pub fn SDL_CreateRWLock() -> *mut SDL_RWLock;
}
unsafe extern "C" {
    #[doc = " Lock the read/write lock for _read only_ operations.\n\n This will block until the rwlock is available, which is to say it is not\n locked for writing by any other thread. Of all threads waiting to lock the\n rwlock, all may do so at the same time as long as they are requesting\n read-only access; if a thread wants to lock for writing, only one may do so\n at a time, and no other threads, read-only or not, may hold the lock at the\n same time.\n\n It is legal for the owning thread to lock an already-locked rwlock for\n reading. It must unlock it the same number of times before it is actually\n made available for other threads in the system (this is known as a\n \"recursive rwlock\").\n\n Note that locking for writing is not recursive (this is only available to\n read-only locks).\n\n It is illegal to request a read-only lock from a thread that already holds\n the write lock. Doing so results in undefined behavior. Unlock the write\n lock before requesting a read-only lock. (But, of course, if you have the\n write lock, you don't need further locks to read in any case.)\n\n This function does not fail; if rwlock is NULL, it will return immediately\n having locked nothing. If the rwlock is valid, this function will always\n block until it can lock the mutex, and return with it locked.\n\n \\param rwlock the read/write lock to lock.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LockRWLockForWriting\n \\sa SDL_TryLockRWLockForReading\n \\sa SDL_UnlockRWLock"]
    pub fn SDL_LockRWLockForReading(rwlock: *mut SDL_RWLock);
}
unsafe extern "C" {
    #[doc = " Lock the read/write lock for _write_ operations.\n\n This will block until the rwlock is available, which is to say it is not\n locked for reading or writing by any other thread. Only one thread may hold\n the lock when it requests write access; all other threads, whether they\n also want to write or only want read-only access, must wait until the\n writer thread has released the lock.\n\n It is illegal for the owning thread to lock an already-locked rwlock for\n writing (read-only may be locked recursively, writing can not). Doing so\n results in undefined behavior.\n\n It is illegal to request a write lock from a thread that already holds a\n read-only lock. Doing so results in undefined behavior. Unlock the\n read-only lock before requesting a write lock.\n\n This function does not fail; if rwlock is NULL, it will return immediately\n having locked nothing. If the rwlock is valid, this function will always\n block until it can lock the mutex, and return with it locked.\n\n \\param rwlock the read/write lock to lock.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LockRWLockForReading\n \\sa SDL_TryLockRWLockForWriting\n \\sa SDL_UnlockRWLock"]
    pub fn SDL_LockRWLockForWriting(rwlock: *mut SDL_RWLock);
}
unsafe extern "C" {
    #[doc = " Try to lock a read/write lock _for reading_ without blocking.\n\n This works just like SDL_LockRWLockForReading(), but if the rwlock is not\n available, then this function returns false immediately.\n\n This technique is useful if you need access to a resource but don't want to\n wait for it, and will return to it to try again later.\n\n Trying to lock for read-only access can succeed if other threads are\n holding read-only locks, as this won't prevent access.\n\n This function returns true if passed a NULL rwlock.\n\n \\param rwlock the rwlock to try to lock.\n \\returns true on success, false if the lock would block.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LockRWLockForReading\n \\sa SDL_TryLockRWLockForWriting\n \\sa SDL_UnlockRWLock"]
    pub fn SDL_TryLockRWLockForReading(rwlock: *mut SDL_RWLock) -> bool;
}
unsafe extern "C" {
    #[doc = " Try to lock a read/write lock _for writing_ without blocking.\n\n This works just like SDL_LockRWLockForWriting(), but if the rwlock is not\n available, then this function returns false immediately.\n\n This technique is useful if you need exclusive access to a resource but\n don't want to wait for it, and will return to it to try again later.\n\n It is illegal for the owning thread to lock an already-locked rwlock for\n writing (read-only may be locked recursively, writing can not). Doing so\n results in undefined behavior.\n\n It is illegal to request a write lock from a thread that already holds a\n read-only lock. Doing so results in undefined behavior. Unlock the\n read-only lock before requesting a write lock.\n\n This function returns true if passed a NULL rwlock.\n\n \\param rwlock the rwlock to try to lock.\n \\returns true on success, false if the lock would block.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LockRWLockForWriting\n \\sa SDL_TryLockRWLockForReading\n \\sa SDL_UnlockRWLock"]
    pub fn SDL_TryLockRWLockForWriting(rwlock: *mut SDL_RWLock) -> bool;
}
unsafe extern "C" {
    #[doc = " Unlock the read/write lock.\n\n Use this function to unlock the rwlock, whether it was locked for read-only\n or write operations.\n\n It is legal for the owning thread to lock an already-locked read-only lock.\n It must unlock it the same number of times before it is actually made\n available for other threads in the system (this is known as a \"recursive\n rwlock\").\n\n It is illegal to unlock a rwlock that has not been locked by the current\n thread, and doing so results in undefined behavior.\n\n \\param rwlock the rwlock to unlock.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LockRWLockForReading\n \\sa SDL_LockRWLockForWriting\n \\sa SDL_TryLockRWLockForReading\n \\sa SDL_TryLockRWLockForWriting"]
    pub fn SDL_UnlockRWLock(rwlock: *mut SDL_RWLock);
}
unsafe extern "C" {
    #[doc = " Destroy a read/write lock created with SDL_CreateRWLock().\n\n This function must be called on any read/write lock that is no longer\n needed. Failure to destroy a rwlock will result in a system memory or\n resource leak. While it is safe to destroy a rwlock that is _unlocked_, it\n is not safe to attempt to destroy a locked rwlock, and may result in\n undefined behavior depending on the platform.\n\n \\param rwlock the rwlock to destroy.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateRWLock"]
    pub fn SDL_DestroyRWLock(rwlock: *mut SDL_RWLock);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Semaphore {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Create a semaphore.\n\n This function creates a new semaphore and initializes it with the value\n `initial_value`. Each wait operation on the semaphore will atomically\n decrement the semaphore value and potentially block if the semaphore value\n is 0. Each post operation will atomically increment the semaphore value and\n wake waiting threads and allow them to retry the wait operation.\n\n \\param initial_value the starting value of the semaphore.\n \\returns a new semaphore or NULL on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DestroySemaphore\n \\sa SDL_SignalSemaphore\n \\sa SDL_TryWaitSemaphore\n \\sa SDL_GetSemaphoreValue\n \\sa SDL_WaitSemaphore\n \\sa SDL_WaitSemaphoreTimeout"]
    pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_Semaphore;
}
unsafe extern "C" {
    #[doc = " Destroy a semaphore.\n\n It is not safe to destroy a semaphore if there are threads currently\n waiting on it.\n\n \\param sem the semaphore to destroy.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateSemaphore"]
    pub fn SDL_DestroySemaphore(sem: *mut SDL_Semaphore);
}
unsafe extern "C" {
    #[doc = " Wait until a semaphore has a positive value and then decrements it.\n\n This function suspends the calling thread until the semaphore pointed to by\n `sem` has a positive value, and then atomically decrement the semaphore\n value.\n\n This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with\n a time length of -1.\n\n \\param sem the semaphore wait on.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SignalSemaphore\n \\sa SDL_TryWaitSemaphore\n \\sa SDL_WaitSemaphoreTimeout"]
    pub fn SDL_WaitSemaphore(sem: *mut SDL_Semaphore);
}
unsafe extern "C" {
    #[doc = " See if a semaphore has a positive value and decrement it if it does.\n\n This function checks to see if the semaphore pointed to by `sem` has a\n positive value and atomically decrements the semaphore value if it does. If\n the semaphore doesn't have a positive value, the function immediately\n returns false.\n\n \\param sem the semaphore to wait on.\n \\returns true if the wait succeeds, false if the wait would block.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SignalSemaphore\n \\sa SDL_WaitSemaphore\n \\sa SDL_WaitSemaphoreTimeout"]
    pub fn SDL_TryWaitSemaphore(sem: *mut SDL_Semaphore) -> bool;
}
unsafe extern "C" {
    #[doc = " Wait until a semaphore has a positive value and then decrements it.\n\n This function suspends the calling thread until either the semaphore\n pointed to by `sem` has a positive value or the specified time has elapsed.\n If the call is successful it will atomically decrement the semaphore value.\n\n \\param sem the semaphore to wait on.\n \\param timeoutMS the length of the timeout, in milliseconds, or -1 to wait\n                  indefinitely.\n \\returns true if the wait succeeds or false if the wait times out.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SignalSemaphore\n \\sa SDL_TryWaitSemaphore\n \\sa SDL_WaitSemaphore"]
    pub fn SDL_WaitSemaphoreTimeout(sem: *mut SDL_Semaphore, timeoutMS: Sint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Atomically increment a semaphore's value and wake waiting threads.\n\n \\param sem the semaphore to increment.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_TryWaitSemaphore\n \\sa SDL_WaitSemaphore\n \\sa SDL_WaitSemaphoreTimeout"]
    pub fn SDL_SignalSemaphore(sem: *mut SDL_Semaphore);
}
unsafe extern "C" {
    #[doc = " Get the current value of a semaphore.\n\n \\param sem the semaphore to query.\n \\returns the current value of the semaphore.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSemaphoreValue(sem: *mut SDL_Semaphore) -> Uint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Condition {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Create a condition variable.\n\n \\returns a new condition variable or NULL on failure; call SDL_GetError()\n          for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BroadcastCondition\n \\sa SDL_SignalCondition\n \\sa SDL_WaitCondition\n \\sa SDL_WaitConditionTimeout\n \\sa SDL_DestroyCondition"]
    pub fn SDL_CreateCondition() -> *mut SDL_Condition;
}
unsafe extern "C" {
    #[doc = " Destroy a condition variable.\n\n \\param cond the condition variable to destroy.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateCondition"]
    pub fn SDL_DestroyCondition(cond: *mut SDL_Condition);
}
unsafe extern "C" {
    #[doc = " Restart one of the threads that are waiting on the condition variable.\n\n \\param cond the condition variable to signal.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BroadcastCondition\n \\sa SDL_WaitCondition\n \\sa SDL_WaitConditionTimeout"]
    pub fn SDL_SignalCondition(cond: *mut SDL_Condition);
}
unsafe extern "C" {
    #[doc = " Restart all threads that are waiting on the condition variable.\n\n \\param cond the condition variable to signal.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SignalCondition\n \\sa SDL_WaitCondition\n \\sa SDL_WaitConditionTimeout"]
    pub fn SDL_BroadcastCondition(cond: *mut SDL_Condition);
}
unsafe extern "C" {
    #[doc = " Wait until a condition variable is signaled.\n\n This function unlocks the specified `mutex` and waits for another thread to\n call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition\n variable `cond`. Once the condition variable is signaled, the mutex is\n re-locked and the function returns.\n\n The mutex must be locked before calling this function. Locking the mutex\n recursively (more than once) is not supported and leads to undefined\n behavior.\n\n This function is the equivalent of calling SDL_WaitConditionTimeout() with\n a time length of -1.\n\n \\param cond the condition variable to wait on.\n \\param mutex the mutex used to coordinate thread access.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BroadcastCondition\n \\sa SDL_SignalCondition\n \\sa SDL_WaitConditionTimeout"]
    pub fn SDL_WaitCondition(cond: *mut SDL_Condition, mutex: *mut SDL_Mutex);
}
unsafe extern "C" {
    #[doc = " Wait until a condition variable is signaled or a certain time has passed.\n\n This function unlocks the specified `mutex` and waits for another thread to\n call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition\n variable `cond`, or for the specified time to elapse. Once the condition\n variable is signaled or the time elapsed, the mutex is re-locked and the\n function returns.\n\n The mutex must be locked before calling this function. Locking the mutex\n recursively (more than once) is not supported and leads to undefined\n behavior.\n\n \\param cond the condition variable to wait on.\n \\param mutex the mutex used to coordinate thread access.\n \\param timeoutMS the maximum time to wait, in milliseconds, or -1 to wait\n                  indefinitely.\n \\returns true if the condition variable is signaled, false if the condition\n          is not signaled in the allotted time.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BroadcastCondition\n \\sa SDL_SignalCondition\n \\sa SDL_WaitCondition"]
    pub fn SDL_WaitConditionTimeout(
        cond: *mut SDL_Condition,
        mutex: *mut SDL_Mutex,
        timeoutMS: Sint32,
    ) -> bool;
}
pub const SDL_InitStatus_SDL_INIT_STATUS_UNINITIALIZED: SDL_InitStatus = 0;
pub const SDL_InitStatus_SDL_INIT_STATUS_INITIALIZING: SDL_InitStatus = 1;
pub const SDL_InitStatus_SDL_INIT_STATUS_INITIALIZED: SDL_InitStatus = 2;
pub const SDL_InitStatus_SDL_INIT_STATUS_UNINITIALIZING: SDL_InitStatus = 3;
#[doc = " The current status of an SDL_InitState structure.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_InitStatus = ::core::ffi::c_uint;
#[doc = " A structure used for thread-safe initialization and shutdown.\n\n Here is an example of using this:\n\n ```c\n    static SDL_AtomicInitState init;\n\n    bool InitSystem(void)\n    {\n        if (!SDL_ShouldInit(&init)) {\n            // The system is initialized\n            return true;\n        }\n\n        // At this point, you should not leave this function without calling SDL_SetInitialized()\n\n        bool initialized = DoInitTasks();\n        SDL_SetInitialized(&init, initialized);\n        return initialized;\n    }\n\n    bool UseSubsystem(void)\n    {\n        if (SDL_ShouldInit(&init)) {\n            // Error, the subsystem isn't initialized\n            SDL_SetInitialized(&init, false);\n            return false;\n        }\n\n        // Do work using the initialized subsystem\n\n        return true;\n    }\n\n    void QuitSystem(void)\n    {\n        if (!SDL_ShouldQuit(&init)) {\n            // The system is not initialized\n            return;\n        }\n\n        // At this point, you should not leave this function without calling SDL_SetInitialized()\n\n        DoQuitTasks();\n        SDL_SetInitialized(&init, false);\n    }\n ```\n\n Note that this doesn't protect any resources created during initialization,\n or guarantee that nobody is using those resources during cleanup. You\n should use other mechanisms to protect those, if that's a concern for your\n code.\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_InitState {
    pub status: SDL_AtomicInt,
    pub thread: SDL_ThreadID,
    pub reserved: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_InitState"][::core::mem::size_of::<SDL_InitState>() - 24usize];
    ["Alignment of SDL_InitState"][::core::mem::align_of::<SDL_InitState>() - 8usize];
    ["Offset of field: SDL_InitState::status"]
        [::core::mem::offset_of!(SDL_InitState, status) - 0usize];
    ["Offset of field: SDL_InitState::thread"]
        [::core::mem::offset_of!(SDL_InitState, thread) - 8usize];
    ["Offset of field: SDL_InitState::reserved"]
        [::core::mem::offset_of!(SDL_InitState, reserved) - 16usize];
};
unsafe extern "C" {
    #[doc = " Return whether initialization should be done.\n\n This function checks the passed in state and if initialization should be\n done, sets the status to `SDL_INIT_STATUS_INITIALIZING` and returns true.\n If another thread is already modifying this state, it will wait until\n that's done before returning.\n\n If this function returns true, the calling code must call\n SDL_SetInitialized() to complete the initialization.\n\n \\param state the initialization state to check.\n \\returns true if initialization needs to be done, false otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetInitialized\n \\sa SDL_ShouldQuit"]
    pub fn SDL_ShouldInit(state: *mut SDL_InitState) -> bool;
}
unsafe extern "C" {
    #[doc = " Return whether cleanup should be done.\n\n This function checks the passed in state and if cleanup should be done,\n sets the status to `SDL_INIT_STATUS_UNINITIALIZING` and returns true.\n\n If this function returns true, the calling code must call\n SDL_SetInitialized() to complete the cleanup.\n\n \\param state the initialization state to check.\n \\returns true if cleanup needs to be done, false otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetInitialized\n \\sa SDL_ShouldInit"]
    pub fn SDL_ShouldQuit(state: *mut SDL_InitState) -> bool;
}
unsafe extern "C" {
    #[doc = " Finish an initialization state transition.\n\n This function sets the status of the passed in state to\n `SDL_INIT_STATUS_INITIALIZED` or `SDL_INIT_STATUS_UNINITIALIZED` and allows\n any threads waiting for the status to proceed.\n\n \\param state the initialization state to check.\n \\param initialized the new initialization state.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ShouldInit\n \\sa SDL_ShouldQuit"]
    pub fn SDL_SetInitialized(state: *mut SDL_InitState, initialized: bool);
}
#[doc = "< Everything is ready (no errors and not EOF)."]
pub const SDL_IOStatus_SDL_IO_STATUS_READY: SDL_IOStatus = 0;
#[doc = "< Read or write I/O error"]
pub const SDL_IOStatus_SDL_IO_STATUS_ERROR: SDL_IOStatus = 1;
#[doc = "< End of file"]
pub const SDL_IOStatus_SDL_IO_STATUS_EOF: SDL_IOStatus = 2;
#[doc = "< Non blocking I/O, not ready"]
pub const SDL_IOStatus_SDL_IO_STATUS_NOT_READY: SDL_IOStatus = 3;
#[doc = "< Tried to write a read-only buffer"]
pub const SDL_IOStatus_SDL_IO_STATUS_READONLY: SDL_IOStatus = 4;
#[doc = "< Tried to read a write-only buffer"]
pub const SDL_IOStatus_SDL_IO_STATUS_WRITEONLY: SDL_IOStatus = 5;
#[doc = " SDL_IOStream status, set by a read or write operation.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_IOStatus = ::core::ffi::c_uint;
#[doc = "< Seek from the beginning of data"]
pub const SDL_IOWhence_SDL_IO_SEEK_SET: SDL_IOWhence = 0;
#[doc = "< Seek relative to current read point"]
pub const SDL_IOWhence_SDL_IO_SEEK_CUR: SDL_IOWhence = 1;
#[doc = "< Seek relative to the end of data"]
pub const SDL_IOWhence_SDL_IO_SEEK_END: SDL_IOWhence = 2;
#[doc = " Possible `whence` values for SDL_IOStream seeking.\n\n These map to the same \"whence\" concept that `fseek` or `lseek` use in the\n standard C runtime.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_IOWhence = ::core::ffi::c_uint;
#[doc = " The function pointers that drive an SDL_IOStream.\n\n Applications can provide this struct to SDL_OpenIO() to create their own\n implementation of SDL_IOStream. This is not necessarily required, as SDL\n already offers several common types of I/O streams, via functions like\n SDL_IOFromFile() and SDL_IOFromMem().\n\n This structure should be initialized using SDL_INIT_INTERFACE()\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_INIT_INTERFACE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_IOStreamInterface {
    pub version: Uint32,
    #[doc = "  Return the number of bytes in this SDL_IOStream\n\n  \\return the total size of the data stream, or -1 on error."]
    pub size:
        ::core::option::Option<unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void) -> Sint64>,
    #[doc = "  Seek to `offset` relative to `whence`, one of stdio's whence values:\n  SDL_IO_SEEK_SET, SDL_IO_SEEK_CUR, SDL_IO_SEEK_END\n\n  \\return the final offset in the data stream, or -1 on error."]
    pub seek: ::core::option::Option<
        unsafe extern "C" fn(
            userdata: *mut ::core::ffi::c_void,
            offset: Sint64,
            whence: SDL_IOWhence,
        ) -> Sint64,
    >,
    #[doc = "  Read up to `size` bytes from the data stream to the area pointed\n  at by `ptr`.\n\n  On an incomplete read, you should set `*status` to a value from the\n  SDL_IOStatus enum. You do not have to explicitly set this on\n  a complete, successful read.\n\n  \\return the number of bytes read"]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            userdata: *mut ::core::ffi::c_void,
            ptr: *mut ::core::ffi::c_void,
            size: usize,
            status: *mut SDL_IOStatus,
        ) -> usize,
    >,
    #[doc = "  Write exactly `size` bytes from the area pointed at by `ptr`\n  to data stream.\n\n  On an incomplete write, you should set `*status` to a value from the\n  SDL_IOStatus enum. You do not have to explicitly set this on\n  a complete, successful write.\n\n  \\return the number of bytes written"]
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            userdata: *mut ::core::ffi::c_void,
            ptr: *const ::core::ffi::c_void,
            size: usize,
            status: *mut SDL_IOStatus,
        ) -> usize,
    >,
    #[doc = "  If the stream is buffering, make sure the data is written out.\n\n  On failure, you should set `*status` to a value from the\n  SDL_IOStatus enum. You do not have to explicitly set this on\n  a successful flush.\n\n  \\return true if successful or false on write error when flushing data."]
    pub flush: ::core::option::Option<
        unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void, status: *mut SDL_IOStatus) -> bool,
    >,
    #[doc = "  Close and free any allocated resources.\n\n  This does not guarantee file writes will sync to physical media; they\n  can be in the system's file cache, waiting to go to disk.\n\n  The SDL_IOStream is still destroyed even if this fails, so clean up anything\n  even if flushing buffers, etc, returns an error.\n\n  \\return true if successful or false on write error when flushing data."]
    pub close:
        ::core::option::Option<unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void) -> bool>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_IOStreamInterface"][::core::mem::size_of::<SDL_IOStreamInterface>() - 56usize];
    ["Alignment of SDL_IOStreamInterface"]
        [::core::mem::align_of::<SDL_IOStreamInterface>() - 8usize];
    ["Offset of field: SDL_IOStreamInterface::version"]
        [::core::mem::offset_of!(SDL_IOStreamInterface, version) - 0usize];
    ["Offset of field: SDL_IOStreamInterface::size"]
        [::core::mem::offset_of!(SDL_IOStreamInterface, size) - 8usize];
    ["Offset of field: SDL_IOStreamInterface::seek"]
        [::core::mem::offset_of!(SDL_IOStreamInterface, seek) - 16usize];
    ["Offset of field: SDL_IOStreamInterface::read"]
        [::core::mem::offset_of!(SDL_IOStreamInterface, read) - 24usize];
    ["Offset of field: SDL_IOStreamInterface::write"]
        [::core::mem::offset_of!(SDL_IOStreamInterface, write) - 32usize];
    ["Offset of field: SDL_IOStreamInterface::flush"]
        [::core::mem::offset_of!(SDL_IOStreamInterface, flush) - 40usize];
    ["Offset of field: SDL_IOStreamInterface::close"]
        [::core::mem::offset_of!(SDL_IOStreamInterface, close) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_IOStream {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Use this function to create a new SDL_IOStream structure for reading from\n and/or writing to a named file.\n\n The `mode` string is treated roughly the same as in a call to the C\n library's fopen(), even if SDL doesn't happen to use fopen() behind the\n scenes.\n\n Available `mode` strings:\n\n - \"r\": Open a file for reading. The file must exist.\n - \"w\": Create an empty file for writing. If a file with the same name\n   already exists its content is erased and the file is treated as a new\n   empty file.\n - \"a\": Append to a file. Writing operations append data at the end of the\n   file. The file is created if it does not exist.\n - \"r+\": Open a file for update both reading and writing. The file must\n   exist.\n - \"w+\": Create an empty file for both reading and writing. If a file with\n   the same name already exists its content is erased and the file is\n   treated as a new empty file.\n - \"a+\": Open a file for reading and appending. All writing operations are\n   performed at the end of the file, protecting the previous content to be\n   overwritten. You can reposition (fseek, rewind) the internal pointer to\n   anywhere in the file for reading, but writing operations will move it\n   back to the end of file. The file is created if it does not exist.\n\n **NOTE**: In order to open a file as a binary file, a \"b\" character has to\n be included in the `mode` string. This additional \"b\" character can either\n be appended at the end of the string (thus making the following compound\n modes: \"rb\", \"wb\", \"ab\", \"r+b\", \"w+b\", \"a+b\") or be inserted between the\n letter and the \"+\" sign for the mixed modes (\"rb+\", \"wb+\", \"ab+\").\n Additional characters may follow the sequence, although they should have no\n effect. For example, \"t\" is sometimes appended to make explicit the file is\n a text file.\n\n This function supports Unicode filenames, but they must be encoded in UTF-8\n format, regardless of the underlying operating system.\n\n In Android, SDL_IOFromFile() can be used to open content:// URIs. As a\n fallback, SDL_IOFromFile() will transparently open a matching filename in\n the app's `assets`.\n\n Closing the SDL_IOStream will close SDL's internal file handle.\n\n The following properties may be set at creation time by SDL:\n\n - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast\n   to a win32 `HANDLE`, that this SDL_IOStream is using to access the\n   filesystem. If the program isn't running on Windows, or SDL used some\n   other method to access the filesystem, this property will not be set.\n - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a\n   stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.\n   If SDL used some other method to access the filesystem, this property\n   will not be set. PLEASE NOTE that if SDL is using a different C runtime\n   than your app, trying to use this pointer will almost certainly result in\n   a crash! This is mostly a problem on Windows; make sure you build SDL and\n   your app with the same compiler and settings to avoid it.\n - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this\n   SDL_IOStream is using to access the filesystem.\n - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast\n   to an Android NDK `AAsset *`, that this SDL_IOStream is using to access\n   the filesystem. If SDL used some other method to access the filesystem,\n   this property will not be set.\n\n \\param file a UTF-8 string representing the filename to open.\n \\param mode an ASCII string representing the mode to be used for opening\n             the file.\n \\returns a pointer to the SDL_IOStream structure that is created or NULL on\n          failure; call SDL_GetError() for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CloseIO\n \\sa SDL_FlushIO\n \\sa SDL_ReadIO\n \\sa SDL_SeekIO\n \\sa SDL_TellIO\n \\sa SDL_WriteIO"]
    pub fn SDL_IOFromFile(
        file: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
    ) -> *mut SDL_IOStream;
}
unsafe extern "C" {
    #[doc = " Use this function to prepare a read-write memory buffer for use with\n SDL_IOStream.\n\n This function sets up an SDL_IOStream struct based on a memory area of a\n certain size, for both read and write access.\n\n This memory buffer is not copied by the SDL_IOStream; the pointer you\n provide must remain valid until you close the stream. Closing the stream\n will not free the original buffer.\n\n If you need to make sure the SDL_IOStream never writes to the memory\n buffer, you should use SDL_IOFromConstMem() with a read-only buffer of\n memory instead.\n\n The following properties will be set at creation time by SDL:\n\n - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that\n   was passed to this function.\n - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter\n   that was passed to this function.\n\n \\param mem a pointer to a buffer to feed an SDL_IOStream stream.\n \\param size the buffer size, in bytes.\n \\returns a pointer to a new SDL_IOStream structure or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_IOFromConstMem\n \\sa SDL_CloseIO\n \\sa SDL_FlushIO\n \\sa SDL_ReadIO\n \\sa SDL_SeekIO\n \\sa SDL_TellIO\n \\sa SDL_WriteIO"]
    pub fn SDL_IOFromMem(mem: *mut ::core::ffi::c_void, size: usize) -> *mut SDL_IOStream;
}
unsafe extern "C" {
    #[doc = " Use this function to prepare a read-only memory buffer for use with\n SDL_IOStream.\n\n This function sets up an SDL_IOStream struct based on a memory area of a\n certain size. It assumes the memory area is not writable.\n\n Attempting to write to this SDL_IOStream stream will report an error\n without writing to the memory buffer.\n\n This memory buffer is not copied by the SDL_IOStream; the pointer you\n provide must remain valid until you close the stream. Closing the stream\n will not free the original buffer.\n\n If you need to write to a memory buffer, you should use SDL_IOFromMem()\n with a writable buffer of memory instead.\n\n The following properties will be set at creation time by SDL:\n\n - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that\n   was passed to this function.\n - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter\n   that was passed to this function.\n\n \\param mem a pointer to a read-only buffer to feed an SDL_IOStream stream.\n \\param size the buffer size, in bytes.\n \\returns a pointer to a new SDL_IOStream structure or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_IOFromMem\n \\sa SDL_CloseIO\n \\sa SDL_ReadIO\n \\sa SDL_SeekIO\n \\sa SDL_TellIO"]
    pub fn SDL_IOFromConstMem(mem: *const ::core::ffi::c_void, size: usize) -> *mut SDL_IOStream;
}
unsafe extern "C" {
    #[doc = " Use this function to create an SDL_IOStream that is backed by dynamically\n allocated memory.\n\n This supports the following properties to provide access to the memory and\n control over allocations:\n\n - `SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER`: a pointer to the internal\n   memory of the stream. This can be set to NULL to transfer ownership of\n   the memory to the application, which should free the memory with\n   SDL_free(). If this is done, the next operation on the stream must be\n   SDL_CloseIO().\n - `SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER`: memory will be allocated in\n   multiples of this size, defaulting to 1024.\n\n \\returns a pointer to a new SDL_IOStream structure or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CloseIO\n \\sa SDL_ReadIO\n \\sa SDL_SeekIO\n \\sa SDL_TellIO\n \\sa SDL_WriteIO"]
    pub fn SDL_IOFromDynamicMem() -> *mut SDL_IOStream;
}
unsafe extern "C" {
    #[doc = " Create a custom SDL_IOStream.\n\n Applications do not need to use this function unless they are providing\n their own SDL_IOStream implementation. If you just need an SDL_IOStream to\n read/write a common data source, you should use the built-in\n implementations in SDL, like SDL_IOFromFile() or SDL_IOFromMem(), etc.\n\n This function makes a copy of `iface` and the caller does not need to keep\n it around after this call.\n\n \\param iface the interface that implements this SDL_IOStream, initialized\n              using SDL_INIT_INTERFACE().\n \\param userdata the pointer that will be passed to the interface functions.\n \\returns a pointer to the allocated memory on success or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CloseIO\n \\sa SDL_INIT_INTERFACE\n \\sa SDL_IOFromConstMem\n \\sa SDL_IOFromFile\n \\sa SDL_IOFromMem"]
    pub fn SDL_OpenIO(
        iface: *const SDL_IOStreamInterface,
        userdata: *mut ::core::ffi::c_void,
    ) -> *mut SDL_IOStream;
}
unsafe extern "C" {
    #[doc = " Close and free an allocated SDL_IOStream structure.\n\n SDL_CloseIO() closes and cleans up the SDL_IOStream stream. It releases any\n resources used by the stream and frees the SDL_IOStream itself. This\n returns true on success, or false if the stream failed to flush to its\n output (e.g. to disk).\n\n Note that if this fails to flush the stream for any reason, this function\n reports an error, but the SDL_IOStream is still invalid once this function\n returns.\n\n This call flushes any buffered writes to the operating system, but there\n are no guarantees that those writes have gone to physical media; they might\n be in the OS's file cache, waiting to go to disk later. If it's absolutely\n crucial that writes go to disk immediately, so they are definitely stored\n even if the power fails before the file cache would have caught up, one\n should call SDL_FlushIO() before closing. Note that flushing takes time and\n makes the system and your app operate less efficiently, so do so sparingly.\n\n \\param context SDL_IOStream structure to close.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_OpenIO"]
    pub fn SDL_CloseIO(context: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the properties associated with an SDL_IOStream.\n\n \\param context a pointer to an SDL_IOStream structure.\n \\returns a valid property ID on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetIOProperties(context: *mut SDL_IOStream) -> SDL_PropertiesID;
}
unsafe extern "C" {
    #[doc = " Query the stream status of an SDL_IOStream.\n\n This information can be useful to decide if a short read or write was due\n to an error, an EOF, or a non-blocking operation that isn't yet ready to\n complete.\n\n An SDL_IOStream's status is only expected to change after a SDL_ReadIO or\n SDL_WriteIO call; don't expect it to change if you just call this query\n function in a tight loop.\n\n \\param context the SDL_IOStream to query.\n \\returns an SDL_IOStatus enum with the current state.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetIOStatus(context: *mut SDL_IOStream) -> SDL_IOStatus;
}
unsafe extern "C" {
    #[doc = " Use this function to get the size of the data stream in an SDL_IOStream.\n\n \\param context the SDL_IOStream to get the size of the data stream from.\n \\returns the size of the data stream in the SDL_IOStream on success or a\n          negative error code on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetIOSize(context: *mut SDL_IOStream) -> Sint64;
}
unsafe extern "C" {
    #[doc = " Seek within an SDL_IOStream data stream.\n\n This function seeks to byte `offset`, relative to `whence`.\n\n `whence` may be any of the following values:\n\n - `SDL_IO_SEEK_SET`: seek from the beginning of data\n - `SDL_IO_SEEK_CUR`: seek relative to current read point\n - `SDL_IO_SEEK_END`: seek relative to the end of data\n\n If this stream can not seek, it will return -1.\n\n \\param context a pointer to an SDL_IOStream structure.\n \\param offset an offset in bytes, relative to `whence` location; can be\n               negative.\n \\param whence any of `SDL_IO_SEEK_SET`, `SDL_IO_SEEK_CUR`,\n               `SDL_IO_SEEK_END`.\n \\returns the final offset in the data stream after the seek or -1 on\n          failure; call SDL_GetError() for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_TellIO"]
    pub fn SDL_SeekIO(context: *mut SDL_IOStream, offset: Sint64, whence: SDL_IOWhence) -> Sint64;
}
unsafe extern "C" {
    #[doc = " Determine the current read/write offset in an SDL_IOStream data stream.\n\n SDL_TellIO is actually a wrapper function that calls the SDL_IOStream's\n `seek` method, with an offset of 0 bytes from `SDL_IO_SEEK_CUR`, to\n simplify application development.\n\n \\param context an SDL_IOStream data stream object from which to get the\n                current offset.\n \\returns the current offset in the stream, or -1 if the information can not\n          be determined.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SeekIO"]
    pub fn SDL_TellIO(context: *mut SDL_IOStream) -> Sint64;
}
unsafe extern "C" {
    #[doc = " Read from a data source.\n\n This function reads up `size` bytes from the data source to the area\n pointed at by `ptr`. This function may read less bytes than requested.\n\n This function will return zero when the data stream is completely read, and\n SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If zero is returned and\n the stream is not at EOF, SDL_GetIOStatus() will return a different error\n value and SDL_GetError() will offer a human-readable message.\n\n \\param context a pointer to an SDL_IOStream structure.\n \\param ptr a pointer to a buffer to read data into.\n \\param size the number of bytes to read from the data source.\n \\returns the number of bytes read, or 0 on end of file or other failure;\n          call SDL_GetError() for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_WriteIO\n \\sa SDL_GetIOStatus"]
    pub fn SDL_ReadIO(
        context: *mut SDL_IOStream,
        ptr: *mut ::core::ffi::c_void,
        size: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Write to an SDL_IOStream data stream.\n\n This function writes exactly `size` bytes from the area pointed at by `ptr`\n to the stream. If this fails for any reason, it'll return less than `size`\n to demonstrate how far the write progressed. On success, it returns `size`.\n\n On error, this function still attempts to write as much as possible, so it\n might return a positive value less than the requested write size.\n\n The caller can use SDL_GetIOStatus() to determine if the problem is\n recoverable, such as a non-blocking write that can simply be retried later,\n or a fatal error.\n\n \\param context a pointer to an SDL_IOStream structure.\n \\param ptr a pointer to a buffer containing data to write.\n \\param size the number of bytes to write.\n \\returns the number of bytes written, which will be less than `size` on\n          failure; call SDL_GetError() for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_IOprintf\n \\sa SDL_ReadIO\n \\sa SDL_SeekIO\n \\sa SDL_FlushIO\n \\sa SDL_GetIOStatus"]
    pub fn SDL_WriteIO(
        context: *mut SDL_IOStream,
        ptr: *const ::core::ffi::c_void,
        size: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Print to an SDL_IOStream data stream.\n\n This function does formatted printing to the stream.\n\n \\param context a pointer to an SDL_IOStream structure.\n \\param fmt a printf() style format string.\n \\param ... additional parameters matching % tokens in the `fmt` string, if\n            any.\n \\returns the number of bytes written or 0 on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_IOvprintf\n \\sa SDL_WriteIO"]
    pub fn SDL_IOprintf(context: *mut SDL_IOStream, fmt: *const ::core::ffi::c_char, ...) -> usize;
}
unsafe extern "C" {
    #[doc = " Print to an SDL_IOStream data stream.\n\n This function does formatted printing to the stream.\n\n \\param context a pointer to an SDL_IOStream structure.\n \\param fmt a printf() style format string.\n \\param ap a variable argument list.\n \\returns the number of bytes written or 0 on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_IOprintf\n \\sa SDL_WriteIO"]
    pub fn SDL_IOvprintf(
        context: *mut SDL_IOStream,
        fmt: *const ::core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Flush any buffered data in the stream.\n\n This function makes sure that any buffered data is written to the stream.\n Normally this isn't necessary but if the stream is a pipe or socket it\n guarantees that any pending data is sent.\n\n \\param context SDL_IOStream structure to flush.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_OpenIO\n \\sa SDL_WriteIO"]
    pub fn SDL_FlushIO(context: *mut SDL_IOStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Load all the data from an SDL data stream.\n\n The data is allocated with a zero byte at the end (null terminated) for\n convenience. This extra byte is not included in the value reported via\n `datasize`.\n\n The data should be freed with SDL_free().\n\n \\param src the SDL_IOStream to read all available data from.\n \\param datasize a pointer filled in with the number of bytes read, may be\n                 NULL.\n \\param closeio if true, calls SDL_CloseIO() on `src` before returning, even\n                in the case of an error.\n \\returns the data or NULL on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LoadFile\n \\sa SDL_SaveFile_IO"]
    pub fn SDL_LoadFile_IO(
        src: *mut SDL_IOStream,
        datasize: *mut usize,
        closeio: bool,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Load all the data from a file path.\n\n The data is allocated with a zero byte at the end (null terminated) for\n convenience. This extra byte is not included in the value reported via\n `datasize`.\n\n The data should be freed with SDL_free().\n\n \\param file the path to read all available data from.\n \\param datasize if not NULL, will store the number of bytes read.\n \\returns the data or NULL on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LoadFile_IO\n \\sa SDL_SaveFile"]
    pub fn SDL_LoadFile(
        file: *const ::core::ffi::c_char,
        datasize: *mut usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Save all the data into an SDL data stream.\n\n \\param src the SDL_IOStream to write all data to.\n \\param data the data to be written. If datasize is 0, may be NULL or a\n             invalid pointer.\n \\param datasize the number of bytes to be written.\n \\param closeio if true, calls SDL_CloseIO() on `src` before returning, even\n                in the case of an error.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SaveFile\n \\sa SDL_LoadFile_IO"]
    pub fn SDL_SaveFile_IO(
        src: *mut SDL_IOStream,
        data: *const ::core::ffi::c_void,
        datasize: usize,
        closeio: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Save all the data into a file path.\n\n \\param file the path to write all available data into.\n \\param data the data to be written. If datasize is 0, may be NULL or a\n             invalid pointer.\n \\param datasize the number of bytes to be written.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SaveFile_IO\n \\sa SDL_LoadFile"]
    pub fn SDL_SaveFile(
        file: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_void,
        datasize: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read a byte from an SDL_IOStream.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the SDL_IOStream to read from.\n \\param value a pointer filled in with the data read.\n \\returns true on success or false on failure or EOF; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadU8(src: *mut SDL_IOStream, value: *mut Uint8) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read a signed byte from an SDL_IOStream.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the SDL_IOStream to read from.\n \\param value a pointer filled in with the data read.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadS8(src: *mut SDL_IOStream, value: *mut Sint8) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read 16 bits of little-endian data from an\n SDL_IOStream and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the stream from which to read data.\n \\param value a pointer filled in with the data read.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadU16LE(src: *mut SDL_IOStream, value: *mut Uint16) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read 16 bits of little-endian data from an\n SDL_IOStream and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the stream from which to read data.\n \\param value a pointer filled in with the data read.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadS16LE(src: *mut SDL_IOStream, value: *mut Sint16) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read 16 bits of big-endian data from an SDL_IOStream\n and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the stream from which to read data.\n \\param value a pointer filled in with the data read.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadU16BE(src: *mut SDL_IOStream, value: *mut Uint16) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read 16 bits of big-endian data from an SDL_IOStream\n and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the stream from which to read data.\n \\param value a pointer filled in with the data read.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadS16BE(src: *mut SDL_IOStream, value: *mut Sint16) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read 32 bits of little-endian data from an\n SDL_IOStream and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the stream from which to read data.\n \\param value a pointer filled in with the data read.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadU32LE(src: *mut SDL_IOStream, value: *mut Uint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read 32 bits of little-endian data from an\n SDL_IOStream and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the stream from which to read data.\n \\param value a pointer filled in with the data read.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadS32LE(src: *mut SDL_IOStream, value: *mut Sint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read 32 bits of big-endian data from an SDL_IOStream\n and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the stream from which to read data.\n \\param value a pointer filled in with the data read.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadU32BE(src: *mut SDL_IOStream, value: *mut Uint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read 32 bits of big-endian data from an SDL_IOStream\n and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the stream from which to read data.\n \\param value a pointer filled in with the data read.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadS32BE(src: *mut SDL_IOStream, value: *mut Sint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read 64 bits of little-endian data from an\n SDL_IOStream and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the stream from which to read data.\n \\param value a pointer filled in with the data read.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadU64LE(src: *mut SDL_IOStream, value: *mut Uint64) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read 64 bits of little-endian data from an\n SDL_IOStream and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the stream from which to read data.\n \\param value a pointer filled in with the data read.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadS64LE(src: *mut SDL_IOStream, value: *mut Sint64) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read 64 bits of big-endian data from an SDL_IOStream\n and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the stream from which to read data.\n \\param value a pointer filled in with the data read.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadU64BE(src: *mut SDL_IOStream, value: *mut Uint64) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to read 64 bits of big-endian data from an SDL_IOStream\n and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n This function will return false when the data stream is completely read,\n and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned\n and the stream is not at EOF, SDL_GetIOStatus() will return a different\n error value and SDL_GetError() will offer a human-readable message.\n\n \\param src the stream from which to read data.\n \\param value a pointer filled in with the data read.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadS64BE(src: *mut SDL_IOStream, value: *mut Sint64) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write a byte to an SDL_IOStream.\n\n \\param dst the SDL_IOStream to write to.\n \\param value the byte value to write.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteU8(dst: *mut SDL_IOStream, value: Uint8) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write a signed byte to an SDL_IOStream.\n\n \\param dst the SDL_IOStream to write to.\n \\param value the byte value to write.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteS8(dst: *mut SDL_IOStream, value: Sint8) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write 16 bits in native format to an SDL_IOStream as\n little-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in little-endian\n format.\n\n \\param dst the stream to which data will be written.\n \\param value the data to be written, in native format.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteU16LE(dst: *mut SDL_IOStream, value: Uint16) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write 16 bits in native format to an SDL_IOStream as\n little-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in little-endian\n format.\n\n \\param dst the stream to which data will be written.\n \\param value the data to be written, in native format.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteS16LE(dst: *mut SDL_IOStream, value: Sint16) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write 16 bits in native format to an SDL_IOStream as\n big-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in big-endian format.\n\n \\param dst the stream to which data will be written.\n \\param value the data to be written, in native format.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteU16BE(dst: *mut SDL_IOStream, value: Uint16) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write 16 bits in native format to an SDL_IOStream as\n big-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in big-endian format.\n\n \\param dst the stream to which data will be written.\n \\param value the data to be written, in native format.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteS16BE(dst: *mut SDL_IOStream, value: Sint16) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write 32 bits in native format to an SDL_IOStream as\n little-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in little-endian\n format.\n\n \\param dst the stream to which data will be written.\n \\param value the data to be written, in native format.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteU32LE(dst: *mut SDL_IOStream, value: Uint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write 32 bits in native format to an SDL_IOStream as\n little-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in little-endian\n format.\n\n \\param dst the stream to which data will be written.\n \\param value the data to be written, in native format.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteS32LE(dst: *mut SDL_IOStream, value: Sint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write 32 bits in native format to an SDL_IOStream as\n big-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in big-endian format.\n\n \\param dst the stream to which data will be written.\n \\param value the data to be written, in native format.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteU32BE(dst: *mut SDL_IOStream, value: Uint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write 32 bits in native format to an SDL_IOStream as\n big-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in big-endian format.\n\n \\param dst the stream to which data will be written.\n \\param value the data to be written, in native format.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteS32BE(dst: *mut SDL_IOStream, value: Sint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write 64 bits in native format to an SDL_IOStream as\n little-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in little-endian\n format.\n\n \\param dst the stream to which data will be written.\n \\param value the data to be written, in native format.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteU64LE(dst: *mut SDL_IOStream, value: Uint64) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write 64 bits in native format to an SDL_IOStream as\n little-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in little-endian\n format.\n\n \\param dst the stream to which data will be written.\n \\param value the data to be written, in native format.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteS64LE(dst: *mut SDL_IOStream, value: Sint64) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write 64 bits in native format to an SDL_IOStream as\n big-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in big-endian format.\n\n \\param dst the stream to which data will be written.\n \\param value the data to be written, in native format.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteU64BE(dst: *mut SDL_IOStream, value: Uint64) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to write 64 bits in native format to an SDL_IOStream as\n big-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in big-endian format.\n\n \\param dst the stream to which data will be written.\n \\param value the data to be written, in native format.\n \\returns true on successful write or false on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteS64BE(dst: *mut SDL_IOStream, value: Sint64) -> bool;
}
#[doc = "< Unspecified audio format"]
pub const SDL_AudioFormat_SDL_AUDIO_UNKNOWN: SDL_AudioFormat = 0;
#[doc = "< Unsigned 8-bit samples"]
pub const SDL_AudioFormat_SDL_AUDIO_U8: SDL_AudioFormat = 8;
#[doc = "< Signed 8-bit samples"]
pub const SDL_AudioFormat_SDL_AUDIO_S8: SDL_AudioFormat = 32776;
#[doc = "< Signed 16-bit samples"]
pub const SDL_AudioFormat_SDL_AUDIO_S16LE: SDL_AudioFormat = 32784;
#[doc = "< As above, but big-endian byte order"]
pub const SDL_AudioFormat_SDL_AUDIO_S16BE: SDL_AudioFormat = 36880;
#[doc = "< 32-bit integer samples"]
pub const SDL_AudioFormat_SDL_AUDIO_S32LE: SDL_AudioFormat = 32800;
#[doc = "< As above, but big-endian byte order"]
pub const SDL_AudioFormat_SDL_AUDIO_S32BE: SDL_AudioFormat = 36896;
#[doc = "< 32-bit floating point samples"]
pub const SDL_AudioFormat_SDL_AUDIO_F32LE: SDL_AudioFormat = 33056;
#[doc = "< As above, but big-endian byte order"]
pub const SDL_AudioFormat_SDL_AUDIO_F32BE: SDL_AudioFormat = 37152;
pub const SDL_AudioFormat_SDL_AUDIO_S16: SDL_AudioFormat = 32784;
pub const SDL_AudioFormat_SDL_AUDIO_S32: SDL_AudioFormat = 32800;
pub const SDL_AudioFormat_SDL_AUDIO_F32: SDL_AudioFormat = 33056;
#[doc = " Audio format.\n\n \\since This enum is available since SDL 3.2.0.\n\n \\sa SDL_AUDIO_BITSIZE\n \\sa SDL_AUDIO_BYTESIZE\n \\sa SDL_AUDIO_ISINT\n \\sa SDL_AUDIO_ISFLOAT\n \\sa SDL_AUDIO_ISBIGENDIAN\n \\sa SDL_AUDIO_ISLITTLEENDIAN\n \\sa SDL_AUDIO_ISSIGNED\n \\sa SDL_AUDIO_ISUNSIGNED"]
pub type SDL_AudioFormat = ::core::ffi::c_uint;
#[doc = " SDL Audio Device instance IDs.\n\n Zero is used to signify an invalid/null device.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_AudioDeviceID = Uint32;
#[doc = " Format specifier for audio data.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_AudioFormat"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AudioSpec {
    #[doc = "< Audio data format"]
    pub format: SDL_AudioFormat,
    #[doc = "< Number of channels: 1 mono, 2 stereo, etc"]
    pub channels: ::core::ffi::c_int,
    #[doc = "< sample rate: sample frames per second"]
    pub freq: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_AudioSpec"][::core::mem::size_of::<SDL_AudioSpec>() - 12usize];
    ["Alignment of SDL_AudioSpec"][::core::mem::align_of::<SDL_AudioSpec>() - 4usize];
    ["Offset of field: SDL_AudioSpec::format"]
        [::core::mem::offset_of!(SDL_AudioSpec, format) - 0usize];
    ["Offset of field: SDL_AudioSpec::channels"]
        [::core::mem::offset_of!(SDL_AudioSpec, channels) - 4usize];
    ["Offset of field: SDL_AudioSpec::freq"][::core::mem::offset_of!(SDL_AudioSpec, freq) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AudioStream {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Use this function to get the number of built-in audio drivers.\n\n This function returns a hardcoded number. This never returns a negative\n value; if there are no drivers compiled into this build of SDL, this\n function returns zero. The presence of a driver in this list does not mean\n it will function, it just means SDL is capable of interacting with that\n interface. For example, a build of SDL might have esound support, but if\n there's no esound server available, SDL's esound driver would fail if used.\n\n By default, SDL tries all drivers, in its preferred order, until one is\n found to be usable.\n\n \\returns the number of built-in audio drivers.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAudioDriver"]
    pub fn SDL_GetNumAudioDrivers() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Use this function to get the name of a built in audio driver.\n\n The list of audio drivers is given in the order that they are normally\n initialized by default; the drivers that seem more reasonable to choose\n first (as far as the SDL developers believe) are earlier in the list.\n\n The names of drivers are all simple, low-ASCII identifiers, like \"alsa\",\n \"coreaudio\" or \"wasapi\". These never have Unicode characters, and are not\n meant to be proper names.\n\n \\param index the index of the audio driver; the value ranges from 0 to\n              SDL_GetNumAudioDrivers() - 1.\n \\returns the name of the audio driver at the requested index, or NULL if an\n          invalid index was specified.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetNumAudioDrivers"]
    pub fn SDL_GetAudioDriver(index: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the current audio driver.\n\n The names of drivers are all simple, low-ASCII identifiers, like \"alsa\",\n \"coreaudio\" or \"wasapi\". These never have Unicode characters, and are not\n meant to be proper names.\n\n \\returns the name of the current audio driver or NULL if no driver has been\n          initialized.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetCurrentAudioDriver() -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get a list of currently-connected audio playback devices.\n\n This returns of list of available devices that play sound, perhaps to\n speakers or headphones (\"playback\" devices). If you want devices that\n record audio, like a microphone (\"recording\" devices), use\n SDL_GetAudioRecordingDevices() instead.\n\n This only returns a list of physical devices; it will not have any device\n IDs returned by SDL_OpenAudioDevice().\n\n If this function returns NULL, to signify an error, `*count` will be set to\n zero.\n\n \\param count a pointer filled in with the number of devices returned, may\n              be NULL.\n \\returns a 0 terminated array of device instance IDs or NULL on error; call\n          SDL_GetError() for more information. This should be freed with\n          SDL_free() when it is no longer needed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_OpenAudioDevice\n \\sa SDL_GetAudioRecordingDevices"]
    pub fn SDL_GetAudioPlaybackDevices(count: *mut ::core::ffi::c_int) -> *mut SDL_AudioDeviceID;
}
unsafe extern "C" {
    #[doc = " Get a list of currently-connected audio recording devices.\n\n This returns of list of available devices that record audio, like a\n microphone (\"recording\" devices). If you want devices that play sound,\n perhaps to speakers or headphones (\"playback\" devices), use\n SDL_GetAudioPlaybackDevices() instead.\n\n This only returns a list of physical devices; it will not have any device\n IDs returned by SDL_OpenAudioDevice().\n\n If this function returns NULL, to signify an error, `*count` will be set to\n zero.\n\n \\param count a pointer filled in with the number of devices returned, may\n              be NULL.\n \\returns a 0 terminated array of device instance IDs, or NULL on failure;\n          call SDL_GetError() for more information. This should be freed\n          with SDL_free() when it is no longer needed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_OpenAudioDevice\n \\sa SDL_GetAudioPlaybackDevices"]
    pub fn SDL_GetAudioRecordingDevices(count: *mut ::core::ffi::c_int) -> *mut SDL_AudioDeviceID;
}
unsafe extern "C" {
    #[doc = " Get the human-readable name of a specific audio device.\n\n \\param devid the instance ID of the device to query.\n \\returns the name of the audio device, or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAudioPlaybackDevices\n \\sa SDL_GetAudioRecordingDevices"]
    pub fn SDL_GetAudioDeviceName(devid: SDL_AudioDeviceID) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the current audio format of a specific audio device.\n\n For an opened device, this will report the format the device is currently\n using. If the device isn't yet opened, this will report the device's\n preferred format (or a reasonable default if this can't be determined).\n\n You may also specify SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or\n SDL_AUDIO_DEVICE_DEFAULT_RECORDING here, which is useful for getting a\n reasonable recommendation before opening the system-recommended default\n device.\n\n You can also use this to request the current device buffer size. This is\n specified in sample frames and represents the amount of data SDL will feed\n to the physical hardware in each chunk. This can be converted to\n milliseconds of audio with the following equation:\n\n `ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`\n\n Buffer size is only important if you need low-level control over the audio\n playback timing. Most apps do not need this.\n\n \\param devid the instance ID of the device to query.\n \\param spec on return, will be filled with device details.\n \\param sample_frames pointer to store device buffer size, in sample frames.\n                      Can be NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetAudioDeviceFormat(
        devid: SDL_AudioDeviceID,
        spec: *mut SDL_AudioSpec,
        sample_frames: *mut ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the current channel map of an audio device.\n\n Channel maps are optional; most things do not need them, instead passing\n data in the [order that SDL expects](CategoryAudio#channel-layouts).\n\n Audio devices usually have no remapping applied. This is represented by\n returning NULL, and does not signify an error.\n\n \\param devid the instance ID of the device to query.\n \\param count On output, set to number of channels in the map. Can be NULL.\n \\returns an array of the current channel mapping, with as many elements as\n          the current output spec's channels, or NULL if default. This\n          should be freed with SDL_free() when it is no longer needed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioStreamInputChannelMap"]
    pub fn SDL_GetAudioDeviceChannelMap(
        devid: SDL_AudioDeviceID,
        count: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Open a specific audio device.\n\n You can open both playback and recording devices through this function.\n Playback devices will take data from bound audio streams, mix it, and send\n it to the hardware. Recording devices will feed any bound audio streams\n with a copy of any incoming data.\n\n An opened audio device starts out with no audio streams bound. To start\n audio playing, bind a stream and supply audio data to it. Unlike SDL2,\n there is no audio callback; you only bind audio streams and make sure they\n have data flowing into them (however, you can simulate SDL2's semantics\n fairly closely by using SDL_OpenAudioDeviceStream instead of this\n function).\n\n If you don't care about opening a specific device, pass a `devid` of either\n `SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK` or\n `SDL_AUDIO_DEVICE_DEFAULT_RECORDING`. In this case, SDL will try to pick\n the most reasonable default, and may also switch between physical devices\n seamlessly later, if the most reasonable default changes during the\n lifetime of this opened device (user changed the default in the OS's system\n preferences, the default got unplugged so the system jumped to a new\n default, the user plugged in headphones on a mobile device, etc). Unless\n you have a good reason to choose a specific device, this is probably what\n you want.\n\n You may request a specific format for the audio device, but there is no\n promise the device will honor that request for several reasons. As such,\n it's only meant to be a hint as to what data your app will provide. Audio\n streams will accept data in whatever format you specify and manage\n conversion for you as appropriate. SDL_GetAudioDeviceFormat can tell you\n the preferred format for the device before opening and the actual format\n the device is using after opening.\n\n It's legal to open the same device ID more than once; each successful open\n will generate a new logical SDL_AudioDeviceID that is managed separately\n from others on the same physical device. This allows libraries to open a\n device separately from the main app and bind its own streams without\n conflicting.\n\n It is also legal to open a device ID returned by a previous call to this\n function; doing so just creates another logical device on the same physical\n device. This may be useful for making logical groupings of audio streams.\n\n This function returns the opened device ID on success. This is a new,\n unique SDL_AudioDeviceID that represents a logical device.\n\n Some backends might offer arbitrary devices (for example, a networked audio\n protocol that can connect to an arbitrary server). For these, as a change\n from SDL2, you should open a default device ID and use an SDL hint to\n specify the target if you care, or otherwise let the backend figure out a\n reasonable default. Most backends don't offer anything like this, and often\n this would be an end user setting an environment variable for their custom\n need, and not something an application should specifically manage.\n\n When done with an audio device, possibly at the end of the app's life, one\n should call SDL_CloseAudioDevice() on the returned device id.\n\n \\param devid the device instance id to open, or\n              SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or\n              SDL_AUDIO_DEVICE_DEFAULT_RECORDING for the most reasonable\n              default device.\n \\param spec the requested device configuration. Can be NULL to use\n             reasonable defaults.\n \\returns the device ID on success or 0 on failure; call SDL_GetError() for\n          more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CloseAudioDevice\n \\sa SDL_GetAudioDeviceFormat"]
    pub fn SDL_OpenAudioDevice(
        devid: SDL_AudioDeviceID,
        spec: *const SDL_AudioSpec,
    ) -> SDL_AudioDeviceID;
}
unsafe extern "C" {
    #[doc = " Determine if an audio device is physical (instead of logical).\n\n An SDL_AudioDeviceID that represents physical hardware is a physical\n device; there is one for each piece of hardware that SDL can see. Logical\n devices are created by calling SDL_OpenAudioDevice or\n SDL_OpenAudioDeviceStream, and while each is associated with a physical\n device, there can be any number of logical devices on one physical device.\n\n For the most part, logical and physical IDs are interchangeable--if you try\n to open a logical device, SDL understands to assign that effort to the\n underlying physical device, etc. However, it might be useful to know if an\n arbitrary device ID is physical or logical. This function reports which.\n\n This function may return either true or false for invalid device IDs.\n\n \\param devid the device ID to query.\n \\returns true if devid is a physical device, false if it is logical.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_IsAudioDevicePhysical(devid: SDL_AudioDeviceID) -> bool;
}
unsafe extern "C" {
    #[doc = " Determine if an audio device is a playback device (instead of recording).\n\n This function may return either true or false for invalid device IDs.\n\n \\param devid the device ID to query.\n \\returns true if devid is a playback device, false if it is recording.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_IsAudioDevicePlayback(devid: SDL_AudioDeviceID) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to pause audio playback on a specified device.\n\n This function pauses audio processing for a given device. Any bound audio\n streams will not progress, and no audio will be generated. Pausing one\n device does not prevent other unpaused devices from running.\n\n Unlike in SDL2, audio devices start in an _unpaused_ state, since an app\n has to bind a stream before any audio will flow. Pausing a paused device is\n a legal no-op.\n\n Pausing a device can be useful to halt all audio without unbinding all the\n audio streams. This might be useful while a game is paused, or a level is\n loading, etc.\n\n Physical devices can not be paused or unpaused, only logical devices\n created through SDL_OpenAudioDevice() can be.\n\n \\param devid a device opened by SDL_OpenAudioDevice().\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ResumeAudioDevice\n \\sa SDL_AudioDevicePaused"]
    pub fn SDL_PauseAudioDevice(devid: SDL_AudioDeviceID) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to unpause audio playback on a specified device.\n\n This function unpauses audio processing for a given device that has\n previously been paused with SDL_PauseAudioDevice(). Once unpaused, any\n bound audio streams will begin to progress again, and audio can be\n generated.\n\n Unlike in SDL2, audio devices start in an _unpaused_ state, since an app\n has to bind a stream before any audio will flow. Unpausing an unpaused\n device is a legal no-op.\n\n Physical devices can not be paused or unpaused, only logical devices\n created through SDL_OpenAudioDevice() can be.\n\n \\param devid a device opened by SDL_OpenAudioDevice().\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AudioDevicePaused\n \\sa SDL_PauseAudioDevice"]
    pub fn SDL_ResumeAudioDevice(devid: SDL_AudioDeviceID) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to query if an audio device is paused.\n\n Unlike in SDL2, audio devices start in an _unpaused_ state, since an app\n has to bind a stream before any audio will flow.\n\n Physical devices can not be paused or unpaused, only logical devices\n created through SDL_OpenAudioDevice() can be. Physical and invalid device\n IDs will report themselves as unpaused here.\n\n \\param devid a device opened by SDL_OpenAudioDevice().\n \\returns true if device is valid and paused, false otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PauseAudioDevice\n \\sa SDL_ResumeAudioDevice"]
    pub fn SDL_AudioDevicePaused(devid: SDL_AudioDeviceID) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the gain of an audio device.\n\n The gain of a device is its volume; a larger gain means a louder output,\n with a gain of zero being silence.\n\n Audio devices default to a gain of 1.0f (no change in output).\n\n Physical devices may not have their gain changed, only logical devices, and\n this function will always return -1.0f when used on physical devices.\n\n \\param devid the audio device to query.\n \\returns the gain of the device or -1.0f on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioDeviceGain"]
    pub fn SDL_GetAudioDeviceGain(devid: SDL_AudioDeviceID) -> f32;
}
unsafe extern "C" {
    #[doc = " Change the gain of an audio device.\n\n The gain of a device is its volume; a larger gain means a louder output,\n with a gain of zero being silence.\n\n Audio devices default to a gain of 1.0f (no change in output).\n\n Physical devices may not have their gain changed, only logical devices, and\n this function will always return false when used on physical devices. While\n it might seem attractive to adjust several logical devices at once in this\n way, it would allow an app or library to interfere with another portion of\n the program's otherwise-isolated devices.\n\n This is applied, along with any per-audiostream gain, during playback to\n the hardware, and can be continuously changed to create various effects. On\n recording devices, this will adjust the gain before passing the data into\n an audiostream; that recording audiostream can then adjust its gain further\n when outputting the data elsewhere, if it likes, but that second gain is\n not applied until the data leaves the audiostream again.\n\n \\param devid the audio device on which to change gain.\n \\param gain the gain. 1.0f is no change, 0.0f is silence.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAudioDeviceGain"]
    pub fn SDL_SetAudioDeviceGain(devid: SDL_AudioDeviceID, gain: f32) -> bool;
}
unsafe extern "C" {
    #[doc = " Close a previously-opened audio device.\n\n The application should close open audio devices once they are no longer\n needed.\n\n This function may block briefly while pending audio data is played by the\n hardware, so that applications don't drop the last buffer of data they\n supplied if terminating immediately afterwards.\n\n \\param devid an audio device id previously returned by\n              SDL_OpenAudioDevice().\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_OpenAudioDevice"]
    pub fn SDL_CloseAudioDevice(devid: SDL_AudioDeviceID);
}
unsafe extern "C" {
    #[doc = " Bind a list of audio streams to an audio device.\n\n Audio data will flow through any bound streams. For a playback device, data\n for all bound streams will be mixed together and fed to the device. For a\n recording device, a copy of recorded data will be provided to each bound\n stream.\n\n Audio streams can only be bound to an open device. This operation is\n atomic--all streams bound in the same call will start processing at the\n same time, so they can stay in sync. Also: either all streams will be bound\n or none of them will be.\n\n It is an error to bind an already-bound stream; it must be explicitly\n unbound first.\n\n Binding a stream to a device will set its output format for playback\n devices, and its input format for recording devices, so they match the\n device's settings. The caller is welcome to change the other end of the\n stream's format at any time with SDL_SetAudioStreamFormat().\n\n \\param devid an audio device to bind a stream to.\n \\param streams an array of audio streams to bind.\n \\param num_streams number streams listed in the `streams` array.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BindAudioStreams\n \\sa SDL_UnbindAudioStream\n \\sa SDL_GetAudioStreamDevice"]
    pub fn SDL_BindAudioStreams(
        devid: SDL_AudioDeviceID,
        streams: *const *mut SDL_AudioStream,
        num_streams: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Bind a single audio stream to an audio device.\n\n This is a convenience function, equivalent to calling\n `SDL_BindAudioStreams(devid, &stream, 1)`.\n\n \\param devid an audio device to bind a stream to.\n \\param stream an audio stream to bind to a device.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BindAudioStreams\n \\sa SDL_UnbindAudioStream\n \\sa SDL_GetAudioStreamDevice"]
    pub fn SDL_BindAudioStream(devid: SDL_AudioDeviceID, stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Unbind a list of audio streams from their audio devices.\n\n The streams being unbound do not all have to be on the same device. All\n streams on the same device will be unbound atomically (data will stop\n flowing through all unbound streams on the same device at the same time).\n\n Unbinding a stream that isn't bound to a device is a legal no-op.\n\n \\param streams an array of audio streams to unbind. Can be NULL or contain\n                NULL.\n \\param num_streams number streams listed in the `streams` array.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BindAudioStreams"]
    pub fn SDL_UnbindAudioStreams(
        streams: *const *mut SDL_AudioStream,
        num_streams: ::core::ffi::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Unbind a single audio stream from its audio device.\n\n This is a convenience function, equivalent to calling\n `SDL_UnbindAudioStreams(&stream, 1)`.\n\n \\param stream an audio stream to unbind from a device. Can be NULL.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BindAudioStream"]
    pub fn SDL_UnbindAudioStream(stream: *mut SDL_AudioStream);
}
unsafe extern "C" {
    #[doc = " Query an audio stream for its currently-bound device.\n\n This reports the audio device that an audio stream is currently bound to.\n\n If not bound, or invalid, this returns zero, which is not a valid device\n ID.\n\n \\param stream the audio stream to query.\n \\returns the bound audio device, or 0 if not bound or invalid.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BindAudioStream\n \\sa SDL_BindAudioStreams"]
    pub fn SDL_GetAudioStreamDevice(stream: *mut SDL_AudioStream) -> SDL_AudioDeviceID;
}
unsafe extern "C" {
    #[doc = " Create a new audio stream.\n\n \\param src_spec the format details of the input audio.\n \\param dst_spec the format details of the output audio.\n \\returns a new audio stream on success or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PutAudioStreamData\n \\sa SDL_GetAudioStreamData\n \\sa SDL_GetAudioStreamAvailable\n \\sa SDL_FlushAudioStream\n \\sa SDL_ClearAudioStream\n \\sa SDL_SetAudioStreamFormat\n \\sa SDL_DestroyAudioStream"]
    pub fn SDL_CreateAudioStream(
        src_spec: *const SDL_AudioSpec,
        dst_spec: *const SDL_AudioSpec,
    ) -> *mut SDL_AudioStream;
}
unsafe extern "C" {
    #[doc = " Get the properties associated with an audio stream.\n\n \\param stream the SDL_AudioStream to query.\n \\returns a valid property ID on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetAudioStreamProperties(stream: *mut SDL_AudioStream) -> SDL_PropertiesID;
}
unsafe extern "C" {
    #[doc = " Query the current format of an audio stream.\n\n \\param stream the SDL_AudioStream to query.\n \\param src_spec where to store the input audio format; ignored if NULL.\n \\param dst_spec where to store the output audio format; ignored if NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioStreamFormat"]
    pub fn SDL_GetAudioStreamFormat(
        stream: *mut SDL_AudioStream,
        src_spec: *mut SDL_AudioSpec,
        dst_spec: *mut SDL_AudioSpec,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Change the input and output formats of an audio stream.\n\n Future calls to and SDL_GetAudioStreamAvailable and SDL_GetAudioStreamData\n will reflect the new format, and future calls to SDL_PutAudioStreamData\n must provide data in the new input formats.\n\n Data that was previously queued in the stream will still be operated on in\n the format that was current when it was added, which is to say you can put\n the end of a sound file in one format to a stream, change formats for the\n next sound file, and start putting that new data while the previous sound\n file is still queued, and everything will still play back correctly.\n\n If a stream is bound to a device, then the format of the side of the stream\n bound to a device cannot be changed (src_spec for recording devices,\n dst_spec for playback devices). Attempts to make a change to this side will\n be ignored, but this will not report an error. The other side's format can\n be changed.\n\n \\param stream the stream the format is being changed.\n \\param src_spec the new format of the audio input; if NULL, it is not\n                 changed.\n \\param dst_spec the new format of the audio output; if NULL, it is not\n                 changed.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAudioStreamFormat\n \\sa SDL_SetAudioStreamFrequencyRatio"]
    pub fn SDL_SetAudioStreamFormat(
        stream: *mut SDL_AudioStream,
        src_spec: *const SDL_AudioSpec,
        dst_spec: *const SDL_AudioSpec,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the frequency ratio of an audio stream.\n\n \\param stream the SDL_AudioStream to query.\n \\returns the frequency ratio of the stream or 0.0 on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioStreamFrequencyRatio"]
    pub fn SDL_GetAudioStreamFrequencyRatio(stream: *mut SDL_AudioStream) -> f32;
}
unsafe extern "C" {
    #[doc = " Change the frequency ratio of an audio stream.\n\n The frequency ratio is used to adjust the rate at which input data is\n consumed. Changing this effectively modifies the speed and pitch of the\n audio. A value greater than 1.0 will play the audio faster, and at a higher\n pitch. A value less than 1.0 will play the audio slower, and at a lower\n pitch.\n\n This is applied during SDL_GetAudioStreamData, and can be continuously\n changed to create various effects.\n\n \\param stream the stream the frequency ratio is being changed.\n \\param ratio the frequency ratio. 1.0 is normal speed. Must be between 0.01\n              and 100.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAudioStreamFrequencyRatio\n \\sa SDL_SetAudioStreamFormat"]
    pub fn SDL_SetAudioStreamFrequencyRatio(stream: *mut SDL_AudioStream, ratio: f32) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the gain of an audio stream.\n\n The gain of a stream is its volume; a larger gain means a louder output,\n with a gain of zero being silence.\n\n Audio streams default to a gain of 1.0f (no change in output).\n\n \\param stream the SDL_AudioStream to query.\n \\returns the gain of the stream or -1.0f on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioStreamGain"]
    pub fn SDL_GetAudioStreamGain(stream: *mut SDL_AudioStream) -> f32;
}
unsafe extern "C" {
    #[doc = " Change the gain of an audio stream.\n\n The gain of a stream is its volume; a larger gain means a louder output,\n with a gain of zero being silence.\n\n Audio streams default to a gain of 1.0f (no change in output).\n\n This is applied during SDL_GetAudioStreamData, and can be continuously\n changed to create various effects.\n\n \\param stream the stream on which the gain is being changed.\n \\param gain the gain. 1.0f is no change, 0.0f is silence.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAudioStreamGain"]
    pub fn SDL_SetAudioStreamGain(stream: *mut SDL_AudioStream, gain: f32) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the current input channel map of an audio stream.\n\n Channel maps are optional; most things do not need them, instead passing\n data in the [order that SDL expects](CategoryAudio#channel-layouts).\n\n Audio streams default to no remapping applied. This is represented by\n returning NULL, and does not signify an error.\n\n \\param stream the SDL_AudioStream to query.\n \\param count On output, set to number of channels in the map. Can be NULL.\n \\returns an array of the current channel mapping, with as many elements as\n          the current output spec's channels, or NULL if default. This\n          should be freed with SDL_free() when it is no longer needed.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioStreamInputChannelMap"]
    pub fn SDL_GetAudioStreamInputChannelMap(
        stream: *mut SDL_AudioStream,
        count: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current output channel map of an audio stream.\n\n Channel maps are optional; most things do not need them, instead passing\n data in the [order that SDL expects](CategoryAudio#channel-layouts).\n\n Audio streams default to no remapping applied. This is represented by\n returning NULL, and does not signify an error.\n\n \\param stream the SDL_AudioStream to query.\n \\param count On output, set to number of channels in the map. Can be NULL.\n \\returns an array of the current channel mapping, with as many elements as\n          the current output spec's channels, or NULL if default. This\n          should be freed with SDL_free() when it is no longer needed.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioStreamInputChannelMap"]
    pub fn SDL_GetAudioStreamOutputChannelMap(
        stream: *mut SDL_AudioStream,
        count: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Set the current input channel map of an audio stream.\n\n Channel maps are optional; most things do not need them, instead passing\n data in the [order that SDL expects](CategoryAudio#channel-layouts).\n\n The input channel map reorders data that is added to a stream via\n SDL_PutAudioStreamData. Future calls to SDL_PutAudioStreamData must provide\n data in the new channel order.\n\n Each item in the array represents an input channel, and its value is the\n channel that it should be remapped to. To reverse a stereo signal's left\n and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap\n multiple channels to the same thing, so `{ 1, 1 }` would duplicate the\n right channel to both channels of a stereo signal. An element in the\n channel map set to -1 instead of a valid channel will mute that channel,\n setting it to a silence value.\n\n You cannot change the number of channels through a channel map, just\n reorder/mute them.\n\n Data that was previously queued in the stream will still be operated on in\n the order that was current when it was added, which is to say you can put\n the end of a sound file in one order to a stream, change orders for the\n next sound file, and start putting that new data while the previous sound\n file is still queued, and everything will still play back correctly.\n\n Audio streams default to no remapping applied. Passing a NULL channel map\n is legal, and turns off remapping.\n\n SDL will copy the channel map; the caller does not have to save this array\n after this call.\n\n If `count` is not equal to the current number of channels in the audio\n stream's format, this will fail. This is a safety measure to make sure a\n race condition hasn't changed the format while this call is setting the\n channel map.\n\n Unlike attempting to change the stream's format, the input channel map on a\n stream bound to a recording device is permitted to change at any time; any\n data added to the stream from the device after this call will have the new\n mapping, but previously-added data will still have the prior mapping.\n\n \\param stream the SDL_AudioStream to change.\n \\param chmap the new channel map, NULL to reset to default.\n \\param count The number of channels in the map.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running. Don't change the\n               stream's format to have a different number of channels from a\n               a different thread at the same time, though!\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioStreamInputChannelMap"]
    pub fn SDL_SetAudioStreamInputChannelMap(
        stream: *mut SDL_AudioStream,
        chmap: *const ::core::ffi::c_int,
        count: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the current output channel map of an audio stream.\n\n Channel maps are optional; most things do not need them, instead passing\n data in the [order that SDL expects](CategoryAudio#channel-layouts).\n\n The output channel map reorders data that leaving a stream via\n SDL_GetAudioStreamData.\n\n Each item in the array represents an input channel, and its value is the\n channel that it should be remapped to. To reverse a stereo signal's left\n and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap\n multiple channels to the same thing, so `{ 1, 1 }` would duplicate the\n right channel to both channels of a stereo signal. An element in the\n channel map set to -1 instead of a valid channel will mute that channel,\n setting it to a silence value.\n\n You cannot change the number of channels through a channel map, just\n reorder/mute them.\n\n The output channel map can be changed at any time, as output remapping is\n applied during SDL_GetAudioStreamData.\n\n Audio streams default to no remapping applied. Passing a NULL channel map\n is legal, and turns off remapping.\n\n SDL will copy the channel map; the caller does not have to save this array\n after this call.\n\n If `count` is not equal to the current number of channels in the audio\n stream's format, this will fail. This is a safety measure to make sure a\n race condition hasn't changed the format while this call is setting the\n channel map.\n\n Unlike attempting to change the stream's format, the output channel map on\n a stream bound to a recording device is permitted to change at any time;\n any data added to the stream after this call will have the new mapping, but\n previously-added data will still have the prior mapping. When the channel\n map doesn't match the hardware's channel layout, SDL will convert the data\n before feeding it to the device for playback.\n\n \\param stream the SDL_AudioStream to change.\n \\param chmap the new channel map, NULL to reset to default.\n \\param count The number of channels in the map.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running. Don't change the\n               stream's format to have a different number of channels from a\n               a different thread at the same time, though!\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioStreamInputChannelMap"]
    pub fn SDL_SetAudioStreamOutputChannelMap(
        stream: *mut SDL_AudioStream,
        chmap: *const ::core::ffi::c_int,
        count: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Add data to the stream.\n\n This data must match the format/channels/samplerate specified in the latest\n call to SDL_SetAudioStreamFormat, or the format specified when creating the\n stream if it hasn't been changed.\n\n Note that this call simply copies the unconverted data for later. This is\n different than SDL2, where data was converted during the Put call and the\n Get call would just dequeue the previously-converted data.\n\n \\param stream the stream the audio data is being added to.\n \\param buf a pointer to the audio data to add.\n \\param len the number of bytes to write to the stream.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread, but if the\n               stream has a callback set, the caller might need to manage\n               extra locking.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ClearAudioStream\n \\sa SDL_FlushAudioStream\n \\sa SDL_GetAudioStreamData\n \\sa SDL_GetAudioStreamQueued"]
    pub fn SDL_PutAudioStreamData(
        stream: *mut SDL_AudioStream,
        buf: *const ::core::ffi::c_void,
        len: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get converted/resampled data from the stream.\n\n The input/output data format/channels/samplerate is specified when creating\n the stream, and can be changed after creation by calling\n SDL_SetAudioStreamFormat.\n\n Note that any conversion and resampling necessary is done during this call,\n and SDL_PutAudioStreamData simply queues unconverted data for later. This\n is different than SDL2, where that work was done while inputting new data\n to the stream and requesting the output just copied the converted data.\n\n \\param stream the stream the audio is being requested from.\n \\param buf a buffer to fill with audio data.\n \\param len the maximum number of bytes to fill.\n \\returns the number of bytes read from the stream or -1 on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread, but if the\n               stream has a callback set, the caller might need to manage\n               extra locking.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ClearAudioStream\n \\sa SDL_GetAudioStreamAvailable\n \\sa SDL_PutAudioStreamData"]
    pub fn SDL_GetAudioStreamData(
        stream: *mut SDL_AudioStream,
        buf: *mut ::core::ffi::c_void,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of converted/resampled bytes available.\n\n The stream may be buffering data behind the scenes until it has enough to\n resample correctly, so this number might be lower than what you expect, or\n even be zero. Add more data or flush the stream if you need the data now.\n\n If the stream has so much data that it would overflow an int, the return\n value is clamped to a maximum value, but no queued data is lost; if there\n are gigabytes of data queued, the app might need to read some of it with\n SDL_GetAudioStreamData before this function's return value is no longer\n clamped.\n\n \\param stream the audio stream to query.\n \\returns the number of converted/resampled bytes available or -1 on\n          failure; call SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAudioStreamData\n \\sa SDL_PutAudioStreamData"]
    pub fn SDL_GetAudioStreamAvailable(stream: *mut SDL_AudioStream) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of bytes currently queued.\n\n This is the number of bytes put into a stream as input, not the number that\n can be retrieved as output. Because of several details, it's not possible\n to calculate one number directly from the other. If you need to know how\n much usable data can be retrieved right now, you should use\n SDL_GetAudioStreamAvailable() and not this function.\n\n Note that audio streams can change their input format at any time, even if\n there is still data queued in a different format, so the returned byte\n count will not necessarily match the number of _sample frames_ available.\n Users of this API should be aware of format changes they make when feeding\n a stream and plan accordingly.\n\n Queued data is not converted until it is consumed by\n SDL_GetAudioStreamData, so this value should be representative of the exact\n data that was put into the stream.\n\n If the stream has so much data that it would overflow an int, the return\n value is clamped to a maximum value, but no queued data is lost; if there\n are gigabytes of data queued, the app might need to read some of it with\n SDL_GetAudioStreamData before this function's return value is no longer\n clamped.\n\n \\param stream the audio stream to query.\n \\returns the number of bytes queued or -1 on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PutAudioStreamData\n \\sa SDL_ClearAudioStream"]
    pub fn SDL_GetAudioStreamQueued(stream: *mut SDL_AudioStream) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Tell the stream that you're done sending data, and anything being buffered\n should be converted/resampled and made available immediately.\n\n It is legal to add more data to a stream after flushing, but there may be\n audio gaps in the output. Generally this is intended to signal the end of\n input, so the complete output becomes available.\n\n \\param stream the audio stream to flush.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PutAudioStreamData"]
    pub fn SDL_FlushAudioStream(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Clear any pending data in the stream.\n\n This drops any queued data, so there will be nothing to read from the\n stream until more is added.\n\n \\param stream the audio stream to clear.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAudioStreamAvailable\n \\sa SDL_GetAudioStreamData\n \\sa SDL_GetAudioStreamQueued\n \\sa SDL_PutAudioStreamData"]
    pub fn SDL_ClearAudioStream(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to pause audio playback on the audio device associated\n with an audio stream.\n\n This function pauses audio processing for a given device. Any bound audio\n streams will not progress, and no audio will be generated. Pausing one\n device does not prevent other unpaused devices from running.\n\n Pausing a device can be useful to halt all audio without unbinding all the\n audio streams. This might be useful while a game is paused, or a level is\n loading, etc.\n\n \\param stream the audio stream associated with the audio device to pause.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ResumeAudioStreamDevice"]
    pub fn SDL_PauseAudioStreamDevice(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to unpause audio playback on the audio device associated\n with an audio stream.\n\n This function unpauses audio processing for a given device that has\n previously been paused. Once unpaused, any bound audio streams will begin\n to progress again, and audio can be generated.\n\n Remember, SDL_OpenAudioDeviceStream opens device in a paused state, so this\n function call is required for audio playback to begin on such device.\n\n \\param stream the audio stream associated with the audio device to resume.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PauseAudioStreamDevice"]
    pub fn SDL_ResumeAudioStreamDevice(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Use this function to query if an audio device associated with a stream is\n paused.\n\n Unlike in SDL2, audio devices start in an _unpaused_ state, since an app\n has to bind a stream before any audio will flow.\n\n \\param stream the audio stream associated with the audio device to query.\n \\returns true if device is valid and paused, false otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PauseAudioStreamDevice\n \\sa SDL_ResumeAudioStreamDevice"]
    pub fn SDL_AudioStreamDevicePaused(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Lock an audio stream for serialized access.\n\n Each SDL_AudioStream has an internal mutex it uses to protect its data\n structures from threading conflicts. This function allows an app to lock\n that mutex, which could be useful if registering callbacks on this stream.\n\n One does not need to lock a stream to use in it most cases, as the stream\n manages this lock internally. However, this lock is held during callbacks,\n which may run from arbitrary threads at any time, so if an app needs to\n protect shared data during those callbacks, locking the stream guarantees\n that the callback is not running while the lock is held.\n\n As this is just a wrapper over SDL_LockMutex for an internal lock; it has\n all the same attributes (recursive locks are allowed, etc).\n\n \\param stream the audio stream to lock.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_UnlockAudioStream"]
    pub fn SDL_LockAudioStream(stream: *mut SDL_AudioStream) -> bool;
}
unsafe extern "C" {
    #[doc = " Unlock an audio stream for serialized access.\n\n This unlocks an audio stream after a call to SDL_LockAudioStream.\n\n \\param stream the audio stream to unlock.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety You should only call this from the same thread that\n               previously called SDL_LockAudioStream.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LockAudioStream"]
    pub fn SDL_UnlockAudioStream(stream: *mut SDL_AudioStream) -> bool;
}
#[doc = " A callback that fires when data passes through an SDL_AudioStream.\n\n Apps can (optionally) register a callback with an audio stream that is\n called when data is added with SDL_PutAudioStreamData, or requested with\n SDL_GetAudioStreamData.\n\n Two values are offered here: one is the amount of additional data needed to\n satisfy the immediate request (which might be zero if the stream already\n has enough data queued) and the other is the total amount being requested.\n In a Get call triggering a Put callback, these values can be different. In\n a Put call triggering a Get callback, these values are always the same.\n\n Byte counts might be slightly overestimated due to buffering or resampling,\n and may change from call to call.\n\n This callback is not required to do anything. Generally this is useful for\n adding/reading data on demand, and the app will often put/get data as\n appropriate, but the system goes on with the data currently available to it\n if this callback does nothing.\n\n \\param stream the SDL audio stream associated with this callback.\n \\param additional_amount the amount of data, in bytes, that is needed right\n                          now.\n \\param total_amount the total amount of data requested, in bytes, that is\n                     requested or available.\n \\param userdata an opaque pointer provided by the app for their personal\n                 use.\n\n \\threadsafety This callbacks may run from any thread, so if you need to\n               protect shared data, you should use SDL_LockAudioStream to\n               serialize access; this lock will be held before your callback\n               is called, so your callback does not need to manage the lock\n               explicitly.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioStreamGetCallback\n \\sa SDL_SetAudioStreamPutCallback"]
pub type SDL_AudioStreamCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::core::ffi::c_void,
        stream: *mut SDL_AudioStream,
        additional_amount: ::core::ffi::c_int,
        total_amount: ::core::ffi::c_int,
    ),
>;
unsafe extern "C" {
    #[doc = " Set a callback that runs when data is requested from an audio stream.\n\n This callback is called _before_ data is obtained from the stream, giving\n the callback the chance to add more on-demand.\n\n The callback can (optionally) call SDL_PutAudioStreamData() to add more\n audio to the stream during this call; if needed, the request that triggered\n this callback will obtain the new data immediately.\n\n The callback's `approx_request` argument is roughly how many bytes of\n _unconverted_ data (in the stream's input format) is needed by the caller,\n although this may overestimate a little for safety. This takes into account\n how much is already in the stream and only asks for any extra necessary to\n resolve the request, which means the callback may be asked for zero bytes,\n and a different amount on each call.\n\n The callback is not required to supply exact amounts; it is allowed to\n supply too much or too little or none at all. The caller will get what's\n available, up to the amount they requested, regardless of this callback's\n outcome.\n\n Clearing or flushing an audio stream does not call this callback.\n\n This function obtains the stream's lock, which means any existing callback\n (get or put) in progress will finish running before setting the new\n callback.\n\n Setting a NULL function turns off the callback.\n\n \\param stream the audio stream to set the new callback on.\n \\param callback the new callback function to call when data is requested\n                 from the stream.\n \\param userdata an opaque pointer provided to the callback for its own\n                 personal use.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information. This only fails if `stream` is NULL.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioStreamPutCallback"]
    pub fn SDL_SetAudioStreamGetCallback(
        stream: *mut SDL_AudioStream,
        callback: SDL_AudioStreamCallback,
        userdata: *mut ::core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set a callback that runs when data is added to an audio stream.\n\n This callback is called _after_ the data is added to the stream, giving the\n callback the chance to obtain it immediately.\n\n The callback can (optionally) call SDL_GetAudioStreamData() to obtain audio\n from the stream during this call.\n\n The callback's `approx_request` argument is how many bytes of _converted_\n data (in the stream's output format) was provided by the caller, although\n this may underestimate a little for safety. This value might be less than\n what is currently available in the stream, if data was already there, and\n might be less than the caller provided if the stream needs to keep a buffer\n to aid in resampling. Which means the callback may be provided with zero\n bytes, and a different amount on each call.\n\n The callback may call SDL_GetAudioStreamAvailable to see the total amount\n currently available to read from the stream, instead of the total provided\n by the current call.\n\n The callback is not required to obtain all data. It is allowed to read less\n or none at all. Anything not read now simply remains in the stream for\n later access.\n\n Clearing or flushing an audio stream does not call this callback.\n\n This function obtains the stream's lock, which means any existing callback\n (get or put) in progress will finish running before setting the new\n callback.\n\n Setting a NULL function turns off the callback.\n\n \\param stream the audio stream to set the new callback on.\n \\param callback the new callback function to call when data is added to the\n                 stream.\n \\param userdata an opaque pointer provided to the callback for its own\n                 personal use.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information. This only fails if `stream` is NULL.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioStreamGetCallback"]
    pub fn SDL_SetAudioStreamPutCallback(
        stream: *mut SDL_AudioStream,
        callback: SDL_AudioStreamCallback,
        userdata: *mut ::core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Free an audio stream.\n\n This will release all allocated data, including any audio that is still\n queued. You do not need to manually clear the stream first.\n\n If this stream was bound to an audio device, it is unbound during this\n call. If this stream was created with SDL_OpenAudioDeviceStream, the audio\n device that was opened alongside this stream's creation will be closed,\n too.\n\n \\param stream the audio stream to destroy.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateAudioStream"]
    pub fn SDL_DestroyAudioStream(stream: *mut SDL_AudioStream);
}
unsafe extern "C" {
    #[doc = " Convenience function for straightforward audio init for the common case.\n\n If all your app intends to do is provide a single source of PCM audio, this\n function allows you to do all your audio setup in a single call.\n\n This is also intended to be a clean means to migrate apps from SDL2.\n\n This function will open an audio device, create a stream and bind it.\n Unlike other methods of setup, the audio device will be closed when this\n stream is destroyed, so the app can treat the returned SDL_AudioStream as\n the only object needed to manage audio playback.\n\n Also unlike other functions, the audio device begins paused. This is to map\n more closely to SDL2-style behavior, since there is no extra step here to\n bind a stream to begin audio flowing. The audio device should be resumed\n with `SDL_ResumeAudioStreamDevice(stream);`\n\n This function works with both playback and recording devices.\n\n The `spec` parameter represents the app's side of the audio stream. That\n is, for recording audio, this will be the output format, and for playing\n audio, this will be the input format. If spec is NULL, the system will\n choose the format, and the app can use SDL_GetAudioStreamFormat() to obtain\n this information later.\n\n If you don't care about opening a specific audio device, you can (and\n probably _should_), use SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and\n SDL_AUDIO_DEVICE_DEFAULT_RECORDING for recording.\n\n One can optionally provide a callback function; if NULL, the app is\n expected to queue audio data for playback (or unqueue audio data if\n capturing). Otherwise, the callback will begin to fire once the device is\n unpaused.\n\n Destroying the returned stream with SDL_DestroyAudioStream will also close\n the audio device associated with this stream.\n\n \\param devid an audio device to open, or SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK\n              or SDL_AUDIO_DEVICE_DEFAULT_RECORDING.\n \\param spec the audio stream's data format. Can be NULL.\n \\param callback a callback where the app will provide new data for\n                 playback, or receive new data for recording. Can be NULL,\n                 in which case the app will need to call\n                 SDL_PutAudioStreamData or SDL_GetAudioStreamData as\n                 necessary.\n \\param userdata app-controlled pointer passed to callback. Can be NULL.\n                 Ignored if callback is NULL.\n \\returns an audio stream on success, ready to use, or NULL on failure; call\n          SDL_GetError() for more information. When done with this stream,\n          call SDL_DestroyAudioStream to free resources and close the\n          device.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAudioStreamDevice\n \\sa SDL_ResumeAudioStreamDevice"]
    pub fn SDL_OpenAudioDeviceStream(
        devid: SDL_AudioDeviceID,
        spec: *const SDL_AudioSpec,
        callback: SDL_AudioStreamCallback,
        userdata: *mut ::core::ffi::c_void,
    ) -> *mut SDL_AudioStream;
}
#[doc = " A callback that fires when data is about to be fed to an audio device.\n\n This is useful for accessing the final mix, perhaps for writing a\n visualizer or applying a final effect to the audio data before playback.\n\n This callback should run as quickly as possible and not block for any\n significant time, as this callback delays submission of data to the audio\n device, which can cause audio playback problems.\n\n The postmix callback _must_ be able to handle any audio data format\n specified in `spec`, which can change between callbacks if the audio device\n changed. However, this only covers frequency and channel count; data is\n always provided here in SDL_AUDIO_F32 format.\n\n The postmix callback runs _after_ logical device gain and audiostream gain\n have been applied, which is to say you can make the output data louder at\n this point than the gain settings would suggest.\n\n \\param userdata a pointer provided by the app through\n                 SDL_SetAudioPostmixCallback, for its own use.\n \\param spec the current format of audio that is to be submitted to the\n             audio device.\n \\param buffer the buffer of audio samples to be submitted. The callback can\n               inspect and/or modify this data.\n \\param buflen the size of `buffer` in bytes.\n\n \\threadsafety This will run from a background thread owned by SDL. The\n               application is responsible for locking resources the callback\n               touches that need to be protected.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_SetAudioPostmixCallback"]
pub type SDL_AudioPostmixCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::core::ffi::c_void,
        spec: *const SDL_AudioSpec,
        buffer: *mut f32,
        buflen: ::core::ffi::c_int,
    ),
>;
unsafe extern "C" {
    #[doc = " Set a callback that fires when data is about to be fed to an audio device.\n\n This is useful for accessing the final mix, perhaps for writing a\n visualizer or applying a final effect to the audio data before playback.\n\n The buffer is the final mix of all bound audio streams on an opened device;\n this callback will fire regularly for any device that is both opened and\n unpaused. If there is no new data to mix, either because no streams are\n bound to the device or all the streams are empty, this callback will still\n fire with the entire buffer set to silence.\n\n This callback is allowed to make changes to the data; the contents of the\n buffer after this call is what is ultimately passed along to the hardware.\n\n The callback is always provided the data in float format (values from -1.0f\n to 1.0f), but the number of channels or sample rate may be different than\n the format the app requested when opening the device; SDL might have had to\n manage a conversion behind the scenes, or the playback might have jumped to\n new physical hardware when a system default changed, etc. These details may\n change between calls. Accordingly, the size of the buffer might change\n between calls as well.\n\n This callback can run at any time, and from any thread; if you need to\n serialize access to your app's data, you should provide and use a mutex or\n other synchronization device.\n\n All of this to say: there are specific needs this callback can fulfill, but\n it is not the simplest interface. Apps should generally provide audio in\n their preferred format through an SDL_AudioStream and let SDL handle the\n difference.\n\n This function is extremely time-sensitive; the callback should do the least\n amount of work possible and return as quickly as it can. The longer the\n callback runs, the higher the risk of audio dropouts or other problems.\n\n This function will block until the audio device is in between iterations,\n so any existing callback that might be running will finish before this\n function sets the new callback and returns.\n\n Setting a NULL callback function disables any previously-set callback.\n\n \\param devid the ID of an opened audio device.\n \\param callback a callback function to be called. Can be NULL.\n \\param userdata app-controlled pointer passed to callback. Can be NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetAudioPostmixCallback(
        devid: SDL_AudioDeviceID,
        callback: SDL_AudioPostmixCallback,
        userdata: *mut ::core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Load the audio data of a WAVE file into memory.\n\n Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to\n be valid pointers. The entire data portion of the file is then loaded into\n memory and decoded if necessary.\n\n Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and\n 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and\n A-law and mu-law (8 bits). Other formats are currently unsupported and\n cause an error.\n\n If this function succeeds, the return value is zero and the pointer to the\n audio data allocated by the function is written to `audio_buf` and its\n length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,\n `channels`, and `format` are set to the values of the audio data in the\n buffer.\n\n It's necessary to use SDL_free() to free the audio data returned in\n `audio_buf` when it is no longer used.\n\n Because of the underspecification of the .WAV format, there are many\n problematic files in the wild that cause issues with strict decoders. To\n provide compatibility with these files, this decoder is lenient in regards\n to the truncation of the file, the fact chunk, and the size of the RIFF\n chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,\n `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to\n tune the behavior of the loading process.\n\n Any file that is invalid (due to truncation, corruption, or wrong values in\n the headers), too big, or unsupported causes an error. Additionally, any\n critical I/O error from the data source will terminate the loading process\n with an error. The function returns NULL on error and in all cases (with\n the exception of `src` being NULL), an appropriate error message will be\n set.\n\n It is required that the data source supports seeking.\n\n Example:\n\n ```c\n SDL_LoadWAV_IO(SDL_IOFromFile(\"sample.wav\", \"rb\"), true, &spec, &buf, &len);\n ```\n\n Note that the SDL_LoadWAV function does this same thing for you, but in a\n less messy way:\n\n ```c\n SDL_LoadWAV(\"sample.wav\", &spec, &buf, &len);\n ```\n\n \\param src the data source for the WAVE data.\n \\param closeio if true, calls SDL_CloseIO() on `src` before returning, even\n                in the case of an error.\n \\param spec a pointer to an SDL_AudioSpec that will be set to the WAVE\n             data's format details on successful return.\n \\param audio_buf a pointer filled with the audio data, allocated by the\n                  function.\n \\param audio_len a pointer filled with the length of the audio data buffer\n                  in bytes.\n \\returns true on success. `audio_buf` will be filled with a pointer to an\n          allocated buffer containing the audio data, and `audio_len` is\n          filled with the length of that audio buffer in bytes.\n\n          This function returns false if the .WAV file cannot be opened,\n          uses an unknown data format, or is corrupt; call SDL_GetError()\n          for more information.\n\n          When the application is done with the data returned in\n          `audio_buf`, it should call SDL_free() to dispose of it.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_free\n \\sa SDL_LoadWAV"]
    pub fn SDL_LoadWAV_IO(
        src: *mut SDL_IOStream,
        closeio: bool,
        spec: *mut SDL_AudioSpec,
        audio_buf: *mut *mut Uint8,
        audio_len: *mut Uint32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Loads a WAV from a file path.\n\n This is a convenience function that is effectively the same as:\n\n ```c\n SDL_LoadWAV_IO(SDL_IOFromFile(path, \"rb\"), true, spec, audio_buf, audio_len);\n ```\n\n \\param path the file path of the WAV file to open.\n \\param spec a pointer to an SDL_AudioSpec that will be set to the WAVE\n             data's format details on successful return.\n \\param audio_buf a pointer filled with the audio data, allocated by the\n                  function.\n \\param audio_len a pointer filled with the length of the audio data buffer\n                  in bytes.\n \\returns true on success. `audio_buf` will be filled with a pointer to an\n          allocated buffer containing the audio data, and `audio_len` is\n          filled with the length of that audio buffer in bytes.\n\n          This function returns false if the .WAV file cannot be opened,\n          uses an unknown data format, or is corrupt; call SDL_GetError()\n          for more information.\n\n          When the application is done with the data returned in\n          `audio_buf`, it should call SDL_free() to dispose of it.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_free\n \\sa SDL_LoadWAV_IO"]
    pub fn SDL_LoadWAV(
        path: *const ::core::ffi::c_char,
        spec: *mut SDL_AudioSpec,
        audio_buf: *mut *mut Uint8,
        audio_len: *mut Uint32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Mix audio data in a specified format.\n\n This takes an audio buffer `src` of `len` bytes of `format` data and mixes\n it into `dst`, performing addition, volume adjustment, and overflow\n clipping. The buffer pointed to by `dst` must also be `len` bytes of\n `format` data.\n\n This is provided for convenience -- you can mix your own audio data.\n\n Do not use this function for mixing together more than two streams of\n sample data. The output from repeated application of this function may be\n distorted by clipping, because there is no accumulator with greater range\n than the input (not to mention this being an inefficient way of doing it).\n\n It is a common misconception that this function is required to write audio\n data to an output stream in an audio callback. While you can do that,\n SDL_MixAudio() is really only needed when you're mixing a single audio\n stream with a volume adjustment.\n\n \\param dst the destination for the mixed audio.\n \\param src the source audio buffer to be mixed.\n \\param format the SDL_AudioFormat structure representing the desired audio\n               format.\n \\param len the length of the audio buffer in bytes.\n \\param volume ranges from 0.0 - 1.0, and should be set to 1.0 for full\n               audio volume.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_MixAudio(
        dst: *mut Uint8,
        src: *const Uint8,
        format: SDL_AudioFormat,
        len: Uint32,
        volume: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Convert some audio data of one format to another format.\n\n Please note that this function is for convenience, but should not be used\n to resample audio in blocks, as it will introduce audio artifacts on the\n boundaries. You should only use this function if you are converting audio\n data in its entirety in one call. If you want to convert audio in smaller\n chunks, use an SDL_AudioStream, which is designed for this situation.\n\n Internally, this function creates and destroys an SDL_AudioStream on each\n use, so it's also less efficient than using one directly, if you need to\n convert multiple times.\n\n \\param src_spec the format details of the input audio.\n \\param src_data the audio data to be converted.\n \\param src_len the len of src_data.\n \\param dst_spec the format details of the output audio.\n \\param dst_data will be filled with a pointer to converted audio data,\n                 which should be freed with SDL_free(). On error, it will be\n                 NULL.\n \\param dst_len will be filled with the len of dst_data.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ConvertAudioSamples(
        src_spec: *const SDL_AudioSpec,
        src_data: *const Uint8,
        src_len: ::core::ffi::c_int,
        dst_spec: *const SDL_AudioSpec,
        dst_data: *mut *mut Uint8,
        dst_len: *mut ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the human readable name of an audio format.\n\n \\param format the audio format to query.\n \\returns the human readable name of the specified audio format or\n          \"SDL_AUDIO_UNKNOWN\" if the format isn't recognized.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetAudioFormatName(format: SDL_AudioFormat) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the appropriate memset value for silencing an audio format.\n\n The value returned by this function can be used as the second argument to\n memset (or SDL_memset) to set an audio buffer in a specific format to\n silence.\n\n \\param format the audio data format to query.\n \\returns a byte value that can be passed to memset.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSilenceValueForFormat(format: SDL_AudioFormat) -> ::core::ffi::c_int;
}
pub const SDL_PixelType_SDL_PIXELTYPE_UNKNOWN: SDL_PixelType = 0;
pub const SDL_PixelType_SDL_PIXELTYPE_INDEX1: SDL_PixelType = 1;
pub const SDL_PixelType_SDL_PIXELTYPE_INDEX4: SDL_PixelType = 2;
pub const SDL_PixelType_SDL_PIXELTYPE_INDEX8: SDL_PixelType = 3;
pub const SDL_PixelType_SDL_PIXELTYPE_PACKED8: SDL_PixelType = 4;
pub const SDL_PixelType_SDL_PIXELTYPE_PACKED16: SDL_PixelType = 5;
pub const SDL_PixelType_SDL_PIXELTYPE_PACKED32: SDL_PixelType = 6;
pub const SDL_PixelType_SDL_PIXELTYPE_ARRAYU8: SDL_PixelType = 7;
pub const SDL_PixelType_SDL_PIXELTYPE_ARRAYU16: SDL_PixelType = 8;
pub const SDL_PixelType_SDL_PIXELTYPE_ARRAYU32: SDL_PixelType = 9;
pub const SDL_PixelType_SDL_PIXELTYPE_ARRAYF16: SDL_PixelType = 10;
pub const SDL_PixelType_SDL_PIXELTYPE_ARRAYF32: SDL_PixelType = 11;
pub const SDL_PixelType_SDL_PIXELTYPE_INDEX2: SDL_PixelType = 12;
#[doc = " Pixel type.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_PixelType = ::core::ffi::c_uint;
pub const SDL_BitmapOrder_SDL_BITMAPORDER_NONE: SDL_BitmapOrder = 0;
pub const SDL_BitmapOrder_SDL_BITMAPORDER_4321: SDL_BitmapOrder = 1;
pub const SDL_BitmapOrder_SDL_BITMAPORDER_1234: SDL_BitmapOrder = 2;
#[doc = " Bitmap pixel order, high bit -> low bit.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_BitmapOrder = ::core::ffi::c_uint;
pub const SDL_PackedOrder_SDL_PACKEDORDER_NONE: SDL_PackedOrder = 0;
pub const SDL_PackedOrder_SDL_PACKEDORDER_XRGB: SDL_PackedOrder = 1;
pub const SDL_PackedOrder_SDL_PACKEDORDER_RGBX: SDL_PackedOrder = 2;
pub const SDL_PackedOrder_SDL_PACKEDORDER_ARGB: SDL_PackedOrder = 3;
pub const SDL_PackedOrder_SDL_PACKEDORDER_RGBA: SDL_PackedOrder = 4;
pub const SDL_PackedOrder_SDL_PACKEDORDER_XBGR: SDL_PackedOrder = 5;
pub const SDL_PackedOrder_SDL_PACKEDORDER_BGRX: SDL_PackedOrder = 6;
pub const SDL_PackedOrder_SDL_PACKEDORDER_ABGR: SDL_PackedOrder = 7;
pub const SDL_PackedOrder_SDL_PACKEDORDER_BGRA: SDL_PackedOrder = 8;
#[doc = " Packed component order, high bit -> low bit.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_PackedOrder = ::core::ffi::c_uint;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_NONE: SDL_ArrayOrder = 0;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_RGB: SDL_ArrayOrder = 1;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_RGBA: SDL_ArrayOrder = 2;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_ARGB: SDL_ArrayOrder = 3;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_BGR: SDL_ArrayOrder = 4;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_BGRA: SDL_ArrayOrder = 5;
pub const SDL_ArrayOrder_SDL_ARRAYORDER_ABGR: SDL_ArrayOrder = 6;
#[doc = " Array component order, low byte -> high byte.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_ArrayOrder = ::core::ffi::c_uint;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_NONE: SDL_PackedLayout = 0;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_332: SDL_PackedLayout = 1;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_4444: SDL_PackedLayout = 2;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_1555: SDL_PackedLayout = 3;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_5551: SDL_PackedLayout = 4;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_565: SDL_PackedLayout = 5;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_8888: SDL_PackedLayout = 6;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_2101010: SDL_PackedLayout = 7;
pub const SDL_PackedLayout_SDL_PACKEDLAYOUT_1010102: SDL_PackedLayout = 8;
#[doc = " Packed component layout.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_PackedLayout = ::core::ffi::c_uint;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_UNKNOWN: SDL_PixelFormat = 0;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_INDEX1LSB: SDL_PixelFormat = 286261504;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_INDEX1MSB: SDL_PixelFormat = 287310080;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_INDEX2LSB: SDL_PixelFormat = 470811136;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_INDEX2MSB: SDL_PixelFormat = 471859712;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_INDEX4LSB: SDL_PixelFormat = 303039488;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_INDEX4MSB: SDL_PixelFormat = 304088064;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_INDEX8: SDL_PixelFormat = 318769153;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGB332: SDL_PixelFormat = 336660481;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_XRGB4444: SDL_PixelFormat = 353504258;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_XBGR4444: SDL_PixelFormat = 357698562;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_XRGB1555: SDL_PixelFormat = 353570562;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_XBGR1555: SDL_PixelFormat = 357764866;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ARGB4444: SDL_PixelFormat = 355602434;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGBA4444: SDL_PixelFormat = 356651010;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ABGR4444: SDL_PixelFormat = 359796738;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGRA4444: SDL_PixelFormat = 360845314;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ARGB1555: SDL_PixelFormat = 355667970;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGBA5551: SDL_PixelFormat = 356782082;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ABGR1555: SDL_PixelFormat = 359862274;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGRA5551: SDL_PixelFormat = 360976386;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGB565: SDL_PixelFormat = 353701890;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGR565: SDL_PixelFormat = 357896194;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGB24: SDL_PixelFormat = 386930691;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGR24: SDL_PixelFormat = 390076419;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_XRGB8888: SDL_PixelFormat = 370546692;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGBX8888: SDL_PixelFormat = 371595268;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_XBGR8888: SDL_PixelFormat = 374740996;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGRX8888: SDL_PixelFormat = 375789572;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ARGB8888: SDL_PixelFormat = 372645892;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGBA8888: SDL_PixelFormat = 373694468;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ABGR8888: SDL_PixelFormat = 376840196;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGRA8888: SDL_PixelFormat = 377888772;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_XRGB2101010: SDL_PixelFormat = 370614276;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_XBGR2101010: SDL_PixelFormat = 374808580;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ARGB2101010: SDL_PixelFormat = 372711428;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ABGR2101010: SDL_PixelFormat = 376905732;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGB48: SDL_PixelFormat = 403714054;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGR48: SDL_PixelFormat = 406859782;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGBA64: SDL_PixelFormat = 404766728;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ARGB64: SDL_PixelFormat = 405815304;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGRA64: SDL_PixelFormat = 407912456;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ABGR64: SDL_PixelFormat = 408961032;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGB48_FLOAT: SDL_PixelFormat = 437268486;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGR48_FLOAT: SDL_PixelFormat = 440414214;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGBA64_FLOAT: SDL_PixelFormat = 438321160;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ARGB64_FLOAT: SDL_PixelFormat = 439369736;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGRA64_FLOAT: SDL_PixelFormat = 441466888;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ABGR64_FLOAT: SDL_PixelFormat = 442515464;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGB96_FLOAT: SDL_PixelFormat = 454057996;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGR96_FLOAT: SDL_PixelFormat = 457203724;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGBA128_FLOAT: SDL_PixelFormat = 455114768;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ARGB128_FLOAT: SDL_PixelFormat = 456163344;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGRA128_FLOAT: SDL_PixelFormat = 458260496;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ABGR128_FLOAT: SDL_PixelFormat = 459309072;
#[doc = "< Planar mode: Y + V + U  (3 planes)"]
pub const SDL_PixelFormat_SDL_PIXELFORMAT_YV12: SDL_PixelFormat = 842094169;
#[doc = "< Planar mode: Y + U + V  (3 planes)"]
pub const SDL_PixelFormat_SDL_PIXELFORMAT_IYUV: SDL_PixelFormat = 1448433993;
#[doc = "< Packed mode: Y0+U0+Y1+V0 (1 plane)"]
pub const SDL_PixelFormat_SDL_PIXELFORMAT_YUY2: SDL_PixelFormat = 844715353;
#[doc = "< Packed mode: U0+Y0+V0+Y1 (1 plane)"]
pub const SDL_PixelFormat_SDL_PIXELFORMAT_UYVY: SDL_PixelFormat = 1498831189;
#[doc = "< Packed mode: Y0+V0+Y1+U0 (1 plane)"]
pub const SDL_PixelFormat_SDL_PIXELFORMAT_YVYU: SDL_PixelFormat = 1431918169;
#[doc = "< Planar mode: Y + U/V interleaved  (2 planes)"]
pub const SDL_PixelFormat_SDL_PIXELFORMAT_NV12: SDL_PixelFormat = 842094158;
#[doc = "< Planar mode: Y + V/U interleaved  (2 planes)"]
pub const SDL_PixelFormat_SDL_PIXELFORMAT_NV21: SDL_PixelFormat = 825382478;
#[doc = "< Planar mode: Y + U/V interleaved  (2 planes)"]
pub const SDL_PixelFormat_SDL_PIXELFORMAT_P010: SDL_PixelFormat = 808530000;
#[doc = "< Android video texture format"]
pub const SDL_PixelFormat_SDL_PIXELFORMAT_EXTERNAL_OES: SDL_PixelFormat = 542328143;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGBA32: SDL_PixelFormat = 376840196;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ARGB32: SDL_PixelFormat = 377888772;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGRA32: SDL_PixelFormat = 372645892;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_ABGR32: SDL_PixelFormat = 373694468;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_RGBX32: SDL_PixelFormat = 374740996;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_XRGB32: SDL_PixelFormat = 375789572;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_BGRX32: SDL_PixelFormat = 370546692;
pub const SDL_PixelFormat_SDL_PIXELFORMAT_XBGR32: SDL_PixelFormat = 371595268;
#[doc = " Pixel format.\n\n SDL's pixel formats have the following naming convention:\n\n - Names with a list of components and a single bit count, such as RGB24 and\n   ABGR32, define a platform-independent encoding into bytes in the order\n   specified. For example, in RGB24 data, each pixel is encoded in 3 bytes\n   (red, green, blue) in that order, and in ABGR32 data, each pixel is\n   encoded in 4 bytes alpha, blue, green, red) in that order. Use these\n   names if the property of a format that is important to you is the order\n   of the bytes in memory or on disk.\n - Names with a bit count per component, such as ARGB8888 and XRGB1555, are\n   \"packed\" into an appropriately-sized integer in the platform's native\n   endianness. For example, ARGB8888 is a sequence of 32-bit integers; in\n   each integer, the most significant bits are alpha, and the least\n   significant bits are blue. On a little-endian CPU such as x86, the least\n   significant bits of each integer are arranged first in memory, but on a\n   big-endian CPU such as s390x, the most significant bits are arranged\n   first. Use these names if the property of a format that is important to\n   you is the meaning of each bit position within a native-endianness\n   integer.\n - In indexed formats such as INDEX4LSB, each pixel is represented by\n   encoding an index into the palette into the indicated number of bits,\n   with multiple pixels packed into each byte if appropriate. In LSB\n   formats, the first (leftmost) pixel is stored in the least-significant\n   bits of the byte; in MSB formats, it's stored in the most-significant\n   bits. INDEX8 does not need LSB/MSB variants, because each pixel exactly\n   fills one byte.\n\n The 32-bit byte-array encodings such as RGBA32 are aliases for the\n appropriate 8888 encoding for the current platform. For example, RGBA32 is\n an alias for ABGR8888 on little-endian CPUs like x86, or an alias for\n RGBA8888 on big-endian CPUs.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_PixelFormat = ::core::ffi::c_uint;
pub const SDL_ColorType_SDL_COLOR_TYPE_UNKNOWN: SDL_ColorType = 0;
pub const SDL_ColorType_SDL_COLOR_TYPE_RGB: SDL_ColorType = 1;
pub const SDL_ColorType_SDL_COLOR_TYPE_YCBCR: SDL_ColorType = 2;
#[doc = " Colorspace color type.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_ColorType = ::core::ffi::c_uint;
pub const SDL_ColorRange_SDL_COLOR_RANGE_UNKNOWN: SDL_ColorRange = 0;
#[doc = "< Narrow range, e.g. 16-235 for 8-bit RGB and luma, and 16-240 for 8-bit chroma"]
pub const SDL_ColorRange_SDL_COLOR_RANGE_LIMITED: SDL_ColorRange = 1;
#[doc = "< Full range, e.g. 0-255 for 8-bit RGB and luma, and 1-255 for 8-bit chroma"]
pub const SDL_ColorRange_SDL_COLOR_RANGE_FULL: SDL_ColorRange = 2;
#[doc = " Colorspace color range, as described by\n https://www.itu.int/rec/R-REC-BT.2100-2-201807-I/en\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_ColorRange = ::core::ffi::c_uint;
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_UNKNOWN: SDL_ColorPrimaries = 0;
#[doc = "< ITU-R BT.709-6"]
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_BT709: SDL_ColorPrimaries = 1;
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_UNSPECIFIED: SDL_ColorPrimaries = 2;
#[doc = "< ITU-R BT.470-6 System M"]
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_BT470M: SDL_ColorPrimaries = 4;
#[doc = "< ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625"]
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_BT470BG: SDL_ColorPrimaries = 5;
#[doc = "< ITU-R BT.601-7 525, SMPTE 170M"]
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_BT601: SDL_ColorPrimaries = 6;
#[doc = "< SMPTE 240M, functionally the same as SDL_COLOR_PRIMARIES_BT601"]
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_SMPTE240: SDL_ColorPrimaries = 7;
#[doc = "< Generic film (color filters using Illuminant C)"]
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_GENERIC_FILM: SDL_ColorPrimaries = 8;
#[doc = "< ITU-R BT.2020-2 / ITU-R BT.2100-0"]
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_BT2020: SDL_ColorPrimaries = 9;
#[doc = "< SMPTE ST 428-1"]
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_XYZ: SDL_ColorPrimaries = 10;
#[doc = "< SMPTE RP 431-2"]
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_SMPTE431: SDL_ColorPrimaries = 11;
#[doc = "< SMPTE EG 432-1 / DCI P3"]
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_SMPTE432: SDL_ColorPrimaries = 12;
#[doc = "< EBU Tech. 3213-E"]
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_EBU3213: SDL_ColorPrimaries = 22;
pub const SDL_ColorPrimaries_SDL_COLOR_PRIMARIES_CUSTOM: SDL_ColorPrimaries = 31;
#[doc = " Colorspace color primaries, as described by\n https://www.itu.int/rec/T-REC-H.273-201612-S/en\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_ColorPrimaries = ::core::ffi::c_uint;
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_UNKNOWN:
    SDL_TransferCharacteristics = 0;
#[doc = "< Rec. ITU-R BT.709-6 / ITU-R BT1361"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_BT709:
    SDL_TransferCharacteristics = 1;
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_UNSPECIFIED:
    SDL_TransferCharacteristics = 2;
#[doc = "< ITU-R BT.470-6 System M / ITU-R BT1700 625 PAL & SECAM"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_GAMMA22:
    SDL_TransferCharacteristics = 4;
#[doc = "< ITU-R BT.470-6 System B, G"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_GAMMA28:
    SDL_TransferCharacteristics = 5;
#[doc = "< SMPTE ST 170M / ITU-R BT.601-7 525 or 625"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_BT601:
    SDL_TransferCharacteristics = 6;
#[doc = "< SMPTE ST 240M"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_SMPTE240:
    SDL_TransferCharacteristics = 7;
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_LINEAR:
    SDL_TransferCharacteristics = 8;
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_LOG100:
    SDL_TransferCharacteristics = 9;
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_LOG100_SQRT10:
    SDL_TransferCharacteristics = 10;
#[doc = "< IEC 61966-2-4"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_IEC61966:
    SDL_TransferCharacteristics = 11;
#[doc = "< ITU-R BT1361 Extended Colour Gamut"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_BT1361:
    SDL_TransferCharacteristics = 12;
#[doc = "< IEC 61966-2-1 (sRGB or sYCC)"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_SRGB:
    SDL_TransferCharacteristics = 13;
#[doc = "< ITU-R BT2020 for 10-bit system"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_BT2020_10BIT:
    SDL_TransferCharacteristics = 14;
#[doc = "< ITU-R BT2020 for 12-bit system"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_BT2020_12BIT:
    SDL_TransferCharacteristics = 15;
#[doc = "< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_PQ: SDL_TransferCharacteristics =
    16;
#[doc = "< SMPTE ST 428-1"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_SMPTE428:
    SDL_TransferCharacteristics = 17;
#[doc = "< ARIB STD-B67, known as \"hybrid log-gamma\" (HLG)"]
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_HLG:
    SDL_TransferCharacteristics = 18;
pub const SDL_TransferCharacteristics_SDL_TRANSFER_CHARACTERISTICS_CUSTOM:
    SDL_TransferCharacteristics = 31;
#[doc = " Colorspace transfer characteristics.\n\n These are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_TransferCharacteristics = ::core::ffi::c_uint;
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_IDENTITY: SDL_MatrixCoefficients = 0;
#[doc = "< ITU-R BT.709-6"]
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_BT709: SDL_MatrixCoefficients = 1;
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_UNSPECIFIED: SDL_MatrixCoefficients = 2;
#[doc = "< US FCC Title 47"]
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_FCC: SDL_MatrixCoefficients = 4;
#[doc = "< ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625, functionally the same as SDL_MATRIX_COEFFICIENTS_BT601"]
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_BT470BG: SDL_MatrixCoefficients = 5;
#[doc = "< ITU-R BT.601-7 525"]
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_BT601: SDL_MatrixCoefficients = 6;
#[doc = "< SMPTE 240M"]
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_SMPTE240: SDL_MatrixCoefficients = 7;
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_YCGCO: SDL_MatrixCoefficients = 8;
#[doc = "< ITU-R BT.2020-2 non-constant luminance"]
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_BT2020_NCL: SDL_MatrixCoefficients = 9;
#[doc = "< ITU-R BT.2020-2 constant luminance"]
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_BT2020_CL: SDL_MatrixCoefficients = 10;
#[doc = "< SMPTE ST 2085"]
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_SMPTE2085: SDL_MatrixCoefficients = 11;
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL:
    SDL_MatrixCoefficients = 12;
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL: SDL_MatrixCoefficients =
    13;
#[doc = "< ITU-R BT.2100-0 ICTCP"]
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_ICTCP: SDL_MatrixCoefficients = 14;
pub const SDL_MatrixCoefficients_SDL_MATRIX_COEFFICIENTS_CUSTOM: SDL_MatrixCoefficients = 31;
#[doc = " Colorspace matrix coefficients.\n\n These are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_MatrixCoefficients = ::core::ffi::c_uint;
#[doc = "< RGB, no chroma sampling"]
pub const SDL_ChromaLocation_SDL_CHROMA_LOCATION_NONE: SDL_ChromaLocation = 0;
#[doc = "< In MPEG-2, MPEG-4, and AVC, Cb and Cr are taken on midpoint of the left-edge of the 2x2 square. In other words, they have the same horizontal location as the top-left pixel, but is shifted one-half pixel down vertically."]
pub const SDL_ChromaLocation_SDL_CHROMA_LOCATION_LEFT: SDL_ChromaLocation = 1;
#[doc = "< In JPEG/JFIF, H.261, and MPEG-1, Cb and Cr are taken at the center of the 2x2 square. In other words, they are offset one-half pixel to the right and one-half pixel down compared to the top-left pixel."]
pub const SDL_ChromaLocation_SDL_CHROMA_LOCATION_CENTER: SDL_ChromaLocation = 2;
#[doc = "< In HEVC for BT.2020 and BT.2100 content (in particular on Blu-rays), Cb and Cr are sampled at the same location as the group's top-left Y pixel (\"co-sited\", \"co-located\")."]
pub const SDL_ChromaLocation_SDL_CHROMA_LOCATION_TOPLEFT: SDL_ChromaLocation = 3;
#[doc = " Colorspace chroma sample location.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_ChromaLocation = ::core::ffi::c_uint;
pub const SDL_Colorspace_SDL_COLORSPACE_UNKNOWN: SDL_Colorspace = 0;
#[doc = "< Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709"]
pub const SDL_Colorspace_SDL_COLORSPACE_SRGB: SDL_Colorspace = 301991328;
#[doc = "< Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709"]
pub const SDL_Colorspace_SDL_COLORSPACE_SRGB_LINEAR: SDL_Colorspace = 301991168;
#[doc = "< Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020"]
pub const SDL_Colorspace_SDL_COLORSPACE_HDR10: SDL_Colorspace = 301999616;
#[doc = "< Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601"]
pub const SDL_Colorspace_SDL_COLORSPACE_JPEG: SDL_Colorspace = 570426566;
#[doc = "< Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601"]
pub const SDL_Colorspace_SDL_COLORSPACE_BT601_LIMITED: SDL_Colorspace = 554703046;
#[doc = "< Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601"]
pub const SDL_Colorspace_SDL_COLORSPACE_BT601_FULL: SDL_Colorspace = 571480262;
#[doc = "< Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709"]
pub const SDL_Colorspace_SDL_COLORSPACE_BT709_LIMITED: SDL_Colorspace = 554697761;
#[doc = "< Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709"]
pub const SDL_Colorspace_SDL_COLORSPACE_BT709_FULL: SDL_Colorspace = 571474977;
#[doc = "< Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020"]
pub const SDL_Colorspace_SDL_COLORSPACE_BT2020_LIMITED: SDL_Colorspace = 554706441;
#[doc = "< Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020"]
pub const SDL_Colorspace_SDL_COLORSPACE_BT2020_FULL: SDL_Colorspace = 571483657;
#[doc = "< The default colorspace for RGB surfaces if no colorspace is specified"]
pub const SDL_Colorspace_SDL_COLORSPACE_RGB_DEFAULT: SDL_Colorspace = 301991328;
#[doc = "< The default colorspace for YUV surfaces if no colorspace is specified"]
pub const SDL_Colorspace_SDL_COLORSPACE_YUV_DEFAULT: SDL_Colorspace = 570426566;
#[doc = " Colorspace definitions.\n\n Since similar colorspaces may vary in their details (matrix, transfer\n function, etc.), this is not an exhaustive list, but rather a\n representative sample of the kinds of colorspaces supported in SDL.\n\n \\since This enum is available since SDL 3.2.0.\n\n \\sa SDL_ColorPrimaries\n \\sa SDL_ColorRange\n \\sa SDL_ColorType\n \\sa SDL_MatrixCoefficients\n \\sa SDL_TransferCharacteristics"]
pub type SDL_Colorspace = ::core::ffi::c_uint;
#[doc = " A structure that represents a color as RGBA components.\n\n The bits of this structure can be directly reinterpreted as an\n integer-packed color which uses the SDL_PIXELFORMAT_RGBA32 format\n (SDL_PIXELFORMAT_ABGR8888 on little-endian systems and\n SDL_PIXELFORMAT_RGBA8888 on big-endian systems).\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Color {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
    pub a: Uint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_Color"][::core::mem::size_of::<SDL_Color>() - 4usize];
    ["Alignment of SDL_Color"][::core::mem::align_of::<SDL_Color>() - 1usize];
    ["Offset of field: SDL_Color::r"][::core::mem::offset_of!(SDL_Color, r) - 0usize];
    ["Offset of field: SDL_Color::g"][::core::mem::offset_of!(SDL_Color, g) - 1usize];
    ["Offset of field: SDL_Color::b"][::core::mem::offset_of!(SDL_Color, b) - 2usize];
    ["Offset of field: SDL_Color::a"][::core::mem::offset_of!(SDL_Color, a) - 3usize];
};
#[doc = " The bits of this structure can be directly reinterpreted as a float-packed\n color which uses the SDL_PIXELFORMAT_RGBA128_FLOAT format\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_FColor {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_FColor"][::core::mem::size_of::<SDL_FColor>() - 16usize];
    ["Alignment of SDL_FColor"][::core::mem::align_of::<SDL_FColor>() - 4usize];
    ["Offset of field: SDL_FColor::r"][::core::mem::offset_of!(SDL_FColor, r) - 0usize];
    ["Offset of field: SDL_FColor::g"][::core::mem::offset_of!(SDL_FColor, g) - 4usize];
    ["Offset of field: SDL_FColor::b"][::core::mem::offset_of!(SDL_FColor, b) - 8usize];
    ["Offset of field: SDL_FColor::a"][::core::mem::offset_of!(SDL_FColor, a) - 12usize];
};
#[doc = " A set of indexed colors representing a palette.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_SetPaletteColors"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Palette {
    #[doc = "< number of elements in `colors`."]
    pub ncolors: ::core::ffi::c_int,
    #[doc = "< an array of colors, `ncolors` long."]
    pub colors: *mut SDL_Color,
    #[doc = "< internal use only, do not touch."]
    pub version: Uint32,
    #[doc = "< internal use only, do not touch."]
    pub refcount: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_Palette"][::core::mem::size_of::<SDL_Palette>() - 24usize];
    ["Alignment of SDL_Palette"][::core::mem::align_of::<SDL_Palette>() - 8usize];
    ["Offset of field: SDL_Palette::ncolors"]
        [::core::mem::offset_of!(SDL_Palette, ncolors) - 0usize];
    ["Offset of field: SDL_Palette::colors"][::core::mem::offset_of!(SDL_Palette, colors) - 8usize];
    ["Offset of field: SDL_Palette::version"]
        [::core::mem::offset_of!(SDL_Palette, version) - 16usize];
    ["Offset of field: SDL_Palette::refcount"]
        [::core::mem::offset_of!(SDL_Palette, refcount) - 20usize];
};
#[doc = " Details about the format of a pixel.\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_PixelFormatDetails {
    pub format: SDL_PixelFormat,
    pub bits_per_pixel: Uint8,
    pub bytes_per_pixel: Uint8,
    pub padding: [Uint8; 2usize],
    pub Rmask: Uint32,
    pub Gmask: Uint32,
    pub Bmask: Uint32,
    pub Amask: Uint32,
    pub Rbits: Uint8,
    pub Gbits: Uint8,
    pub Bbits: Uint8,
    pub Abits: Uint8,
    pub Rshift: Uint8,
    pub Gshift: Uint8,
    pub Bshift: Uint8,
    pub Ashift: Uint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_PixelFormatDetails"][::core::mem::size_of::<SDL_PixelFormatDetails>() - 32usize];
    ["Alignment of SDL_PixelFormatDetails"]
        [::core::mem::align_of::<SDL_PixelFormatDetails>() - 4usize];
    ["Offset of field: SDL_PixelFormatDetails::format"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, format) - 0usize];
    ["Offset of field: SDL_PixelFormatDetails::bits_per_pixel"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, bits_per_pixel) - 4usize];
    ["Offset of field: SDL_PixelFormatDetails::bytes_per_pixel"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, bytes_per_pixel) - 5usize];
    ["Offset of field: SDL_PixelFormatDetails::padding"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, padding) - 6usize];
    ["Offset of field: SDL_PixelFormatDetails::Rmask"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, Rmask) - 8usize];
    ["Offset of field: SDL_PixelFormatDetails::Gmask"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, Gmask) - 12usize];
    ["Offset of field: SDL_PixelFormatDetails::Bmask"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, Bmask) - 16usize];
    ["Offset of field: SDL_PixelFormatDetails::Amask"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, Amask) - 20usize];
    ["Offset of field: SDL_PixelFormatDetails::Rbits"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, Rbits) - 24usize];
    ["Offset of field: SDL_PixelFormatDetails::Gbits"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, Gbits) - 25usize];
    ["Offset of field: SDL_PixelFormatDetails::Bbits"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, Bbits) - 26usize];
    ["Offset of field: SDL_PixelFormatDetails::Abits"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, Abits) - 27usize];
    ["Offset of field: SDL_PixelFormatDetails::Rshift"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, Rshift) - 28usize];
    ["Offset of field: SDL_PixelFormatDetails::Gshift"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, Gshift) - 29usize];
    ["Offset of field: SDL_PixelFormatDetails::Bshift"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, Bshift) - 30usize];
    ["Offset of field: SDL_PixelFormatDetails::Ashift"]
        [::core::mem::offset_of!(SDL_PixelFormatDetails, Ashift) - 31usize];
};
unsafe extern "C" {
    #[doc = " Get the human readable name of a pixel format.\n\n \\param format the pixel format to query.\n \\returns the human readable name of the specified pixel format or\n          \"SDL_PIXELFORMAT_UNKNOWN\" if the format isn't recognized.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetPixelFormatName(format: SDL_PixelFormat) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Convert one of the enumerated pixel formats to a bpp value and RGBA masks.\n\n \\param format one of the SDL_PixelFormat values.\n \\param bpp a bits per pixel value; usually 15, 16, or 32.\n \\param Rmask a pointer filled in with the red mask for the format.\n \\param Gmask a pointer filled in with the green mask for the format.\n \\param Bmask a pointer filled in with the blue mask for the format.\n \\param Amask a pointer filled in with the alpha mask for the format.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetPixelFormatForMasks"]
    pub fn SDL_GetMasksForPixelFormat(
        format: SDL_PixelFormat,
        bpp: *mut ::core::ffi::c_int,
        Rmask: *mut Uint32,
        Gmask: *mut Uint32,
        Bmask: *mut Uint32,
        Amask: *mut Uint32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Convert a bpp value and RGBA masks to an enumerated pixel format.\n\n This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't\n possible.\n\n \\param bpp a bits per pixel value; usually 15, 16, or 32.\n \\param Rmask the red mask for the format.\n \\param Gmask the green mask for the format.\n \\param Bmask the blue mask for the format.\n \\param Amask the alpha mask for the format.\n \\returns the SDL_PixelFormat value corresponding to the format masks, or\n          SDL_PIXELFORMAT_UNKNOWN if there isn't a match.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetMasksForPixelFormat"]
    pub fn SDL_GetPixelFormatForMasks(
        bpp: ::core::ffi::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> SDL_PixelFormat;
}
unsafe extern "C" {
    #[doc = " Create an SDL_PixelFormatDetails structure corresponding to a pixel format.\n\n Returned structure may come from a shared global cache (i.e. not newly\n allocated), and hence should not be modified, especially the palette. Weird\n errors such as `Blit combination not supported` may occur.\n\n \\param format one of the SDL_PixelFormat values.\n \\returns a pointer to a SDL_PixelFormatDetails structure or NULL on\n          failure; call SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetPixelFormatDetails(format: SDL_PixelFormat) -> *const SDL_PixelFormatDetails;
}
unsafe extern "C" {
    #[doc = " Create a palette structure with the specified number of color entries.\n\n The palette entries are initialized to white.\n\n \\param ncolors represents the number of color entries in the color palette.\n \\returns a new SDL_Palette structure on success or NULL on failure (e.g. if\n          there wasn't enough memory); call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DestroyPalette\n \\sa SDL_SetPaletteColors\n \\sa SDL_SetSurfacePalette"]
    pub fn SDL_CreatePalette(ncolors: ::core::ffi::c_int) -> *mut SDL_Palette;
}
unsafe extern "C" {
    #[doc = " Set a range of colors in a palette.\n\n \\param palette the SDL_Palette structure to modify.\n \\param colors an array of SDL_Color structures to copy into the palette.\n \\param firstcolor the index of the first palette entry to modify.\n \\param ncolors the number of entries to modify.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread, as long as\n               the palette is not modified or destroyed in another thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetPaletteColors(
        palette: *mut SDL_Palette,
        colors: *const SDL_Color,
        firstcolor: ::core::ffi::c_int,
        ncolors: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Free a palette created with SDL_CreatePalette().\n\n \\param palette the SDL_Palette structure to be freed.\n\n \\threadsafety It is safe to call this function from any thread, as long as\n               the palette is not modified or destroyed in another thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreatePalette"]
    pub fn SDL_DestroyPalette(palette: *mut SDL_Palette);
}
unsafe extern "C" {
    #[doc = " Map an RGB triple to an opaque pixel value for a given pixel format.\n\n This function maps the RGB color value to the specified pixel format and\n returns the pixel value best approximating the given RGB color value for\n the given pixel format.\n\n If the format has a palette (8-bit) the index of the closest matching color\n in the palette will be returned.\n\n If the specified pixel format has an alpha component it will be returned as\n all 1 bits (fully opaque).\n\n If the pixel format bpp (color depth) is less than 32-bpp then the unused\n upper bits of the return value can safely be ignored (e.g., with a 16-bpp\n format the return value can be assigned to a Uint16, and similarly a Uint8\n for an 8-bpp format).\n\n \\param format a pointer to SDL_PixelFormatDetails describing the pixel\n               format.\n \\param palette an optional palette for indexed formats, may be NULL.\n \\param r the red component of the pixel in the range 0-255.\n \\param g the green component of the pixel in the range 0-255.\n \\param b the blue component of the pixel in the range 0-255.\n \\returns a pixel value.\n\n \\threadsafety It is safe to call this function from any thread, as long as\n               the palette is not modified.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetPixelFormatDetails\n \\sa SDL_GetRGB\n \\sa SDL_MapRGBA\n \\sa SDL_MapSurfaceRGB"]
    pub fn SDL_MapRGB(
        format: *const SDL_PixelFormatDetails,
        palette: *const SDL_Palette,
        r: Uint8,
        g: Uint8,
        b: Uint8,
    ) -> Uint32;
}
unsafe extern "C" {
    #[doc = " Map an RGBA quadruple to a pixel value for a given pixel format.\n\n This function maps the RGBA color value to the specified pixel format and\n returns the pixel value best approximating the given RGBA color value for\n the given pixel format.\n\n If the specified pixel format has no alpha component the alpha value will\n be ignored (as it will be in formats with a palette).\n\n If the format has a palette (8-bit) the index of the closest matching color\n in the palette will be returned.\n\n If the pixel format bpp (color depth) is less than 32-bpp then the unused\n upper bits of the return value can safely be ignored (e.g., with a 16-bpp\n format the return value can be assigned to a Uint16, and similarly a Uint8\n for an 8-bpp format).\n\n \\param format a pointer to SDL_PixelFormatDetails describing the pixel\n               format.\n \\param palette an optional palette for indexed formats, may be NULL.\n \\param r the red component of the pixel in the range 0-255.\n \\param g the green component of the pixel in the range 0-255.\n \\param b the blue component of the pixel in the range 0-255.\n \\param a the alpha component of the pixel in the range 0-255.\n \\returns a pixel value.\n\n \\threadsafety It is safe to call this function from any thread, as long as\n               the palette is not modified.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetPixelFormatDetails\n \\sa SDL_GetRGBA\n \\sa SDL_MapRGB\n \\sa SDL_MapSurfaceRGBA"]
    pub fn SDL_MapRGBA(
        format: *const SDL_PixelFormatDetails,
        palette: *const SDL_Palette,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> Uint32;
}
unsafe extern "C" {
    #[doc = " Get RGB values from a pixel in the specified format.\n\n This function uses the entire 8-bit [0..255] range when converting color\n components from pixel formats with less than 8-bits per RGB component\n (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,\n 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).\n\n \\param pixel a pixel value.\n \\param format a pointer to SDL_PixelFormatDetails describing the pixel\n               format.\n \\param palette an optional palette for indexed formats, may be NULL.\n \\param r a pointer filled in with the red component, may be NULL.\n \\param g a pointer filled in with the green component, may be NULL.\n \\param b a pointer filled in with the blue component, may be NULL.\n\n \\threadsafety It is safe to call this function from any thread, as long as\n               the palette is not modified.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetPixelFormatDetails\n \\sa SDL_GetRGBA\n \\sa SDL_MapRGB\n \\sa SDL_MapRGBA"]
    pub fn SDL_GetRGB(
        pixel: Uint32,
        format: *const SDL_PixelFormatDetails,
        palette: *const SDL_Palette,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    );
}
unsafe extern "C" {
    #[doc = " Get RGBA values from a pixel in the specified format.\n\n This function uses the entire 8-bit [0..255] range when converting color\n components from pixel formats with less than 8-bits per RGB component\n (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,\n 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).\n\n If the surface has no alpha component, the alpha will be returned as 0xff\n (100% opaque).\n\n \\param pixel a pixel value.\n \\param format a pointer to SDL_PixelFormatDetails describing the pixel\n               format.\n \\param palette an optional palette for indexed formats, may be NULL.\n \\param r a pointer filled in with the red component, may be NULL.\n \\param g a pointer filled in with the green component, may be NULL.\n \\param b a pointer filled in with the blue component, may be NULL.\n \\param a a pointer filled in with the alpha component, may be NULL.\n\n \\threadsafety It is safe to call this function from any thread, as long as\n               the palette is not modified.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetPixelFormatDetails\n \\sa SDL_GetRGB\n \\sa SDL_MapRGB\n \\sa SDL_MapRGBA"]
    pub fn SDL_GetRGBA(
        pixel: Uint32,
        format: *const SDL_PixelFormatDetails,
        palette: *const SDL_Palette,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    );
}
#[doc = " A set of blend modes used in drawing operations.\n\n These predefined blend modes are supported everywhere.\n\n Additional values may be obtained from SDL_ComposeCustomBlendMode.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_ComposeCustomBlendMode"]
pub type SDL_BlendMode = Uint32;
#[doc = "< dst + src: supported by all renderers"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_ADD: SDL_BlendOperation = 1;
#[doc = "< src - dst : supported by D3D, OpenGL, OpenGLES, and Vulkan"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_SUBTRACT: SDL_BlendOperation = 2;
#[doc = "< dst - src : supported by D3D, OpenGL, OpenGLES, and Vulkan"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_REV_SUBTRACT: SDL_BlendOperation = 3;
#[doc = "< min(dst, src) : supported by D3D, OpenGL, OpenGLES, and Vulkan"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_MINIMUM: SDL_BlendOperation = 4;
#[doc = "< max(dst, src) : supported by D3D, OpenGL, OpenGLES, and Vulkan"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_MAXIMUM: SDL_BlendOperation = 5;
#[doc = " The blend operation used when combining source and destination pixel\n components.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_BlendOperation = ::core::ffi::c_uint;
#[doc = "< 0, 0, 0, 0"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ZERO: SDL_BlendFactor = 1;
#[doc = "< 1, 1, 1, 1"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE: SDL_BlendFactor = 2;
#[doc = "< srcR, srcG, srcB, srcA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_SRC_COLOR: SDL_BlendFactor = 3;
#[doc = "< 1-srcR, 1-srcG, 1-srcB, 1-srcA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR: SDL_BlendFactor = 4;
#[doc = "< srcA, srcA, srcA, srcA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_SRC_ALPHA: SDL_BlendFactor = 5;
#[doc = "< 1-srcA, 1-srcA, 1-srcA, 1-srcA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA: SDL_BlendFactor = 6;
#[doc = "< dstR, dstG, dstB, dstA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_DST_COLOR: SDL_BlendFactor = 7;
#[doc = "< 1-dstR, 1-dstG, 1-dstB, 1-dstA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR: SDL_BlendFactor = 8;
#[doc = "< dstA, dstA, dstA, dstA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_DST_ALPHA: SDL_BlendFactor = 9;
#[doc = "< 1-dstA, 1-dstA, 1-dstA, 1-dstA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA: SDL_BlendFactor = 10;
#[doc = " The normalized factor used to multiply pixel components.\n\n The blend factors are multiplied with the pixels from a drawing operation\n (src) and the pixels from the render target (dst) before the blend\n operation. The comma-separated factors listed above are always applied in\n the component order red, green, blue, and alpha.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_BlendFactor = ::core::ffi::c_uint;
unsafe extern "C" {
    #[doc = " Compose a custom blend mode for renderers.\n\n The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept\n the SDL_BlendMode returned by this function if the renderer supports it.\n\n A blend mode controls how the pixels from a drawing operation (source) get\n combined with the pixels from the render target (destination). First, the\n components of the source and destination pixels get multiplied with their\n blend factors. Then, the blend operation takes the two products and\n calculates the result that will get stored in the render target.\n\n Expressed in pseudocode, it would look like this:\n\n ```c\n dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);\n dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);\n ```\n\n Where the functions `colorOperation(src, dst)` and `alphaOperation(src,\n dst)` can return one of the following:\n\n - `src + dst`\n - `src - dst`\n - `dst - src`\n - `min(src, dst)`\n - `max(src, dst)`\n\n The red, green, and blue components are always multiplied with the first,\n second, and third components of the SDL_BlendFactor, respectively. The\n fourth component is not used.\n\n The alpha component is always multiplied with the fourth component of the\n SDL_BlendFactor. The other components are not used in the alpha\n calculation.\n\n Support for these blend modes varies for each renderer. To check if a\n specific SDL_BlendMode is supported, create a renderer and pass it to\n either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will\n return with an error if the blend mode is not supported.\n\n This list describes the support of custom blend modes for each renderer.\n All renderers support the four blend modes listed in the SDL_BlendMode\n enumeration.\n\n - **direct3d**: Supports all operations with all factors. However, some\n   factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and\n   `SDL_BLENDOPERATION_MAXIMUM`.\n - **direct3d11**: Same as Direct3D 9.\n - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all\n   factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.\n - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,\n   `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`\n   operations with all factors.\n - **psp**: No custom blend mode support.\n - **software**: No custom blend mode support.\n\n Some renderers do not provide an alpha component for the default render\n target. The `SDL_BLENDFACTOR_DST_ALPHA` and\n `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this\n case.\n\n \\param srcColorFactor the SDL_BlendFactor applied to the red, green, and\n                       blue components of the source pixels.\n \\param dstColorFactor the SDL_BlendFactor applied to the red, green, and\n                       blue components of the destination pixels.\n \\param colorOperation the SDL_BlendOperation used to combine the red,\n                       green, and blue components of the source and\n                       destination pixels.\n \\param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of\n                       the source pixels.\n \\param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of\n                       the destination pixels.\n \\param alphaOperation the SDL_BlendOperation used to combine the alpha\n                       component of the source and destination pixels.\n \\returns an SDL_BlendMode that represents the chosen factors and\n          operations.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetRenderDrawBlendMode\n \\sa SDL_GetRenderDrawBlendMode\n \\sa SDL_SetTextureBlendMode\n \\sa SDL_GetTextureBlendMode"]
    pub fn SDL_ComposeCustomBlendMode(
        srcColorFactor: SDL_BlendFactor,
        dstColorFactor: SDL_BlendFactor,
        colorOperation: SDL_BlendOperation,
        srcAlphaFactor: SDL_BlendFactor,
        dstAlphaFactor: SDL_BlendFactor,
        alphaOperation: SDL_BlendOperation,
    ) -> SDL_BlendMode;
}
#[doc = " The structure that defines a point (using integers).\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_GetRectEnclosingPoints\n \\sa SDL_PointInRect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Point {
    pub x: ::core::ffi::c_int,
    pub y: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_Point"][::core::mem::size_of::<SDL_Point>() - 8usize];
    ["Alignment of SDL_Point"][::core::mem::align_of::<SDL_Point>() - 4usize];
    ["Offset of field: SDL_Point::x"][::core::mem::offset_of!(SDL_Point, x) - 0usize];
    ["Offset of field: SDL_Point::y"][::core::mem::offset_of!(SDL_Point, y) - 4usize];
};
#[doc = " The structure that defines a point (using floating point values).\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_GetRectEnclosingPointsFloat\n \\sa SDL_PointInRectFloat"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_FPoint {
    pub x: f32,
    pub y: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_FPoint"][::core::mem::size_of::<SDL_FPoint>() - 8usize];
    ["Alignment of SDL_FPoint"][::core::mem::align_of::<SDL_FPoint>() - 4usize];
    ["Offset of field: SDL_FPoint::x"][::core::mem::offset_of!(SDL_FPoint, x) - 0usize];
    ["Offset of field: SDL_FPoint::y"][::core::mem::offset_of!(SDL_FPoint, y) - 4usize];
};
#[doc = " A rectangle, with the origin at the upper left (using integers).\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_RectEmpty\n \\sa SDL_RectsEqual\n \\sa SDL_HasRectIntersection\n \\sa SDL_GetRectIntersection\n \\sa SDL_GetRectAndLineIntersection\n \\sa SDL_GetRectUnion\n \\sa SDL_GetRectEnclosingPoints"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Rect {
    pub x: ::core::ffi::c_int,
    pub y: ::core::ffi::c_int,
    pub w: ::core::ffi::c_int,
    pub h: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_Rect"][::core::mem::size_of::<SDL_Rect>() - 16usize];
    ["Alignment of SDL_Rect"][::core::mem::align_of::<SDL_Rect>() - 4usize];
    ["Offset of field: SDL_Rect::x"][::core::mem::offset_of!(SDL_Rect, x) - 0usize];
    ["Offset of field: SDL_Rect::y"][::core::mem::offset_of!(SDL_Rect, y) - 4usize];
    ["Offset of field: SDL_Rect::w"][::core::mem::offset_of!(SDL_Rect, w) - 8usize];
    ["Offset of field: SDL_Rect::h"][::core::mem::offset_of!(SDL_Rect, h) - 12usize];
};
#[doc = " A rectangle, with the origin at the upper left (using floating point\n values).\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_RectEmptyFloat\n \\sa SDL_RectsEqualFloat\n \\sa SDL_RectsEqualEpsilon\n \\sa SDL_HasRectIntersectionFloat\n \\sa SDL_GetRectIntersectionFloat\n \\sa SDL_GetRectAndLineIntersectionFloat\n \\sa SDL_GetRectUnionFloat\n \\sa SDL_GetRectEnclosingPointsFloat\n \\sa SDL_PointInRectFloat"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_FRect {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_FRect"][::core::mem::size_of::<SDL_FRect>() - 16usize];
    ["Alignment of SDL_FRect"][::core::mem::align_of::<SDL_FRect>() - 4usize];
    ["Offset of field: SDL_FRect::x"][::core::mem::offset_of!(SDL_FRect, x) - 0usize];
    ["Offset of field: SDL_FRect::y"][::core::mem::offset_of!(SDL_FRect, y) - 4usize];
    ["Offset of field: SDL_FRect::w"][::core::mem::offset_of!(SDL_FRect, w) - 8usize];
    ["Offset of field: SDL_FRect::h"][::core::mem::offset_of!(SDL_FRect, h) - 12usize];
};
unsafe extern "C" {
    #[doc = " Determine whether two rectangles intersect.\n\n If either pointer is NULL the function will return false.\n\n \\param A an SDL_Rect structure representing the first rectangle.\n \\param B an SDL_Rect structure representing the second rectangle.\n \\returns true if there is an intersection, false otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetRectIntersection"]
    pub fn SDL_HasRectIntersection(A: *const SDL_Rect, B: *const SDL_Rect) -> bool;
}
unsafe extern "C" {
    #[doc = " Calculate the intersection of two rectangles.\n\n If `result` is NULL then this function will return false.\n\n \\param A an SDL_Rect structure representing the first rectangle.\n \\param B an SDL_Rect structure representing the second rectangle.\n \\param result an SDL_Rect structure filled in with the intersection of\n               rectangles `A` and `B`.\n \\returns true if there is an intersection, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_HasRectIntersection"]
    pub fn SDL_GetRectIntersection(
        A: *const SDL_Rect,
        B: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Calculate the union of two rectangles.\n\n \\param A an SDL_Rect structure representing the first rectangle.\n \\param B an SDL_Rect structure representing the second rectangle.\n \\param result an SDL_Rect structure filled in with the union of rectangles\n               `A` and `B`.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetRectUnion(A: *const SDL_Rect, B: *const SDL_Rect, result: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    #[doc = " Calculate a minimal rectangle enclosing a set of points.\n\n If `clip` is not NULL then only points inside of the clipping rectangle are\n considered.\n\n \\param points an array of SDL_Point structures representing points to be\n               enclosed.\n \\param count the number of structures in the `points` array.\n \\param clip an SDL_Rect used for clipping or NULL to enclose all points.\n \\param result an SDL_Rect structure filled in with the minimal enclosing\n               rectangle.\n \\returns true if any points were enclosed or false if all the points were\n          outside of the clipping rectangle.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetRectEnclosingPoints(
        points: *const SDL_Point,
        count: ::core::ffi::c_int,
        clip: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Calculate the intersection of a rectangle and line segment.\n\n This function is used to clip a line segment to a rectangle. A line segment\n contained entirely within the rectangle or that does not intersect will\n remain unchanged. A line segment that crosses the rectangle at either or\n both ends will be clipped to the boundary of the rectangle and the new\n coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.\n\n \\param rect an SDL_Rect structure representing the rectangle to intersect.\n \\param X1 a pointer to the starting X-coordinate of the line.\n \\param Y1 a pointer to the starting Y-coordinate of the line.\n \\param X2 a pointer to the ending X-coordinate of the line.\n \\param Y2 a pointer to the ending Y-coordinate of the line.\n \\returns true if there is an intersection, false otherwise.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetRectAndLineIntersection(
        rect: *const SDL_Rect,
        X1: *mut ::core::ffi::c_int,
        Y1: *mut ::core::ffi::c_int,
        X2: *mut ::core::ffi::c_int,
        Y2: *mut ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Determine whether two rectangles intersect with float precision.\n\n If either pointer is NULL the function will return false.\n\n \\param A an SDL_FRect structure representing the first rectangle.\n \\param B an SDL_FRect structure representing the second rectangle.\n \\returns true if there is an intersection, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetRectIntersection"]
    pub fn SDL_HasRectIntersectionFloat(A: *const SDL_FRect, B: *const SDL_FRect) -> bool;
}
unsafe extern "C" {
    #[doc = " Calculate the intersection of two rectangles with float precision.\n\n If `result` is NULL then this function will return false.\n\n \\param A an SDL_FRect structure representing the first rectangle.\n \\param B an SDL_FRect structure representing the second rectangle.\n \\param result an SDL_FRect structure filled in with the intersection of\n               rectangles `A` and `B`.\n \\returns true if there is an intersection, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_HasRectIntersectionFloat"]
    pub fn SDL_GetRectIntersectionFloat(
        A: *const SDL_FRect,
        B: *const SDL_FRect,
        result: *mut SDL_FRect,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Calculate the union of two rectangles with float precision.\n\n \\param A an SDL_FRect structure representing the first rectangle.\n \\param B an SDL_FRect structure representing the second rectangle.\n \\param result an SDL_FRect structure filled in with the union of rectangles\n               `A` and `B`.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetRectUnionFloat(
        A: *const SDL_FRect,
        B: *const SDL_FRect,
        result: *mut SDL_FRect,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Calculate a minimal rectangle enclosing a set of points with float\n precision.\n\n If `clip` is not NULL then only points inside of the clipping rectangle are\n considered.\n\n \\param points an array of SDL_FPoint structures representing points to be\n               enclosed.\n \\param count the number of structures in the `points` array.\n \\param clip an SDL_FRect used for clipping or NULL to enclose all points.\n \\param result an SDL_FRect structure filled in with the minimal enclosing\n               rectangle.\n \\returns true if any points were enclosed or false if all the points were\n          outside of the clipping rectangle.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetRectEnclosingPointsFloat(
        points: *const SDL_FPoint,
        count: ::core::ffi::c_int,
        clip: *const SDL_FRect,
        result: *mut SDL_FRect,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Calculate the intersection of a rectangle and line segment with float\n precision.\n\n This function is used to clip a line segment to a rectangle. A line segment\n contained entirely within the rectangle or that does not intersect will\n remain unchanged. A line segment that crosses the rectangle at either or\n both ends will be clipped to the boundary of the rectangle and the new\n coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.\n\n \\param rect an SDL_FRect structure representing the rectangle to intersect.\n \\param X1 a pointer to the starting X-coordinate of the line.\n \\param Y1 a pointer to the starting Y-coordinate of the line.\n \\param X2 a pointer to the ending X-coordinate of the line.\n \\param Y2 a pointer to the ending Y-coordinate of the line.\n \\returns true if there is an intersection, false otherwise.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetRectAndLineIntersectionFloat(
        rect: *const SDL_FRect,
        X1: *mut f32,
        Y1: *mut f32,
        X2: *mut f32,
        Y2: *mut f32,
    ) -> bool;
}
#[doc = " The flags on an SDL_Surface.\n\n These are generally considered read-only.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_SurfaceFlags = Uint32;
#[doc = "< nearest pixel sampling"]
pub const SDL_ScaleMode_SDL_SCALEMODE_NEAREST: SDL_ScaleMode = 0;
#[doc = "< linear filtering"]
pub const SDL_ScaleMode_SDL_SCALEMODE_LINEAR: SDL_ScaleMode = 1;
#[doc = " The scaling mode.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_ScaleMode = ::core::ffi::c_uint;
#[doc = "< Do not flip"]
pub const SDL_FlipMode_SDL_FLIP_NONE: SDL_FlipMode = 0;
#[doc = "< flip horizontally"]
pub const SDL_FlipMode_SDL_FLIP_HORIZONTAL: SDL_FlipMode = 1;
#[doc = "< flip vertically"]
pub const SDL_FlipMode_SDL_FLIP_VERTICAL: SDL_FlipMode = 2;
#[doc = " The flip mode.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_FlipMode = ::core::ffi::c_uint;
#[doc = " A collection of pixels used in software blitting.\n\n Pixels are arranged in memory in rows, with the top row first. Each row\n occupies an amount of memory given by the pitch (sometimes known as the row\n stride in non-SDL APIs).\n\n Within each row, pixels are arranged from left to right until the width is\n reached. Each pixel occupies a number of bits appropriate for its format,\n with most formats representing each pixel as one or more whole bytes (in\n some indexed formats, instead multiple pixels are packed into each byte),\n and a byte order given by the format. After encoding all pixels, any\n remaining bytes to reach the pitch are used as padding to reach a desired\n alignment, and have undefined contents.\n\n When a surface holds YUV format data, the planes are assumed to be\n contiguous without padding between them, e.g. a 32x32 surface in NV12\n format with a pitch of 32 would consist of 32x32 bytes of Y plane followed\n by 32x16 bytes of UV plane.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_CreateSurface\n \\sa SDL_DestroySurface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Surface {
    #[doc = "< The flags of the surface, read-only"]
    pub flags: SDL_SurfaceFlags,
    #[doc = "< The format of the surface, read-only"]
    pub format: SDL_PixelFormat,
    #[doc = "< The width of the surface, read-only."]
    pub w: ::core::ffi::c_int,
    #[doc = "< The height of the surface, read-only."]
    pub h: ::core::ffi::c_int,
    #[doc = "< The distance in bytes between rows of pixels, read-only"]
    pub pitch: ::core::ffi::c_int,
    #[doc = "< A pointer to the pixels of the surface, the pixels are writeable if non-NULL"]
    pub pixels: *mut ::core::ffi::c_void,
    #[doc = "< Application reference count, used when freeing surface"]
    pub refcount: ::core::ffi::c_int,
    #[doc = "< Reserved for internal use"]
    pub reserved: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_Surface"][::core::mem::size_of::<SDL_Surface>() - 48usize];
    ["Alignment of SDL_Surface"][::core::mem::align_of::<SDL_Surface>() - 8usize];
    ["Offset of field: SDL_Surface::flags"][::core::mem::offset_of!(SDL_Surface, flags) - 0usize];
    ["Offset of field: SDL_Surface::format"][::core::mem::offset_of!(SDL_Surface, format) - 4usize];
    ["Offset of field: SDL_Surface::w"][::core::mem::offset_of!(SDL_Surface, w) - 8usize];
    ["Offset of field: SDL_Surface::h"][::core::mem::offset_of!(SDL_Surface, h) - 12usize];
    ["Offset of field: SDL_Surface::pitch"][::core::mem::offset_of!(SDL_Surface, pitch) - 16usize];
    ["Offset of field: SDL_Surface::pixels"]
        [::core::mem::offset_of!(SDL_Surface, pixels) - 24usize];
    ["Offset of field: SDL_Surface::refcount"]
        [::core::mem::offset_of!(SDL_Surface, refcount) - 32usize];
    ["Offset of field: SDL_Surface::reserved"]
        [::core::mem::offset_of!(SDL_Surface, reserved) - 40usize];
};
unsafe extern "C" {
    #[doc = " Allocate a new surface with a specific pixel format.\n\n The pixels of the new surface are initialized to zero.\n\n \\param width the width of the surface.\n \\param height the height of the surface.\n \\param format the SDL_PixelFormat for the new surface's pixel format.\n \\returns the new SDL_Surface structure that is created or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateSurfaceFrom\n \\sa SDL_DestroySurface"]
    pub fn SDL_CreateSurface(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        format: SDL_PixelFormat,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Allocate a new surface with a specific pixel format and existing pixel\n data.\n\n No copy is made of the pixel data. Pixel data is not managed automatically;\n you must free the surface before you free the pixel data.\n\n Pitch is the offset in bytes from one row of pixels to the next, e.g.\n `width*4` for `SDL_PIXELFORMAT_RGBA8888`.\n\n You may pass NULL for pixels and 0 for pitch to create a surface that you\n will fill in with valid values later.\n\n \\param width the width of the surface.\n \\param height the height of the surface.\n \\param format the SDL_PixelFormat for the new surface's pixel format.\n \\param pixels a pointer to existing pixel data.\n \\param pitch the number of bytes between each row, including padding.\n \\returns the new SDL_Surface structure that is created or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateSurface\n \\sa SDL_DestroySurface"]
    pub fn SDL_CreateSurfaceFrom(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        format: SDL_PixelFormat,
        pixels: *mut ::core::ffi::c_void,
        pitch: ::core::ffi::c_int,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Free a surface.\n\n It is safe to pass NULL to this function.\n\n \\param surface the SDL_Surface to free.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateSurface\n \\sa SDL_CreateSurfaceFrom"]
    pub fn SDL_DestroySurface(surface: *mut SDL_Surface);
}
unsafe extern "C" {
    #[doc = " Get the properties associated with a surface.\n\n The following properties are understood by SDL:\n\n - `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point\n   surfaces, this defines the value of 100% diffuse white, with higher\n   values being displayed in the High Dynamic Range headroom. This defaults\n   to 203 for HDR10 surfaces and 1.0 for floating point surfaces.\n - `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point\n   surfaces, this defines the maximum dynamic range used by the content, in\n   terms of the SDR white point. This defaults to 0.0, which disables tone\n   mapping.\n - `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator\n   used when compressing from a surface with high dynamic range to another\n   with lower dynamic range. Currently this supports \"chrome\", which uses\n   the same tone mapping that Chrome uses for HDR content, the form \"*=N\",\n   where N is a floating point scale factor applied in linear space, and\n   \"none\", which disables tone mapping. This defaults to \"chrome\".\n\n \\param surface the SDL_Surface structure to query.\n \\returns a valid property ID on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSurfaceProperties(surface: *mut SDL_Surface) -> SDL_PropertiesID;
}
unsafe extern "C" {
    #[doc = " Set the colorspace used by a surface.\n\n Setting the colorspace doesn't change the pixels, only how they are\n interpreted in color operations.\n\n \\param surface the SDL_Surface structure to update.\n \\param colorspace an SDL_Colorspace value describing the surface\n                   colorspace.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetSurfaceColorspace"]
    pub fn SDL_SetSurfaceColorspace(surface: *mut SDL_Surface, colorspace: SDL_Colorspace) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the colorspace used by a surface.\n\n The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point\n formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for\n other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.\n\n \\param surface the SDL_Surface structure to query.\n \\returns the colorspace used by the surface, or SDL_COLORSPACE_UNKNOWN if\n          the surface is NULL.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetSurfaceColorspace"]
    pub fn SDL_GetSurfaceColorspace(surface: *mut SDL_Surface) -> SDL_Colorspace;
}
unsafe extern "C" {
    #[doc = " Create a palette and associate it with a surface.\n\n This function creates a palette compatible with the provided surface. The\n palette is then returned for you to modify, and the surface will\n automatically use the new palette in future operations. You do not need to\n destroy the returned palette, it will be freed when the reference count\n reaches 0, usually when the surface is destroyed.\n\n Bitmap surfaces (with format SDL_PIXELFORMAT_INDEX1LSB or\n SDL_PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as\n white and 1 as black. Other surfaces will get a palette initialized with\n white in every entry.\n\n If this function is called for a surface that already has a palette, a new\n palette will be created to replace it.\n\n \\param surface the SDL_Surface structure to update.\n \\returns a new SDL_Palette structure on success or NULL on failure (e.g. if\n          the surface didn't have an index format); call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetPaletteColors"]
    pub fn SDL_CreateSurfacePalette(surface: *mut SDL_Surface) -> *mut SDL_Palette;
}
unsafe extern "C" {
    #[doc = " Set the palette used by a surface.\n\n A single palette can be shared with many surfaces.\n\n \\param surface the SDL_Surface structure to update.\n \\param palette the SDL_Palette structure to use.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreatePalette\n \\sa SDL_GetSurfacePalette"]
    pub fn SDL_SetSurfacePalette(surface: *mut SDL_Surface, palette: *mut SDL_Palette) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the palette used by a surface.\n\n \\param surface the SDL_Surface structure to query.\n \\returns a pointer to the palette used by the surface, or NULL if there is\n          no palette used.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetSurfacePalette"]
    pub fn SDL_GetSurfacePalette(surface: *mut SDL_Surface) -> *mut SDL_Palette;
}
unsafe extern "C" {
    #[doc = " Add an alternate version of a surface.\n\n This function adds an alternate version of this surface, usually used for\n content with high DPI representations like cursors or icons. The size,\n format, and content do not need to match the original surface, and these\n alternate versions will not be updated when the original surface changes.\n\n This function adds a reference to the alternate version, so you should call\n SDL_DestroySurface() on the image after this call.\n\n \\param surface the SDL_Surface structure to update.\n \\param image a pointer to an alternate SDL_Surface to associate with this\n              surface.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_RemoveSurfaceAlternateImages\n \\sa SDL_GetSurfaceImages\n \\sa SDL_SurfaceHasAlternateImages"]
    pub fn SDL_AddSurfaceAlternateImage(surface: *mut SDL_Surface, image: *mut SDL_Surface)
        -> bool;
}
unsafe extern "C" {
    #[doc = " Return whether a surface has alternate versions available.\n\n \\param surface the SDL_Surface structure to query.\n \\returns true if alternate versions are available or false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AddSurfaceAlternateImage\n \\sa SDL_RemoveSurfaceAlternateImages\n \\sa SDL_GetSurfaceImages"]
    pub fn SDL_SurfaceHasAlternateImages(surface: *mut SDL_Surface) -> bool;
}
unsafe extern "C" {
    #[doc = " Get an array including all versions of a surface.\n\n This returns all versions of a surface, with the surface being queried as\n the first element in the returned array.\n\n Freeing the array of surfaces does not affect the surfaces in the array.\n They are still referenced by the surface being queried and will be cleaned\n up normally.\n\n \\param surface the SDL_Surface structure to query.\n \\param count a pointer filled in with the number of surface pointers\n              returned, may be NULL.\n \\returns a NULL terminated array of SDL_Surface pointers or NULL on\n          failure; call SDL_GetError() for more information. This should be\n          freed with SDL_free() when it is no longer needed.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AddSurfaceAlternateImage\n \\sa SDL_RemoveSurfaceAlternateImages\n \\sa SDL_SurfaceHasAlternateImages"]
    pub fn SDL_GetSurfaceImages(
        surface: *mut SDL_Surface,
        count: *mut ::core::ffi::c_int,
    ) -> *mut *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Remove all alternate versions of a surface.\n\n This function removes a reference from all the alternative versions,\n destroying them if this is the last reference to them.\n\n \\param surface the SDL_Surface structure to update.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AddSurfaceAlternateImage\n \\sa SDL_GetSurfaceImages\n \\sa SDL_SurfaceHasAlternateImages"]
    pub fn SDL_RemoveSurfaceAlternateImages(surface: *mut SDL_Surface);
}
unsafe extern "C" {
    #[doc = " Set up a surface for directly accessing the pixels.\n\n Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to\n and read from `surface->pixels`, using the pixel format stored in\n `surface->format`. Once you are done accessing the surface, you should use\n SDL_UnlockSurface() to release it.\n\n Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to\n 0, then you can read and write to the surface at any time, and the pixel\n format of the surface will not change.\n\n \\param surface the SDL_Surface structure to be locked.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_MUSTLOCK\n \\sa SDL_UnlockSurface"]
    pub fn SDL_LockSurface(surface: *mut SDL_Surface) -> bool;
}
unsafe extern "C" {
    #[doc = " Release a surface after directly accessing the pixels.\n\n \\param surface the SDL_Surface structure to be unlocked.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LockSurface"]
    pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
}
unsafe extern "C" {
    #[doc = " Load a BMP image from a seekable SDL data stream.\n\n The new surface should be freed with SDL_DestroySurface(). Not doing so\n will result in a memory leak.\n\n \\param src the data stream for the surface.\n \\param closeio if true, calls SDL_CloseIO() on `src` before returning, even\n                in the case of an error.\n \\returns a pointer to a new SDL_Surface structure or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DestroySurface\n \\sa SDL_LoadBMP\n \\sa SDL_SaveBMP_IO"]
    pub fn SDL_LoadBMP_IO(src: *mut SDL_IOStream, closeio: bool) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Load a BMP image from a file.\n\n The new surface should be freed with SDL_DestroySurface(). Not doing so\n will result in a memory leak.\n\n \\param file the BMP file to load.\n \\returns a pointer to a new SDL_Surface structure or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DestroySurface\n \\sa SDL_LoadBMP_IO\n \\sa SDL_SaveBMP"]
    pub fn SDL_LoadBMP(file: *const ::core::ffi::c_char) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Save a surface to a seekable SDL data stream in BMP format.\n\n Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the\n BMP directly. Other RGB formats with 8-bit or higher get converted to a\n 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit\n surface before they are saved. YUV and paletted 1-bit and 4-bit formats are\n not supported.\n\n \\param surface the SDL_Surface structure containing the image to be saved.\n \\param dst a data stream to save to.\n \\param closeio if true, calls SDL_CloseIO() on `dst` before returning, even\n                in the case of an error.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LoadBMP_IO\n \\sa SDL_SaveBMP"]
    pub fn SDL_SaveBMP_IO(surface: *mut SDL_Surface, dst: *mut SDL_IOStream, closeio: bool)
        -> bool;
}
unsafe extern "C" {
    #[doc = " Save a surface to a file.\n\n Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the\n BMP directly. Other RGB formats with 8-bit or higher get converted to a\n 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit\n surface before they are saved. YUV and paletted 1-bit and 4-bit formats are\n not supported.\n\n \\param surface the SDL_Surface structure containing the image to be saved.\n \\param file a file to save to.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_LoadBMP\n \\sa SDL_SaveBMP_IO"]
    pub fn SDL_SaveBMP(surface: *mut SDL_Surface, file: *const ::core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the RLE acceleration hint for a surface.\n\n If RLE is enabled, color key and alpha blending blits are much faster, but\n the surface must be locked before directly accessing the pixels.\n\n \\param surface the SDL_Surface structure to optimize.\n \\param enabled true to enable RLE acceleration, false to disable it.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BlitSurface\n \\sa SDL_LockSurface\n \\sa SDL_UnlockSurface"]
    pub fn SDL_SetSurfaceRLE(surface: *mut SDL_Surface, enabled: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the surface is RLE enabled.\n\n It is safe to pass a NULL `surface` here; it will return false.\n\n \\param surface the SDL_Surface structure to query.\n \\returns true if the surface is RLE enabled, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetSurfaceRLE"]
    pub fn SDL_SurfaceHasRLE(surface: *mut SDL_Surface) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the color key (transparent pixel) in a surface.\n\n The color key defines a pixel value that will be treated as transparent in\n a blit. For example, one can use this to specify that cyan pixels should be\n considered transparent, and therefore not rendered.\n\n It is a pixel of the format used by the surface, as generated by\n SDL_MapRGB().\n\n \\param surface the SDL_Surface structure to update.\n \\param enabled true to enable color key, false to disable color key.\n \\param key the transparent pixel.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetSurfaceColorKey\n \\sa SDL_SetSurfaceRLE\n \\sa SDL_SurfaceHasColorKey"]
    pub fn SDL_SetSurfaceColorKey(surface: *mut SDL_Surface, enabled: bool, key: Uint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the surface has a color key.\n\n It is safe to pass a NULL `surface` here; it will return false.\n\n \\param surface the SDL_Surface structure to query.\n \\returns true if the surface has a color key, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetSurfaceColorKey\n \\sa SDL_GetSurfaceColorKey"]
    pub fn SDL_SurfaceHasColorKey(surface: *mut SDL_Surface) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the color key (transparent pixel) for a surface.\n\n The color key is a pixel of the format used by the surface, as generated by\n SDL_MapRGB().\n\n If the surface doesn't have color key enabled this function returns false.\n\n \\param surface the SDL_Surface structure to query.\n \\param key a pointer filled in with the transparent pixel.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetSurfaceColorKey\n \\sa SDL_SurfaceHasColorKey"]
    pub fn SDL_GetSurfaceColorKey(surface: *mut SDL_Surface, key: *mut Uint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Set an additional color value multiplied into blit operations.\n\n When this surface is blitted, during the blit operation each source color\n channel is modulated by the appropriate color value according to the\n following formula:\n\n `srcC = srcC * (color / 255)`\n\n \\param surface the SDL_Surface structure to update.\n \\param r the red color value multiplied into blit operations.\n \\param g the green color value multiplied into blit operations.\n \\param b the blue color value multiplied into blit operations.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetSurfaceColorMod\n \\sa SDL_SetSurfaceAlphaMod"]
    pub fn SDL_SetSurfaceColorMod(surface: *mut SDL_Surface, r: Uint8, g: Uint8, b: Uint8) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the additional color value multiplied into blit operations.\n\n \\param surface the SDL_Surface structure to query.\n \\param r a pointer filled in with the current red color value.\n \\param g a pointer filled in with the current green color value.\n \\param b a pointer filled in with the current blue color value.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetSurfaceAlphaMod\n \\sa SDL_SetSurfaceColorMod"]
    pub fn SDL_GetSurfaceColorMod(
        surface: *mut SDL_Surface,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set an additional alpha value used in blit operations.\n\n When this surface is blitted, during the blit operation the source alpha\n value is modulated by this alpha value according to the following formula:\n\n `srcA = srcA * (alpha / 255)`\n\n \\param surface the SDL_Surface structure to update.\n \\param alpha the alpha value multiplied into blit operations.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetSurfaceAlphaMod\n \\sa SDL_SetSurfaceColorMod"]
    pub fn SDL_SetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: Uint8) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the additional alpha value used in blit operations.\n\n \\param surface the SDL_Surface structure to query.\n \\param alpha a pointer filled in with the current alpha value.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetSurfaceColorMod\n \\sa SDL_SetSurfaceAlphaMod"]
    pub fn SDL_GetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: *mut Uint8) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the blend mode used for blit operations.\n\n To copy a surface to another surface (or texture) without blending with the\n existing data, the blendmode of the SOURCE surface should be set to\n `SDL_BLENDMODE_NONE`.\n\n \\param surface the SDL_Surface structure to update.\n \\param blendMode the SDL_BlendMode to use for blit blending.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetSurfaceBlendMode"]
    pub fn SDL_SetSurfaceBlendMode(surface: *mut SDL_Surface, blendMode: SDL_BlendMode) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the blend mode used for blit operations.\n\n \\param surface the SDL_Surface structure to query.\n \\param blendMode a pointer filled in with the current SDL_BlendMode.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetSurfaceBlendMode"]
    pub fn SDL_GetSurfaceBlendMode(
        surface: *mut SDL_Surface,
        blendMode: *mut SDL_BlendMode,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the clipping rectangle for a surface.\n\n When `surface` is the destination of a blit, only the area within the clip\n rectangle is drawn into.\n\n Note that blits are automatically clipped to the edges of the source and\n destination surfaces.\n\n \\param surface the SDL_Surface structure to be clipped.\n \\param rect the SDL_Rect structure representing the clipping rectangle, or\n             NULL to disable clipping.\n \\returns true if the rectangle intersects the surface, otherwise false and\n          blits will be completely clipped.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetSurfaceClipRect"]
    pub fn SDL_SetSurfaceClipRect(surface: *mut SDL_Surface, rect: *const SDL_Rect) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the clipping rectangle for a surface.\n\n When `surface` is the destination of a blit, only the area within the clip\n rectangle is drawn into.\n\n \\param surface the SDL_Surface structure representing the surface to be\n                clipped.\n \\param rect an SDL_Rect structure filled in with the clipping rectangle for\n             the surface.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetSurfaceClipRect"]
    pub fn SDL_GetSurfaceClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    #[doc = " Flip a surface vertically or horizontally.\n\n \\param surface the surface to flip.\n \\param flip the direction to flip.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_FlipSurface(surface: *mut SDL_Surface, flip: SDL_FlipMode) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a new surface identical to the existing surface.\n\n If the original surface has alternate images, the new surface will have a\n reference to them as well.\n\n The returned surface should be freed with SDL_DestroySurface().\n\n \\param surface the surface to duplicate.\n \\returns a copy of the surface or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DestroySurface"]
    pub fn SDL_DuplicateSurface(surface: *mut SDL_Surface) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Creates a new surface identical to the existing surface, scaled to the\n desired size.\n\n The returned surface should be freed with SDL_DestroySurface().\n\n \\param surface the surface to duplicate and scale.\n \\param width the width of the new surface.\n \\param height the height of the new surface.\n \\param scaleMode the SDL_ScaleMode to be used.\n \\returns a copy of the surface or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DestroySurface"]
    pub fn SDL_ScaleSurface(
        surface: *mut SDL_Surface,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        scaleMode: SDL_ScaleMode,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Copy an existing surface to a new surface of the specified format.\n\n This function is used to optimize images for faster *repeat* blitting. This\n is accomplished by converting the original and storing the result as a new\n surface. The new, optimized surface can then be used as the source for\n future blits, making them faster.\n\n If you are converting to an indexed surface and want to map colors to a\n palette, you can use SDL_ConvertSurfaceAndColorspace() instead.\n\n If the original surface has alternate images, the new surface will have a\n reference to them as well.\n\n \\param surface the existing SDL_Surface structure to convert.\n \\param format the new pixel format.\n \\returns the new SDL_Surface structure that is created or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ConvertSurfaceAndColorspace\n \\sa SDL_DestroySurface"]
    pub fn SDL_ConvertSurface(
        surface: *mut SDL_Surface,
        format: SDL_PixelFormat,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Copy an existing surface to a new surface of the specified format and\n colorspace.\n\n This function converts an existing surface to a new format and colorspace\n and returns the new surface. This will perform any pixel format and\n colorspace conversion needed.\n\n If the original surface has alternate images, the new surface will have a\n reference to them as well.\n\n \\param surface the existing SDL_Surface structure to convert.\n \\param format the new pixel format.\n \\param palette an optional palette to use for indexed formats, may be NULL.\n \\param colorspace the new colorspace.\n \\param props an SDL_PropertiesID with additional color properties, or 0.\n \\returns the new SDL_Surface structure that is created or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ConvertSurface\n \\sa SDL_DestroySurface"]
    pub fn SDL_ConvertSurfaceAndColorspace(
        surface: *mut SDL_Surface,
        format: SDL_PixelFormat,
        palette: *mut SDL_Palette,
        colorspace: SDL_Colorspace,
        props: SDL_PropertiesID,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Copy a block of pixels of one format to another format.\n\n \\param width the width of the block to copy, in pixels.\n \\param height the height of the block to copy, in pixels.\n \\param src_format an SDL_PixelFormat value of the `src` pixels format.\n \\param src a pointer to the source pixels.\n \\param src_pitch the pitch of the source pixels, in bytes.\n \\param dst_format an SDL_PixelFormat value of the `dst` pixels format.\n \\param dst a pointer to be filled in with new pixel data.\n \\param dst_pitch the pitch of the destination pixels, in bytes.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ConvertPixelsAndColorspace"]
    pub fn SDL_ConvertPixels(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        src_format: SDL_PixelFormat,
        src: *const ::core::ffi::c_void,
        src_pitch: ::core::ffi::c_int,
        dst_format: SDL_PixelFormat,
        dst: *mut ::core::ffi::c_void,
        dst_pitch: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Copy a block of pixels of one format and colorspace to another format and\n colorspace.\n\n \\param width the width of the block to copy, in pixels.\n \\param height the height of the block to copy, in pixels.\n \\param src_format an SDL_PixelFormat value of the `src` pixels format.\n \\param src_colorspace an SDL_Colorspace value describing the colorspace of\n                       the `src` pixels.\n \\param src_properties an SDL_PropertiesID with additional source color\n                       properties, or 0.\n \\param src a pointer to the source pixels.\n \\param src_pitch the pitch of the source pixels, in bytes.\n \\param dst_format an SDL_PixelFormat value of the `dst` pixels format.\n \\param dst_colorspace an SDL_Colorspace value describing the colorspace of\n                       the `dst` pixels.\n \\param dst_properties an SDL_PropertiesID with additional destination color\n                       properties, or 0.\n \\param dst a pointer to be filled in with new pixel data.\n \\param dst_pitch the pitch of the destination pixels, in bytes.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ConvertPixels"]
    pub fn SDL_ConvertPixelsAndColorspace(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        src_format: SDL_PixelFormat,
        src_colorspace: SDL_Colorspace,
        src_properties: SDL_PropertiesID,
        src: *const ::core::ffi::c_void,
        src_pitch: ::core::ffi::c_int,
        dst_format: SDL_PixelFormat,
        dst_colorspace: SDL_Colorspace,
        dst_properties: SDL_PropertiesID,
        dst: *mut ::core::ffi::c_void,
        dst_pitch: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Premultiply the alpha on a block of pixels.\n\n This is safe to use with src == dst, but not for other overlapping areas.\n\n \\param width the width of the block to convert, in pixels.\n \\param height the height of the block to convert, in pixels.\n \\param src_format an SDL_PixelFormat value of the `src` pixels format.\n \\param src a pointer to the source pixels.\n \\param src_pitch the pitch of the source pixels, in bytes.\n \\param dst_format an SDL_PixelFormat value of the `dst` pixels format.\n \\param dst a pointer to be filled in with premultiplied pixel data.\n \\param dst_pitch the pitch of the destination pixels, in bytes.\n \\param linear true to convert from sRGB to linear space for the alpha\n               multiplication, false to do multiplication in sRGB space.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_PremultiplyAlpha(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        src_format: SDL_PixelFormat,
        src: *const ::core::ffi::c_void,
        src_pitch: ::core::ffi::c_int,
        dst_format: SDL_PixelFormat,
        dst: *mut ::core::ffi::c_void,
        dst_pitch: ::core::ffi::c_int,
        linear: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Premultiply the alpha in a surface.\n\n This is safe to use with src == dst, but not for other overlapping areas.\n\n \\param surface the surface to modify.\n \\param linear true to convert from sRGB to linear space for the alpha\n               multiplication, false to do multiplication in sRGB space.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_PremultiplySurfaceAlpha(surface: *mut SDL_Surface, linear: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Clear a surface with a specific color, with floating point precision.\n\n This function handles all surface formats, and ignores any clip rectangle.\n\n If the surface is YUV, the color is assumed to be in the sRGB colorspace,\n otherwise the color is assumed to be in the colorspace of the suface.\n\n \\param surface the SDL_Surface to clear.\n \\param r the red component of the pixel, normally in the range 0-1.\n \\param g the green component of the pixel, normally in the range 0-1.\n \\param b the blue component of the pixel, normally in the range 0-1.\n \\param a the alpha component of the pixel, normally in the range 0-1.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ClearSurface(surface: *mut SDL_Surface, r: f32, g: f32, b: f32, a: f32) -> bool;
}
unsafe extern "C" {
    #[doc = " Perform a fast fill of a rectangle with a specific color.\n\n `color` should be a pixel of the format used by the surface, and can be\n generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an\n alpha component then the destination is simply filled with that alpha\n information, no blending takes place.\n\n If there is a clip rectangle set on the destination (set via\n SDL_SetSurfaceClipRect()), then this function will fill based on the\n intersection of the clip rectangle and `rect`.\n\n \\param dst the SDL_Surface structure that is the drawing target.\n \\param rect the SDL_Rect structure representing the rectangle to fill, or\n             NULL to fill the entire surface.\n \\param color the color to fill with.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_FillSurfaceRects"]
    pub fn SDL_FillSurfaceRect(dst: *mut SDL_Surface, rect: *const SDL_Rect, color: Uint32)
        -> bool;
}
unsafe extern "C" {
    #[doc = " Perform a fast fill of a set of rectangles with a specific color.\n\n `color` should be a pixel of the format used by the surface, and can be\n generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an\n alpha component then the destination is simply filled with that alpha\n information, no blending takes place.\n\n If there is a clip rectangle set on the destination (set via\n SDL_SetSurfaceClipRect()), then this function will fill based on the\n intersection of the clip rectangle and `rect`.\n\n \\param dst the SDL_Surface structure that is the drawing target.\n \\param rects an array of SDL_Rects representing the rectangles to fill.\n \\param count the number of rectangles in the array.\n \\param color the color to fill with.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_FillSurfaceRect"]
    pub fn SDL_FillSurfaceRects(
        dst: *mut SDL_Surface,
        rects: *const SDL_Rect,
        count: ::core::ffi::c_int,
        color: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Performs a fast blit from the source surface to the destination surface\n with clipping.\n\n If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or\n `dst`) is copied while ensuring clipping to `dst->clip_rect`.\n\n The final blit rectangles are saved in `srcrect` and `dstrect` after all\n clipping is performed.\n\n The blit function should not be called on a locked surface.\n\n The blit semantics for surfaces with and without blending and colorkey are\n defined as follows:\n\n ```\n    RGBA->RGB:\n      Source surface blend mode set to SDL_BLENDMODE_BLEND:\n       alpha-blend (using the source alpha-channel and per-surface alpha)\n       SDL_SRCCOLORKEY ignored.\n     Source surface blend mode set to SDL_BLENDMODE_NONE:\n       copy RGB.\n       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the\n       RGB values of the source color key, ignoring alpha in the\n       comparison.\n\n   RGB->RGBA:\n     Source surface blend mode set to SDL_BLENDMODE_BLEND:\n       alpha-blend (using the source per-surface alpha)\n     Source surface blend mode set to SDL_BLENDMODE_NONE:\n       copy RGB, set destination alpha to source per-surface alpha value.\n     both:\n       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the\n       source color key.\n\n   RGBA->RGBA:\n     Source surface blend mode set to SDL_BLENDMODE_BLEND:\n       alpha-blend (using the source alpha-channel and per-surface alpha)\n       SDL_SRCCOLORKEY ignored.\n     Source surface blend mode set to SDL_BLENDMODE_NONE:\n       copy all of RGBA to the destination.\n       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the\n       RGB values of the source color key, ignoring alpha in the\n       comparison.\n\n   RGB->RGB:\n     Source surface blend mode set to SDL_BLENDMODE_BLEND:\n       alpha-blend (using the source per-surface alpha)\n     Source surface blend mode set to SDL_BLENDMODE_NONE:\n       copy RGB.\n     both:\n       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the\n       source color key.\n ```\n\n \\param src the SDL_Surface structure to be copied from.\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied, or NULL to copy the entire surface.\n \\param dst the SDL_Surface structure that is the blit target.\n \\param dstrect the SDL_Rect structure representing the x and y position in\n                the destination surface, or NULL for (0,0). The width and\n                height are ignored, and are copied from `srcrect`. If you\n                want a specific width and height, you should use\n                SDL_BlitSurfaceScaled().\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety The same destination surface should not be used from two\n               threads at once. It is safe to use the same source surface\n               from multiple threads.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BlitSurfaceScaled"]
    pub fn SDL_BlitSurface(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Perform low-level surface blitting only.\n\n This is a semi-private blit function and it performs low-level surface\n blitting, assuming the input rectangles have already been clipped.\n\n \\param src the SDL_Surface structure to be copied from.\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied, may not be NULL.\n \\param dst the SDL_Surface structure that is the blit target.\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface, may not be NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety The same destination surface should not be used from two\n               threads at once. It is safe to use the same source surface\n               from multiple threads.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BlitSurface"]
    pub fn SDL_BlitSurfaceUnchecked(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Perform a scaled blit to a destination surface, which may be of a different\n format.\n\n \\param src the SDL_Surface structure to be copied from.\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied, or NULL to copy the entire surface.\n \\param dst the SDL_Surface structure that is the blit target.\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface, or NULL to fill the entire\n                destination surface.\n \\param scaleMode the SDL_ScaleMode to be used.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety The same destination surface should not be used from two\n               threads at once. It is safe to use the same source surface\n               from multiple threads.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BlitSurface"]
    pub fn SDL_BlitSurfaceScaled(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
        scaleMode: SDL_ScaleMode,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Perform low-level surface scaled blitting only.\n\n This is a semi-private function and it performs low-level surface blitting,\n assuming the input rectangles have already been clipped.\n\n \\param src the SDL_Surface structure to be copied from.\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied, may not be NULL.\n \\param dst the SDL_Surface structure that is the blit target.\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface, may not be NULL.\n \\param scaleMode the SDL_ScaleMode to be used.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety The same destination surface should not be used from two\n               threads at once. It is safe to use the same source surface\n               from multiple threads.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BlitSurfaceScaled"]
    pub fn SDL_BlitSurfaceUncheckedScaled(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
        scaleMode: SDL_ScaleMode,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Perform a stretched pixel copy from one surface to another.\n\n \\param src the SDL_Surface structure to be copied from.\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied, may not be NULL.\n \\param dst the SDL_Surface structure that is the blit target.\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface, may not be NULL.\n \\param scaleMode the SDL_ScaleMode to be used.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety The same destination surface should not be used from two\n               threads at once. It is safe to use the same source surface\n               from multiple threads.\n\n \\since This function is available since SDL 3.4.0.\n\n \\sa SDL_BlitSurfaceScaled"]
    pub fn SDL_StretchSurface(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
        scaleMode: SDL_ScaleMode,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Perform a tiled blit to a destination surface, which may be of a different\n format.\n\n The pixels in `srcrect` will be repeated as many times as needed to\n completely fill `dstrect`.\n\n \\param src the SDL_Surface structure to be copied from.\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied, or NULL to copy the entire surface.\n \\param dst the SDL_Surface structure that is the blit target.\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface, or NULL to fill the entire surface.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety The same destination surface should not be used from two\n               threads at once. It is safe to use the same source surface\n               from multiple threads.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BlitSurface"]
    pub fn SDL_BlitSurfaceTiled(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Perform a scaled and tiled blit to a destination surface, which may be of a\n different format.\n\n The pixels in `srcrect` will be scaled and repeated as many times as needed\n to completely fill `dstrect`.\n\n \\param src the SDL_Surface structure to be copied from.\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied, or NULL to copy the entire surface.\n \\param scale the scale used to transform srcrect into the destination\n              rectangle, e.g. a 32x32 texture with a scale of 2 would fill\n              64x64 tiles.\n \\param scaleMode scale algorithm to be used.\n \\param dst the SDL_Surface structure that is the blit target.\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface, or NULL to fill the entire surface.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety The same destination surface should not be used from two\n               threads at once. It is safe to use the same source surface\n               from multiple threads.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BlitSurface"]
    pub fn SDL_BlitSurfaceTiledWithScale(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        scale: f32,
        scaleMode: SDL_ScaleMode,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Perform a scaled blit using the 9-grid algorithm to a destination surface,\n which may be of a different format.\n\n The pixels in the source surface are split into a 3x3 grid, using the\n different corner sizes for each corner, and the sides and center making up\n the remaining pixels. The corners are then scaled using `scale` and fit\n into the corners of the destination rectangle. The sides and center are\n then stretched into place to cover the remaining destination rectangle.\n\n \\param src the SDL_Surface structure to be copied from.\n \\param srcrect the SDL_Rect structure representing the rectangle to be used\n                for the 9-grid, or NULL to use the entire surface.\n \\param left_width the width, in pixels, of the left corners in `srcrect`.\n \\param right_width the width, in pixels, of the right corners in `srcrect`.\n \\param top_height the height, in pixels, of the top corners in `srcrect`.\n \\param bottom_height the height, in pixels, of the bottom corners in\n                      `srcrect`.\n \\param scale the scale used to transform the corner of `srcrect` into the\n              corner of `dstrect`, or 0.0f for an unscaled blit.\n \\param scaleMode scale algorithm to be used.\n \\param dst the SDL_Surface structure that is the blit target.\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface, or NULL to fill the entire surface.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety The same destination surface should not be used from two\n               threads at once. It is safe to use the same source surface\n               from multiple threads.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_BlitSurface"]
    pub fn SDL_BlitSurface9Grid(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        left_width: ::core::ffi::c_int,
        right_width: ::core::ffi::c_int,
        top_height: ::core::ffi::c_int,
        bottom_height: ::core::ffi::c_int,
        scale: f32,
        scaleMode: SDL_ScaleMode,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Map an RGB triple to an opaque pixel value for a surface.\n\n This function maps the RGB color value to the specified pixel format and\n returns the pixel value best approximating the given RGB color value for\n the given pixel format.\n\n If the surface has a palette, the index of the closest matching color in\n the palette will be returned.\n\n If the surface pixel format has an alpha component it will be returned as\n all 1 bits (fully opaque).\n\n If the pixel format bpp (color depth) is less than 32-bpp then the unused\n upper bits of the return value can safely be ignored (e.g., with a 16-bpp\n format the return value can be assigned to a Uint16, and similarly a Uint8\n for an 8-bpp format).\n\n \\param surface the surface to use for the pixel format and palette.\n \\param r the red component of the pixel in the range 0-255.\n \\param g the green component of the pixel in the range 0-255.\n \\param b the blue component of the pixel in the range 0-255.\n \\returns a pixel value.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_MapSurfaceRGBA"]
    pub fn SDL_MapSurfaceRGB(surface: *mut SDL_Surface, r: Uint8, g: Uint8, b: Uint8) -> Uint32;
}
unsafe extern "C" {
    #[doc = " Map an RGBA quadruple to a pixel value for a surface.\n\n This function maps the RGBA color value to the specified pixel format and\n returns the pixel value best approximating the given RGBA color value for\n the given pixel format.\n\n If the surface pixel format has no alpha component the alpha value will be\n ignored (as it will be in formats with a palette).\n\n If the surface has a palette, the index of the closest matching color in\n the palette will be returned.\n\n If the pixel format bpp (color depth) is less than 32-bpp then the unused\n upper bits of the return value can safely be ignored (e.g., with a 16-bpp\n format the return value can be assigned to a Uint16, and similarly a Uint8\n for an 8-bpp format).\n\n \\param surface the surface to use for the pixel format and palette.\n \\param r the red component of the pixel in the range 0-255.\n \\param g the green component of the pixel in the range 0-255.\n \\param b the blue component of the pixel in the range 0-255.\n \\param a the alpha component of the pixel in the range 0-255.\n \\returns a pixel value.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_MapSurfaceRGB"]
    pub fn SDL_MapSurfaceRGBA(
        surface: *mut SDL_Surface,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> Uint32;
}
unsafe extern "C" {
    #[doc = " Retrieves a single pixel from a surface.\n\n This function prioritizes correctness over speed: it is suitable for unit\n tests, but is not intended for use in a game engine.\n\n Like SDL_GetRGBA, this uses the entire 0..255 range when converting color\n components from pixel formats with less than 8 bits per RGB component.\n\n \\param surface the surface to read.\n \\param x the horizontal coordinate, 0 <= x < width.\n \\param y the vertical coordinate, 0 <= y < height.\n \\param r a pointer filled in with the red channel, 0-255, or NULL to ignore\n          this channel.\n \\param g a pointer filled in with the green channel, 0-255, or NULL to\n          ignore this channel.\n \\param b a pointer filled in with the blue channel, 0-255, or NULL to\n          ignore this channel.\n \\param a a pointer filled in with the alpha channel, 0-255, or NULL to\n          ignore this channel.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadSurfacePixel(
        surface: *mut SDL_Surface,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Retrieves a single pixel from a surface.\n\n This function prioritizes correctness over speed: it is suitable for unit\n tests, but is not intended for use in a game engine.\n\n \\param surface the surface to read.\n \\param x the horizontal coordinate, 0 <= x < width.\n \\param y the vertical coordinate, 0 <= y < height.\n \\param r a pointer filled in with the red channel, normally in the range\n          0-1, or NULL to ignore this channel.\n \\param g a pointer filled in with the green channel, normally in the range\n          0-1, or NULL to ignore this channel.\n \\param b a pointer filled in with the blue channel, normally in the range\n          0-1, or NULL to ignore this channel.\n \\param a a pointer filled in with the alpha channel, normally in the range\n          0-1, or NULL to ignore this channel.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReadSurfacePixelFloat(
        surface: *mut SDL_Surface,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        r: *mut f32,
        g: *mut f32,
        b: *mut f32,
        a: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Writes a single pixel to a surface.\n\n This function prioritizes correctness over speed: it is suitable for unit\n tests, but is not intended for use in a game engine.\n\n Like SDL_MapRGBA, this uses the entire 0..255 range when converting color\n components from pixel formats with less than 8 bits per RGB component.\n\n \\param surface the surface to write.\n \\param x the horizontal coordinate, 0 <= x < width.\n \\param y the vertical coordinate, 0 <= y < height.\n \\param r the red channel value, 0-255.\n \\param g the green channel value, 0-255.\n \\param b the blue channel value, 0-255.\n \\param a the alpha channel value, 0-255.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteSurfacePixel(
        surface: *mut SDL_Surface,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Writes a single pixel to a surface.\n\n This function prioritizes correctness over speed: it is suitable for unit\n tests, but is not intended for use in a game engine.\n\n \\param surface the surface to write.\n \\param x the horizontal coordinate, 0 <= x < width.\n \\param y the vertical coordinate, 0 <= y < height.\n \\param r the red channel value, normally in the range 0-1.\n \\param g the green channel value, normally in the range 0-1.\n \\param b the blue channel value, normally in the range 0-1.\n \\param a the alpha channel value, normally in the range 0-1.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_WriteSurfacePixelFloat(
        surface: *mut SDL_Surface,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
    ) -> bool;
}
#[doc = " This is a unique ID for a camera device for the time it is connected to the\n system, and is never reused for the lifetime of the application.\n\n If the device is disconnected and reconnected, it will get a new ID.\n\n The value 0 is an invalid ID.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_GetCameras"]
pub type SDL_CameraID = Uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Camera {
    _unused: [u8; 0],
}
#[doc = " The details of an output format for a camera device.\n\n Cameras often support multiple formats; each one will be encapsulated in\n this struct.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_GetCameraSupportedFormats\n \\sa SDL_GetCameraFormat"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_CameraSpec {
    #[doc = "< Frame format"]
    pub format: SDL_PixelFormat,
    #[doc = "< Frame colorspace"]
    pub colorspace: SDL_Colorspace,
    #[doc = "< Frame width"]
    pub width: ::core::ffi::c_int,
    #[doc = "< Frame height"]
    pub height: ::core::ffi::c_int,
    #[doc = "< Frame rate numerator ((num / denom) == FPS, (denom / num) == duration in seconds)"]
    pub framerate_numerator: ::core::ffi::c_int,
    #[doc = "< Frame rate demoninator ((num / denom) == FPS, (denom / num) == duration in seconds)"]
    pub framerate_denominator: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_CameraSpec"][::core::mem::size_of::<SDL_CameraSpec>() - 24usize];
    ["Alignment of SDL_CameraSpec"][::core::mem::align_of::<SDL_CameraSpec>() - 4usize];
    ["Offset of field: SDL_CameraSpec::format"]
        [::core::mem::offset_of!(SDL_CameraSpec, format) - 0usize];
    ["Offset of field: SDL_CameraSpec::colorspace"]
        [::core::mem::offset_of!(SDL_CameraSpec, colorspace) - 4usize];
    ["Offset of field: SDL_CameraSpec::width"]
        [::core::mem::offset_of!(SDL_CameraSpec, width) - 8usize];
    ["Offset of field: SDL_CameraSpec::height"]
        [::core::mem::offset_of!(SDL_CameraSpec, height) - 12usize];
    ["Offset of field: SDL_CameraSpec::framerate_numerator"]
        [::core::mem::offset_of!(SDL_CameraSpec, framerate_numerator) - 16usize];
    ["Offset of field: SDL_CameraSpec::framerate_denominator"]
        [::core::mem::offset_of!(SDL_CameraSpec, framerate_denominator) - 20usize];
};
pub const SDL_CameraPosition_SDL_CAMERA_POSITION_UNKNOWN: SDL_CameraPosition = 0;
pub const SDL_CameraPosition_SDL_CAMERA_POSITION_FRONT_FACING: SDL_CameraPosition = 1;
pub const SDL_CameraPosition_SDL_CAMERA_POSITION_BACK_FACING: SDL_CameraPosition = 2;
#[doc = " The position of camera in relation to system device.\n\n \\since This enum is available since SDL 3.2.0.\n\n \\sa SDL_GetCameraPosition"]
pub type SDL_CameraPosition = ::core::ffi::c_uint;
unsafe extern "C" {
    #[doc = " Use this function to get the number of built-in camera drivers.\n\n This function returns a hardcoded number. This never returns a negative\n value; if there are no drivers compiled into this build of SDL, this\n function returns zero. The presence of a driver in this list does not mean\n it will function, it just means SDL is capable of interacting with that\n interface. For example, a build of SDL might have v4l2 support, but if\n there's no kernel support available, SDL's v4l2 driver would fail if used.\n\n By default, SDL tries all drivers, in its preferred order, until one is\n found to be usable.\n\n \\returns the number of built-in camera drivers.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetCameraDriver"]
    pub fn SDL_GetNumCameraDrivers() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Use this function to get the name of a built in camera driver.\n\n The list of camera drivers is given in the order that they are normally\n initialized by default; the drivers that seem more reasonable to choose\n first (as far as the SDL developers believe) are earlier in the list.\n\n The names of drivers are all simple, low-ASCII identifiers, like \"v4l2\",\n \"coremedia\" or \"android\". These never have Unicode characters, and are not\n meant to be proper names.\n\n \\param index the index of the camera driver; the value ranges from 0 to\n              SDL_GetNumCameraDrivers() - 1.\n \\returns the name of the camera driver at the requested index, or NULL if\n          an invalid index was specified.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetNumCameraDrivers"]
    pub fn SDL_GetCameraDriver(index: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the current camera driver.\n\n The names of drivers are all simple, low-ASCII identifiers, like \"v4l2\",\n \"coremedia\" or \"android\". These never have Unicode characters, and are not\n meant to be proper names.\n\n \\returns the name of the current camera driver or NULL if no driver has\n          been initialized.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetCurrentCameraDriver() -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get a list of currently connected camera devices.\n\n \\param count a pointer filled in with the number of cameras returned, may\n              be NULL.\n \\returns a 0 terminated array of camera instance IDs or NULL on failure;\n          call SDL_GetError() for more information. This should be freed\n          with SDL_free() when it is no longer needed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_OpenCamera"]
    pub fn SDL_GetCameras(count: *mut ::core::ffi::c_int) -> *mut SDL_CameraID;
}
unsafe extern "C" {
    #[doc = " Get the list of native formats/sizes a camera supports.\n\n This returns a list of all formats and frame sizes that a specific camera\n can offer. This is useful if your app can accept a variety of image formats\n and sizes and so want to find the optimal spec that doesn't require\n conversion.\n\n This function isn't strictly required; if you call SDL_OpenCamera with a\n NULL spec, SDL will choose a native format for you, and if you instead\n specify a desired format, it will transparently convert to the requested\n format on your behalf.\n\n If `count` is not NULL, it will be filled with the number of elements in\n the returned array.\n\n Note that it's legal for a camera to supply an empty list. This is what\n will happen on Emscripten builds, since that platform won't tell _anything_\n about available cameras until you've opened one, and won't even tell if\n there _is_ a camera until the user has given you permission to check\n through a scary warning popup.\n\n \\param instance_id the camera device instance ID.\n \\param count a pointer filled in with the number of elements in the list,\n              may be NULL.\n \\returns a NULL terminated array of pointers to SDL_CameraSpec or NULL on\n          failure; call SDL_GetError() for more information. This is a\n          single allocation that should be freed with SDL_free() when it is\n          no longer needed.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetCameras\n \\sa SDL_OpenCamera"]
    pub fn SDL_GetCameraSupportedFormats(
        instance_id: SDL_CameraID,
        count: *mut ::core::ffi::c_int,
    ) -> *mut *mut SDL_CameraSpec;
}
unsafe extern "C" {
    #[doc = " Get the human-readable device name for a camera.\n\n \\param instance_id the camera device instance ID.\n \\returns a human-readable device name or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetCameras"]
    pub fn SDL_GetCameraName(instance_id: SDL_CameraID) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the position of the camera in relation to the system.\n\n Most platforms will report UNKNOWN, but mobile devices, like phones, can\n often make a distinction between cameras on the front of the device (that\n points towards the user, for taking \"selfies\") and cameras on the back (for\n filming in the direction the user is facing).\n\n \\param instance_id the camera device instance ID.\n \\returns the position of the camera on the system hardware.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetCameras"]
    pub fn SDL_GetCameraPosition(instance_id: SDL_CameraID) -> SDL_CameraPosition;
}
unsafe extern "C" {
    #[doc = " Open a video recording device (a \"camera\").\n\n You can open the device with any reasonable spec, and if the hardware can't\n directly support it, it will convert data seamlessly to the requested\n format. This might incur overhead, including scaling of image data.\n\n If you would rather accept whatever format the device offers, you can pass\n a NULL spec here and it will choose one for you (and you can use\n SDL_Surface's conversion/scaling functions directly if necessary).\n\n You can call SDL_GetCameraFormat() to get the actual data format if passing\n a NULL spec here. You can see the exact specs a device can support without\n conversion with SDL_GetCameraSupportedFormats().\n\n SDL will not attempt to emulate framerate; it will try to set the hardware\n to the rate closest to the requested speed, but it won't attempt to limit\n or duplicate frames artificially; call SDL_GetCameraFormat() to see the\n actual framerate of the opened the device, and check your timestamps if\n this is crucial to your app!\n\n Note that the camera is not usable until the user approves its use! On some\n platforms, the operating system will prompt the user to permit access to\n the camera, and they can choose Yes or No at that point. Until they do, the\n camera will not be usable. The app should either wait for an\n SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,\n or poll SDL_GetCameraPermissionState() occasionally until it returns\n non-zero. On platforms that don't require explicit user approval (and\n perhaps in places where the user previously permitted access), the approval\n event might come immediately, but it might come seconds, minutes, or hours\n later!\n\n \\param instance_id the camera device instance ID.\n \\param spec the desired format for data the device will provide. Can be\n             NULL.\n \\returns an SDL_Camera object or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetCameras\n \\sa SDL_GetCameraFormat"]
    pub fn SDL_OpenCamera(
        instance_id: SDL_CameraID,
        spec: *const SDL_CameraSpec,
    ) -> *mut SDL_Camera;
}
unsafe extern "C" {
    #[doc = " Query if camera access has been approved by the user.\n\n Cameras will not function between when the device is opened by the app and\n when the user permits access to the hardware. On some platforms, this\n presents as a popup dialog where the user has to explicitly approve access;\n on others the approval might be implicit and not alert the user at all.\n\n This function can be used to check the status of that approval. It will\n return 0 if still waiting for user response, 1 if the camera is approved\n for use, and -1 if the user denied access.\n\n Instead of polling with this function, you can wait for a\n SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event\n in the standard SDL event loop, which is guaranteed to be sent once when\n permission to use the camera is decided.\n\n If a camera is declined, there's nothing to be done but call\n SDL_CloseCamera() to dispose of it.\n\n \\param camera the opened camera device to query.\n \\returns -1 if user denied access to the camera, 1 if user approved access,\n          0 if no decision has been made yet.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_OpenCamera\n \\sa SDL_CloseCamera"]
    pub fn SDL_GetCameraPermissionState(camera: *mut SDL_Camera) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the instance ID of an opened camera.\n\n \\param camera an SDL_Camera to query.\n \\returns the instance ID of the specified camera on success or 0 on\n          failure; call SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_OpenCamera"]
    pub fn SDL_GetCameraID(camera: *mut SDL_Camera) -> SDL_CameraID;
}
unsafe extern "C" {
    #[doc = " Get the properties associated with an opened camera.\n\n \\param camera the SDL_Camera obtained from SDL_OpenCamera().\n \\returns a valid property ID on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetCameraProperties(camera: *mut SDL_Camera) -> SDL_PropertiesID;
}
unsafe extern "C" {
    #[doc = " Get the spec that a camera is using when generating images.\n\n Note that this might not be the native format of the hardware, as SDL might\n be converting to this format behind the scenes.\n\n If the system is waiting for the user to approve access to the camera, as\n some platforms require, this will return false, but this isn't necessarily\n a fatal error; you should either wait for an\n SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,\n or poll SDL_GetCameraPermissionState() occasionally until it returns\n non-zero.\n\n \\param camera opened camera device.\n \\param spec the SDL_CameraSpec to be initialized by this function.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_OpenCamera"]
    pub fn SDL_GetCameraFormat(camera: *mut SDL_Camera, spec: *mut SDL_CameraSpec) -> bool;
}
unsafe extern "C" {
    #[doc = " Acquire a frame.\n\n The frame is a memory pointer to the image data, whose size and format are\n given by the spec requested when opening the device.\n\n This is a non blocking API. If there is a frame available, a non-NULL\n surface is returned, and timestampNS will be filled with a non-zero value.\n\n Note that an error case can also return NULL, but a NULL by itself is\n normal and just signifies that a new frame is not yet available. Note that\n even if a camera device fails outright (a USB camera is unplugged while in\n use, etc), SDL will send an event separately to notify the app, but\n continue to provide blank frames at ongoing intervals until\n SDL_CloseCamera() is called, so real failure here is almost always an out\n of memory condition.\n\n After use, the frame should be released with SDL_ReleaseCameraFrame(). If\n you don't do this, the system may stop providing more video!\n\n Do not call SDL_DestroySurface() on the returned surface! It must be given\n back to the camera subsystem with SDL_ReleaseCameraFrame!\n\n If the system is waiting for the user to approve access to the camera, as\n some platforms require, this will return NULL (no frames available); you\n should either wait for an SDL_EVENT_CAMERA_DEVICE_APPROVED (or\n SDL_EVENT_CAMERA_DEVICE_DENIED) event, or poll\n SDL_GetCameraPermissionState() occasionally until it returns non-zero.\n\n \\param camera opened camera device.\n \\param timestampNS a pointer filled in with the frame's timestamp, or 0 on\n                    error. Can be NULL.\n \\returns a new frame of video on success, NULL if none is currently\n          available.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ReleaseCameraFrame"]
    pub fn SDL_AcquireCameraFrame(
        camera: *mut SDL_Camera,
        timestampNS: *mut Uint64,
    ) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Release a frame of video acquired from a camera.\n\n Let the back-end re-use the internal buffer for camera.\n\n This function _must_ be called only on surface objects returned by\n SDL_AcquireCameraFrame(). This function should be called as quickly as\n possible after acquisition, as SDL keeps a small FIFO queue of surfaces for\n video frames; if surfaces aren't released in a timely manner, SDL may drop\n upcoming video frames from the camera.\n\n If the app needs to keep the surface for a significant time, they should\n make a copy of it and release the original.\n\n The app should not use the surface again after calling this function;\n assume the surface is freed and the pointer is invalid.\n\n \\param camera opened camera device.\n \\param frame the video frame surface to release.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AcquireCameraFrame"]
    pub fn SDL_ReleaseCameraFrame(camera: *mut SDL_Camera, frame: *mut SDL_Surface);
}
unsafe extern "C" {
    #[doc = " Use this function to shut down camera processing and close the camera\n device.\n\n \\param camera opened camera device.\n\n \\threadsafety It is safe to call this function from any thread, but no\n               thread may reference `device` once this function is called.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_OpenCamera"]
    pub fn SDL_CloseCamera(camera: *mut SDL_Camera);
}
#[doc = " An SDL_GUID is a 128-bit identifier for an input device that identifies\n that device across runs of SDL programs on the same platform.\n\n If the device is detached and then re-attached to a different port, or if\n the base system is rebooted, the device should still report the same GUID.\n\n GUIDs are as precise as possible but are not guaranteed to distinguish\n physically distinct but equivalent devices. For example, two game\n controllers from the same vendor with the same product ID and revision may\n have the same GUID.\n\n GUIDs may be platform-dependent (i.e., the same device may report different\n GUIDs on different operating systems).\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_GUID {
    pub data: [Uint8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_GUID"][::core::mem::size_of::<SDL_GUID>() - 16usize];
    ["Alignment of SDL_GUID"][::core::mem::align_of::<SDL_GUID>() - 1usize];
    ["Offset of field: SDL_GUID::data"][::core::mem::offset_of!(SDL_GUID, data) - 0usize];
};
unsafe extern "C" {
    #[doc = " Get an ASCII string representation for a given SDL_GUID.\n\n \\param guid the SDL_GUID you wish to convert to string.\n \\param pszGUID buffer in which to write the ASCII string.\n \\param cbGUID the size of pszGUID, should be at least 33 bytes.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_StringToGUID"]
    pub fn SDL_GUIDToString(
        guid: SDL_GUID,
        pszGUID: *mut ::core::ffi::c_char,
        cbGUID: ::core::ffi::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Convert a GUID string into a SDL_GUID structure.\n\n Performs no error checking. If this function is given a string containing\n an invalid GUID, the function will silently succeed, but the GUID generated\n will not be useful.\n\n \\param pchGUID string containing an ASCII representation of a GUID.\n \\returns a SDL_GUID structure.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GUIDToString"]
    pub fn SDL_StringToGUID(pchGUID: *const ::core::ffi::c_char) -> SDL_GUID;
}
#[doc = "< error determining power status"]
pub const SDL_PowerState_SDL_POWERSTATE_ERROR: SDL_PowerState = -1;
#[doc = "< cannot determine power status"]
pub const SDL_PowerState_SDL_POWERSTATE_UNKNOWN: SDL_PowerState = 0;
#[doc = "< Not plugged in, running on the battery"]
pub const SDL_PowerState_SDL_POWERSTATE_ON_BATTERY: SDL_PowerState = 1;
#[doc = "< Plugged in, no battery available"]
pub const SDL_PowerState_SDL_POWERSTATE_NO_BATTERY: SDL_PowerState = 2;
#[doc = "< Plugged in, charging battery"]
pub const SDL_PowerState_SDL_POWERSTATE_CHARGING: SDL_PowerState = 3;
#[doc = "< Plugged in, battery charged"]
pub const SDL_PowerState_SDL_POWERSTATE_CHARGED: SDL_PowerState = 4;
#[doc = " The basic state for the system's power supply.\n\n These are results returned by SDL_GetPowerInfo().\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_PowerState = ::core::ffi::c_int;
unsafe extern "C" {
    #[doc = " Get the current power supply details.\n\n You should never take a battery status as absolute truth. Batteries\n (especially failing batteries) are delicate hardware, and the values\n reported here are best estimates based on what that hardware reports. It's\n not uncommon for older batteries to lose stored power much faster than it\n reports, or completely drain when reporting it has 20 percent left, etc.\n\n Battery status can change at any time; if you are concerned with power\n state, you should call this function frequently, and perhaps ignore changes\n until they seem to be stable for a few seconds.\n\n It's possible a platform can only report battery percentage or time left\n but not both.\n\n \\param seconds a pointer filled in with the seconds of battery life left,\n                or NULL to ignore. This will be filled in with -1 if we\n                can't determine a value or there is no battery.\n \\param percent a pointer filled in with the percentage of battery life\n                left, between 0 and 100, or NULL to ignore. This will be\n                filled in with -1 we can't determine a value or there is no\n                battery.\n \\returns the current battery state or `SDL_POWERSTATE_ERROR` on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetPowerInfo(
        seconds: *mut ::core::ffi::c_int,
        percent: *mut ::core::ffi::c_int,
    ) -> SDL_PowerState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Sensor {
    _unused: [u8; 0],
}
#[doc = " This is a unique ID for a sensor for the time it is connected to the\n system, and is never reused for the lifetime of the application.\n\n The value 0 is an invalid ID.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_SensorID = Uint32;
#[doc = "< Returned for an invalid sensor"]
pub const SDL_SensorType_SDL_SENSOR_INVALID: SDL_SensorType = -1;
#[doc = "< Unknown sensor type"]
pub const SDL_SensorType_SDL_SENSOR_UNKNOWN: SDL_SensorType = 0;
#[doc = "< Accelerometer"]
pub const SDL_SensorType_SDL_SENSOR_ACCEL: SDL_SensorType = 1;
#[doc = "< Gyroscope"]
pub const SDL_SensorType_SDL_SENSOR_GYRO: SDL_SensorType = 2;
#[doc = "< Accelerometer for left Joy-Con controller and Wii nunchuk"]
pub const SDL_SensorType_SDL_SENSOR_ACCEL_L: SDL_SensorType = 3;
#[doc = "< Gyroscope for left Joy-Con controller"]
pub const SDL_SensorType_SDL_SENSOR_GYRO_L: SDL_SensorType = 4;
#[doc = "< Accelerometer for right Joy-Con controller"]
pub const SDL_SensorType_SDL_SENSOR_ACCEL_R: SDL_SensorType = 5;
#[doc = "< Gyroscope for right Joy-Con controller"]
pub const SDL_SensorType_SDL_SENSOR_GYRO_R: SDL_SensorType = 6;
#[doc = " The different sensors defined by SDL.\n\n Additional sensors may be available, using platform dependent semantics.\n\n Here are the additional Android sensors:\n\n https://developer.android.com/reference/android/hardware/SensorEvent.html#values\n\n Accelerometer sensor notes:\n\n The accelerometer returns the current acceleration in SI meters per second\n squared. This measurement includes the force of gravity, so a device at\n rest will have an value of SDL_STANDARD_GRAVITY away from the center of the\n earth, which is a positive Y value.\n\n - `values[0]`: Acceleration on the x axis\n - `values[1]`: Acceleration on the y axis\n - `values[2]`: Acceleration on the z axis\n\n For phones and tablets held in natural orientation and game controllers\n held in front of you, the axes are defined as follows:\n\n - -X ... +X : left ... right\n - -Y ... +Y : bottom ... top\n - -Z ... +Z : farther ... closer\n\n The accelerometer axis data is not changed when the device is rotated.\n\n Gyroscope sensor notes:\n\n The gyroscope returns the current rate of rotation in radians per second.\n The rotation is positive in the counter-clockwise direction. That is, an\n observer looking from a positive location on one of the axes would see\n positive rotation on that axis when it appeared to be rotating\n counter-clockwise.\n\n - `values[0]`: Angular speed around the x axis (pitch)\n - `values[1]`: Angular speed around the y axis (yaw)\n - `values[2]`: Angular speed around the z axis (roll)\n\n For phones and tablets held in natural orientation and game controllers\n held in front of you, the axes are defined as follows:\n\n - -X ... +X : left ... right\n - -Y ... +Y : bottom ... top\n - -Z ... +Z : farther ... closer\n\n The gyroscope axis data is not changed when the device is rotated.\n\n \\since This enum is available since SDL 3.2.0.\n\n \\sa SDL_GetCurrentDisplayOrientation"]
pub type SDL_SensorType = ::core::ffi::c_int;
unsafe extern "C" {
    #[doc = " Get a list of currently connected sensors.\n\n \\param count a pointer filled in with the number of sensors returned, may\n              be NULL.\n \\returns a 0 terminated array of sensor instance IDs or NULL on failure;\n          call SDL_GetError() for more information. This should be freed\n          with SDL_free() when it is no longer needed.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSensors(count: *mut ::core::ffi::c_int) -> *mut SDL_SensorID;
}
unsafe extern "C" {
    #[doc = " Get the implementation dependent name of a sensor.\n\n This can be called before any sensors are opened.\n\n \\param instance_id the sensor instance ID.\n \\returns the sensor name, or NULL if `instance_id` is not valid.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSensorNameForID(instance_id: SDL_SensorID) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the type of a sensor.\n\n This can be called before any sensors are opened.\n\n \\param instance_id the sensor instance ID.\n \\returns the SDL_SensorType, or `SDL_SENSOR_INVALID` if `instance_id` is\n          not valid.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSensorTypeForID(instance_id: SDL_SensorID) -> SDL_SensorType;
}
unsafe extern "C" {
    #[doc = " Get the platform dependent type of a sensor.\n\n This can be called before any sensors are opened.\n\n \\param instance_id the sensor instance ID.\n \\returns the sensor platform dependent type, or -1 if `instance_id` is not\n          valid.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSensorNonPortableTypeForID(instance_id: SDL_SensorID) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Open a sensor for use.\n\n \\param instance_id the sensor instance ID.\n \\returns an SDL_Sensor object or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_OpenSensor(instance_id: SDL_SensorID) -> *mut SDL_Sensor;
}
unsafe extern "C" {
    #[doc = " Return the SDL_Sensor associated with an instance ID.\n\n \\param instance_id the sensor instance ID.\n \\returns an SDL_Sensor object or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSensorFromID(instance_id: SDL_SensorID) -> *mut SDL_Sensor;
}
unsafe extern "C" {
    #[doc = " Get the properties associated with a sensor.\n\n \\param sensor the SDL_Sensor object.\n \\returns a valid property ID on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSensorProperties(sensor: *mut SDL_Sensor) -> SDL_PropertiesID;
}
unsafe extern "C" {
    #[doc = " Get the implementation dependent name of a sensor.\n\n \\param sensor the SDL_Sensor object.\n \\returns the sensor name or NULL on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSensorName(sensor: *mut SDL_Sensor) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the type of a sensor.\n\n \\param sensor the SDL_Sensor object to inspect.\n \\returns the SDL_SensorType type, or `SDL_SENSOR_INVALID` if `sensor` is\n          NULL.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSensorType(sensor: *mut SDL_Sensor) -> SDL_SensorType;
}
unsafe extern "C" {
    #[doc = " Get the platform dependent type of a sensor.\n\n \\param sensor the SDL_Sensor object to inspect.\n \\returns the sensor platform dependent type, or -1 if `sensor` is NULL.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSensorNonPortableType(sensor: *mut SDL_Sensor) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the instance ID of a sensor.\n\n \\param sensor the SDL_Sensor object to inspect.\n \\returns the sensor instance ID, or 0 on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSensorID(sensor: *mut SDL_Sensor) -> SDL_SensorID;
}
unsafe extern "C" {
    #[doc = " Get the current state of an opened sensor.\n\n The number of values and interpretation of the data is sensor dependent.\n\n \\param sensor the SDL_Sensor object to query.\n \\param data a pointer filled with the current sensor state.\n \\param num_values the number of values to write to data.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSensorData(
        sensor: *mut SDL_Sensor,
        data: *mut f32,
        num_values: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Close a sensor previously opened with SDL_OpenSensor().\n\n \\param sensor the SDL_Sensor object to close.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_CloseSensor(sensor: *mut SDL_Sensor);
}
unsafe extern "C" {
    #[doc = " Update the current state of the open sensors.\n\n This is called automatically by the event loop if sensor events are\n enabled.\n\n This needs to be called from the thread that initialized the sensor\n subsystem.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_UpdateSensors();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Joystick {
    _unused: [u8; 0],
}
#[doc = " This is a unique ID for a joystick for the time it is connected to the\n system, and is never reused for the lifetime of the application.\n\n If the joystick is disconnected and reconnected, it will get a new ID.\n\n The value 0 is an invalid ID.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_JoystickID = Uint32;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_UNKNOWN: SDL_JoystickType = 0;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_GAMEPAD: SDL_JoystickType = 1;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_WHEEL: SDL_JoystickType = 2;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_ARCADE_STICK: SDL_JoystickType = 3;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_FLIGHT_STICK: SDL_JoystickType = 4;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_DANCE_PAD: SDL_JoystickType = 5;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_GUITAR: SDL_JoystickType = 6;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_DRUM_KIT: SDL_JoystickType = 7;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_ARCADE_PAD: SDL_JoystickType = 8;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_THROTTLE: SDL_JoystickType = 9;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_COUNT: SDL_JoystickType = 10;
#[doc = " An enum of some common joystick types.\n\n In some cases, SDL can identify a low-level joystick as being a certain\n type of device, and will report it through SDL_GetJoystickType (or\n SDL_GetJoystickTypeForID).\n\n This is by no means a complete list of everything that can be plugged into\n a computer.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_JoystickType = ::core::ffi::c_uint;
pub const SDL_JoystickConnectionState_SDL_JOYSTICK_CONNECTION_INVALID: SDL_JoystickConnectionState =
    -1;
pub const SDL_JoystickConnectionState_SDL_JOYSTICK_CONNECTION_UNKNOWN: SDL_JoystickConnectionState =
    0;
pub const SDL_JoystickConnectionState_SDL_JOYSTICK_CONNECTION_WIRED: SDL_JoystickConnectionState =
    1;
pub const SDL_JoystickConnectionState_SDL_JOYSTICK_CONNECTION_WIRELESS:
    SDL_JoystickConnectionState = 2;
#[doc = " Possible connection states for a joystick device.\n\n This is used by SDL_GetJoystickConnectionState to report how a device is\n connected to the system.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_JoystickConnectionState = ::core::ffi::c_int;
unsafe extern "C" {
    #[doc = " Locking for atomic access to the joystick API.\n\n The SDL joystick functions are thread-safe, however you can lock the\n joysticks while processing to guarantee that the joystick list won't change\n and joystick and gamepad events will not be delivered.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_LockJoysticks();
}
unsafe extern "C" {
    #[doc = " Unlocking for atomic access to the joystick API.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_UnlockJoysticks();
}
unsafe extern "C" {
    #[doc = " Return whether a joystick is currently connected.\n\n \\returns true if a joystick is connected, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoysticks"]
    pub fn SDL_HasJoystick() -> bool;
}
unsafe extern "C" {
    #[doc = " Get a list of currently connected joysticks.\n\n \\param count a pointer filled in with the number of joysticks returned, may\n              be NULL.\n \\returns a 0 terminated array of joystick instance IDs or NULL on failure;\n          call SDL_GetError() for more information. This should be freed\n          with SDL_free() when it is no longer needed.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_HasJoystick\n \\sa SDL_OpenJoystick"]
    pub fn SDL_GetJoysticks(count: *mut ::core::ffi::c_int) -> *mut SDL_JoystickID;
}
unsafe extern "C" {
    #[doc = " Get the implementation dependent name of a joystick.\n\n This can be called before any joysticks are opened.\n\n \\param instance_id the joystick instance ID.\n \\returns the name of the selected joystick. If no name can be found, this\n          function returns NULL; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickName\n \\sa SDL_GetJoysticks"]
    pub fn SDL_GetJoystickNameForID(instance_id: SDL_JoystickID) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the implementation dependent path of a joystick.\n\n This can be called before any joysticks are opened.\n\n \\param instance_id the joystick instance ID.\n \\returns the path of the selected joystick. If no path can be found, this\n          function returns NULL; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickPath\n \\sa SDL_GetJoysticks"]
    pub fn SDL_GetJoystickPathForID(instance_id: SDL_JoystickID) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the player index of a joystick.\n\n This can be called before any joysticks are opened.\n\n \\param instance_id the joystick instance ID.\n \\returns the player index of a joystick, or -1 if it's not available.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickPlayerIndex\n \\sa SDL_GetJoysticks"]
    pub fn SDL_GetJoystickPlayerIndexForID(instance_id: SDL_JoystickID) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the implementation-dependent GUID of a joystick.\n\n This can be called before any joysticks are opened.\n\n \\param instance_id the joystick instance ID.\n \\returns the GUID of the selected joystick. If called with an invalid\n          instance_id, this function returns a zero GUID.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickGUID\n \\sa SDL_GUIDToString"]
    pub fn SDL_GetJoystickGUIDForID(instance_id: SDL_JoystickID) -> SDL_GUID;
}
unsafe extern "C" {
    #[doc = " Get the USB vendor ID of a joystick, if available.\n\n This can be called before any joysticks are opened. If the vendor ID isn't\n available this function returns 0.\n\n \\param instance_id the joystick instance ID.\n \\returns the USB vendor ID of the selected joystick. If called with an\n          invalid instance_id, this function returns 0.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickVendor\n \\sa SDL_GetJoysticks"]
    pub fn SDL_GetJoystickVendorForID(instance_id: SDL_JoystickID) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the USB product ID of a joystick, if available.\n\n This can be called before any joysticks are opened. If the product ID isn't\n available this function returns 0.\n\n \\param instance_id the joystick instance ID.\n \\returns the USB product ID of the selected joystick. If called with an\n          invalid instance_id, this function returns 0.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickProduct\n \\sa SDL_GetJoysticks"]
    pub fn SDL_GetJoystickProductForID(instance_id: SDL_JoystickID) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the product version of a joystick, if available.\n\n This can be called before any joysticks are opened. If the product version\n isn't available this function returns 0.\n\n \\param instance_id the joystick instance ID.\n \\returns the product version of the selected joystick. If called with an\n          invalid instance_id, this function returns 0.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickProductVersion\n \\sa SDL_GetJoysticks"]
    pub fn SDL_GetJoystickProductVersionForID(instance_id: SDL_JoystickID) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the type of a joystick, if available.\n\n This can be called before any joysticks are opened.\n\n \\param instance_id the joystick instance ID.\n \\returns the SDL_JoystickType of the selected joystick. If called with an\n          invalid instance_id, this function returns\n          `SDL_JOYSTICK_TYPE_UNKNOWN`.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickType\n \\sa SDL_GetJoysticks"]
    pub fn SDL_GetJoystickTypeForID(instance_id: SDL_JoystickID) -> SDL_JoystickType;
}
unsafe extern "C" {
    #[doc = " Open a joystick for use.\n\n The joystick subsystem must be initialized before a joystick can be opened\n for use.\n\n \\param instance_id the joystick instance ID.\n \\returns a joystick identifier or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CloseJoystick"]
    pub fn SDL_OpenJoystick(instance_id: SDL_JoystickID) -> *mut SDL_Joystick;
}
unsafe extern "C" {
    #[doc = " Get the SDL_Joystick associated with an instance ID, if it has been opened.\n\n \\param instance_id the instance ID to get the SDL_Joystick for.\n \\returns an SDL_Joystick on success or NULL on failure or if it hasn't been\n          opened yet; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetJoystickFromID(instance_id: SDL_JoystickID) -> *mut SDL_Joystick;
}
unsafe extern "C" {
    #[doc = " Get the SDL_Joystick associated with a player index.\n\n \\param player_index the player index to get the SDL_Joystick for.\n \\returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()\n          for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickPlayerIndex\n \\sa SDL_SetJoystickPlayerIndex"]
    pub fn SDL_GetJoystickFromPlayerIndex(player_index: ::core::ffi::c_int) -> *mut SDL_Joystick;
}
#[doc = " The structure that describes a virtual joystick touchpad.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_VirtualJoystickDesc"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_VirtualJoystickTouchpadDesc {
    #[doc = "< the number of simultaneous fingers on this touchpad"]
    pub nfingers: Uint16,
    pub padding: [Uint16; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_VirtualJoystickTouchpadDesc"]
        [::core::mem::size_of::<SDL_VirtualJoystickTouchpadDesc>() - 8usize];
    ["Alignment of SDL_VirtualJoystickTouchpadDesc"]
        [::core::mem::align_of::<SDL_VirtualJoystickTouchpadDesc>() - 2usize];
    ["Offset of field: SDL_VirtualJoystickTouchpadDesc::nfingers"]
        [::core::mem::offset_of!(SDL_VirtualJoystickTouchpadDesc, nfingers) - 0usize];
    ["Offset of field: SDL_VirtualJoystickTouchpadDesc::padding"]
        [::core::mem::offset_of!(SDL_VirtualJoystickTouchpadDesc, padding) - 2usize];
};
#[doc = " The structure that describes a virtual joystick sensor.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_VirtualJoystickDesc"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_VirtualJoystickSensorDesc {
    #[doc = "< the type of this sensor"]
    pub type_: SDL_SensorType,
    #[doc = "< the update frequency of this sensor, may be 0.0f"]
    pub rate: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_VirtualJoystickSensorDesc"]
        [::core::mem::size_of::<SDL_VirtualJoystickSensorDesc>() - 8usize];
    ["Alignment of SDL_VirtualJoystickSensorDesc"]
        [::core::mem::align_of::<SDL_VirtualJoystickSensorDesc>() - 4usize];
    ["Offset of field: SDL_VirtualJoystickSensorDesc::type_"]
        [::core::mem::offset_of!(SDL_VirtualJoystickSensorDesc, type_) - 0usize];
    ["Offset of field: SDL_VirtualJoystickSensorDesc::rate"]
        [::core::mem::offset_of!(SDL_VirtualJoystickSensorDesc, rate) - 4usize];
};
#[doc = " The structure that describes a virtual joystick.\n\n This structure should be initialized using SDL_INIT_INTERFACE(). All\n elements of this structure are optional.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_AttachVirtualJoystick\n \\sa SDL_INIT_INTERFACE\n \\sa SDL_VirtualJoystickSensorDesc\n \\sa SDL_VirtualJoystickTouchpadDesc"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_VirtualJoystickDesc {
    #[doc = "< the version of this interface"]
    pub version: Uint32,
    #[doc = "< `SDL_JoystickType`"]
    pub type_: Uint16,
    #[doc = "< unused"]
    pub padding: Uint16,
    #[doc = "< the USB vendor ID of this joystick"]
    pub vendor_id: Uint16,
    #[doc = "< the USB product ID of this joystick"]
    pub product_id: Uint16,
    #[doc = "< the number of axes on this joystick"]
    pub naxes: Uint16,
    #[doc = "< the number of buttons on this joystick"]
    pub nbuttons: Uint16,
    #[doc = "< the number of balls on this joystick"]
    pub nballs: Uint16,
    #[doc = "< the number of hats on this joystick"]
    pub nhats: Uint16,
    #[doc = "< the number of touchpads on this joystick, requires `touchpads` to point at valid descriptions"]
    pub ntouchpads: Uint16,
    #[doc = "< the number of sensors on this joystick, requires `sensors` to point at valid descriptions"]
    pub nsensors: Uint16,
    #[doc = "< unused"]
    pub padding2: [Uint16; 2usize],
    #[doc = "< A mask of which buttons are valid for this controller\ne.g. (1 << SDL_GAMEPAD_BUTTON_SOUTH)"]
    pub button_mask: Uint32,
    #[doc = "< A mask of which axes are valid for this controller\ne.g. (1 << SDL_GAMEPAD_AXIS_LEFTX)"]
    pub axis_mask: Uint32,
    #[doc = "< the name of the joystick"]
    pub name: *const ::core::ffi::c_char,
    #[doc = "< A pointer to an array of touchpad descriptions, required if `ntouchpads` is > 0"]
    pub touchpads: *const SDL_VirtualJoystickTouchpadDesc,
    #[doc = "< A pointer to an array of sensor descriptions, required if `nsensors` is > 0"]
    pub sensors: *const SDL_VirtualJoystickSensorDesc,
    #[doc = "< User data pointer passed to callbacks"]
    pub userdata: *mut ::core::ffi::c_void,
    #[doc = "< Called when the joystick state should be updated"]
    pub Update: ::core::option::Option<unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void)>,
    #[doc = "< Called when the player index is set"]
    pub SetPlayerIndex: ::core::option::Option<
        unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void, player_index: ::core::ffi::c_int),
    >,
    #[doc = "< Implements SDL_RumbleJoystick()"]
    pub Rumble: ::core::option::Option<
        unsafe extern "C" fn(
            userdata: *mut ::core::ffi::c_void,
            low_frequency_rumble: Uint16,
            high_frequency_rumble: Uint16,
        ) -> bool,
    >,
    #[doc = "< Implements SDL_RumbleJoystickTriggers()"]
    pub RumbleTriggers: ::core::option::Option<
        unsafe extern "C" fn(
            userdata: *mut ::core::ffi::c_void,
            left_rumble: Uint16,
            right_rumble: Uint16,
        ) -> bool,
    >,
    #[doc = "< Implements SDL_SetJoystickLED()"]
    pub SetLED: ::core::option::Option<
        unsafe extern "C" fn(
            userdata: *mut ::core::ffi::c_void,
            red: Uint8,
            green: Uint8,
            blue: Uint8,
        ) -> bool,
    >,
    #[doc = "< Implements SDL_SendJoystickEffect()"]
    pub SendEffect: ::core::option::Option<
        unsafe extern "C" fn(
            userdata: *mut ::core::ffi::c_void,
            data: *const ::core::ffi::c_void,
            size: ::core::ffi::c_int,
        ) -> bool,
    >,
    #[doc = "< Implements SDL_SetGamepadSensorEnabled()"]
    pub SetSensorsEnabled: ::core::option::Option<
        unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void, enabled: bool) -> bool,
    >,
    #[doc = "< Cleans up the userdata when the joystick is detached"]
    pub Cleanup: ::core::option::Option<unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_VirtualJoystickDesc"]
        [::core::mem::size_of::<SDL_VirtualJoystickDesc>() - 136usize];
    ["Alignment of SDL_VirtualJoystickDesc"]
        [::core::mem::align_of::<SDL_VirtualJoystickDesc>() - 8usize];
    ["Offset of field: SDL_VirtualJoystickDesc::version"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, version) - 0usize];
    ["Offset of field: SDL_VirtualJoystickDesc::type_"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, type_) - 4usize];
    ["Offset of field: SDL_VirtualJoystickDesc::padding"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, padding) - 6usize];
    ["Offset of field: SDL_VirtualJoystickDesc::vendor_id"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, vendor_id) - 8usize];
    ["Offset of field: SDL_VirtualJoystickDesc::product_id"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, product_id) - 10usize];
    ["Offset of field: SDL_VirtualJoystickDesc::naxes"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, naxes) - 12usize];
    ["Offset of field: SDL_VirtualJoystickDesc::nbuttons"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, nbuttons) - 14usize];
    ["Offset of field: SDL_VirtualJoystickDesc::nballs"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, nballs) - 16usize];
    ["Offset of field: SDL_VirtualJoystickDesc::nhats"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, nhats) - 18usize];
    ["Offset of field: SDL_VirtualJoystickDesc::ntouchpads"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, ntouchpads) - 20usize];
    ["Offset of field: SDL_VirtualJoystickDesc::nsensors"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, nsensors) - 22usize];
    ["Offset of field: SDL_VirtualJoystickDesc::padding2"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, padding2) - 24usize];
    ["Offset of field: SDL_VirtualJoystickDesc::button_mask"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, button_mask) - 28usize];
    ["Offset of field: SDL_VirtualJoystickDesc::axis_mask"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, axis_mask) - 32usize];
    ["Offset of field: SDL_VirtualJoystickDesc::name"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, name) - 40usize];
    ["Offset of field: SDL_VirtualJoystickDesc::touchpads"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, touchpads) - 48usize];
    ["Offset of field: SDL_VirtualJoystickDesc::sensors"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, sensors) - 56usize];
    ["Offset of field: SDL_VirtualJoystickDesc::userdata"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, userdata) - 64usize];
    ["Offset of field: SDL_VirtualJoystickDesc::Update"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, Update) - 72usize];
    ["Offset of field: SDL_VirtualJoystickDesc::SetPlayerIndex"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, SetPlayerIndex) - 80usize];
    ["Offset of field: SDL_VirtualJoystickDesc::Rumble"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, Rumble) - 88usize];
    ["Offset of field: SDL_VirtualJoystickDesc::RumbleTriggers"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, RumbleTriggers) - 96usize];
    ["Offset of field: SDL_VirtualJoystickDesc::SetLED"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, SetLED) - 104usize];
    ["Offset of field: SDL_VirtualJoystickDesc::SendEffect"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, SendEffect) - 112usize];
    ["Offset of field: SDL_VirtualJoystickDesc::SetSensorsEnabled"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, SetSensorsEnabled) - 120usize];
    ["Offset of field: SDL_VirtualJoystickDesc::Cleanup"]
        [::core::mem::offset_of!(SDL_VirtualJoystickDesc, Cleanup) - 128usize];
};
unsafe extern "C" {
    #[doc = " Attach a new virtual joystick.\n\n \\param desc joystick description, initialized using SDL_INIT_INTERFACE().\n \\returns the joystick instance ID, or 0 on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DetachVirtualJoystick"]
    pub fn SDL_AttachVirtualJoystick(desc: *const SDL_VirtualJoystickDesc) -> SDL_JoystickID;
}
unsafe extern "C" {
    #[doc = " Detach a virtual joystick.\n\n \\param instance_id the joystick instance ID, previously returned from\n                    SDL_AttachVirtualJoystick().\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AttachVirtualJoystick"]
    pub fn SDL_DetachVirtualJoystick(instance_id: SDL_JoystickID) -> bool;
}
unsafe extern "C" {
    #[doc = " Query whether or not a joystick is virtual.\n\n \\param instance_id the joystick instance ID.\n \\returns true if the joystick is virtual, false otherwise.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_IsJoystickVirtual(instance_id: SDL_JoystickID) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the state of an axis on an opened virtual joystick.\n\n Please note that values set here will not be applied until the next call to\n SDL_UpdateJoysticks, which can either be called directly, or can be called\n indirectly through various other SDL APIs, including, but not limited to\n the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,\n SDL_WaitEvent.\n\n Note that when sending trigger axes, you should scale the value to the full\n range of Sint16. For example, a trigger at rest would have the value of\n `SDL_JOYSTICK_AXIS_MIN`.\n\n \\param joystick the virtual joystick on which to set state.\n \\param axis the index of the axis on the virtual joystick to update.\n \\param value the new value for the specified axis.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetJoystickVirtualAxis(
        joystick: *mut SDL_Joystick,
        axis: ::core::ffi::c_int,
        value: Sint16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Generate ball motion on an opened virtual joystick.\n\n Please note that values set here will not be applied until the next call to\n SDL_UpdateJoysticks, which can either be called directly, or can be called\n indirectly through various other SDL APIs, including, but not limited to\n the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,\n SDL_WaitEvent.\n\n \\param joystick the virtual joystick on which to set state.\n \\param ball the index of the ball on the virtual joystick to update.\n \\param xrel the relative motion on the X axis.\n \\param yrel the relative motion on the Y axis.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetJoystickVirtualBall(
        joystick: *mut SDL_Joystick,
        ball: ::core::ffi::c_int,
        xrel: Sint16,
        yrel: Sint16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the state of a button on an opened virtual joystick.\n\n Please note that values set here will not be applied until the next call to\n SDL_UpdateJoysticks, which can either be called directly, or can be called\n indirectly through various other SDL APIs, including, but not limited to\n the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,\n SDL_WaitEvent.\n\n \\param joystick the virtual joystick on which to set state.\n \\param button the index of the button on the virtual joystick to update.\n \\param down true if the button is pressed, false otherwise.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetJoystickVirtualButton(
        joystick: *mut SDL_Joystick,
        button: ::core::ffi::c_int,
        down: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the state of a hat on an opened virtual joystick.\n\n Please note that values set here will not be applied until the next call to\n SDL_UpdateJoysticks, which can either be called directly, or can be called\n indirectly through various other SDL APIs, including, but not limited to\n the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,\n SDL_WaitEvent.\n\n \\param joystick the virtual joystick on which to set state.\n \\param hat the index of the hat on the virtual joystick to update.\n \\param value the new value for the specified hat.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetJoystickVirtualHat(
        joystick: *mut SDL_Joystick,
        hat: ::core::ffi::c_int,
        value: Uint8,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set touchpad finger state on an opened virtual joystick.\n\n Please note that values set here will not be applied until the next call to\n SDL_UpdateJoysticks, which can either be called directly, or can be called\n indirectly through various other SDL APIs, including, but not limited to\n the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,\n SDL_WaitEvent.\n\n \\param joystick the virtual joystick on which to set state.\n \\param touchpad the index of the touchpad on the virtual joystick to\n                 update.\n \\param finger the index of the finger on the touchpad to set.\n \\param down true if the finger is pressed, false if the finger is released.\n \\param x the x coordinate of the finger on the touchpad, normalized 0 to 1,\n          with the origin in the upper left.\n \\param y the y coordinate of the finger on the touchpad, normalized 0 to 1,\n          with the origin in the upper left.\n \\param pressure the pressure of the finger.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetJoystickVirtualTouchpad(
        joystick: *mut SDL_Joystick,
        touchpad: ::core::ffi::c_int,
        finger: ::core::ffi::c_int,
        down: bool,
        x: f32,
        y: f32,
        pressure: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Send a sensor update for an opened virtual joystick.\n\n Please note that values set here will not be applied until the next call to\n SDL_UpdateJoysticks, which can either be called directly, or can be called\n indirectly through various other SDL APIs, including, but not limited to\n the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,\n SDL_WaitEvent.\n\n \\param joystick the virtual joystick on which to set state.\n \\param type the type of the sensor on the virtual joystick to update.\n \\param sensor_timestamp a 64-bit timestamp in nanoseconds associated with\n                         the sensor reading.\n \\param data the data associated with the sensor reading.\n \\param num_values the number of values pointed to by `data`.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SendJoystickVirtualSensorData(
        joystick: *mut SDL_Joystick,
        type_: SDL_SensorType,
        sensor_timestamp: Uint64,
        data: *const f32,
        num_values: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the properties associated with a joystick.\n\n The following read-only properties are provided by SDL:\n\n - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an\n   LED that has adjustable brightness\n - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED\n   that has adjustable color\n - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a\n   player LED\n - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has\n   left/right rumble\n - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has\n   simple trigger rumble\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick().\n \\returns a valid property ID on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetJoystickProperties(joystick: *mut SDL_Joystick) -> SDL_PropertiesID;
}
unsafe extern "C" {
    #[doc = " Get the implementation dependent name of a joystick.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick().\n \\returns the name of the selected joystick. If no name can be found, this\n          function returns NULL; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickNameForID"]
    pub fn SDL_GetJoystickName(joystick: *mut SDL_Joystick) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the implementation dependent path of a joystick.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick().\n \\returns the path of the selected joystick. If no path can be found, this\n          function returns NULL; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickPathForID"]
    pub fn SDL_GetJoystickPath(joystick: *mut SDL_Joystick) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the player index of an opened joystick.\n\n For XInput controllers this returns the XInput user index. Many joysticks\n will not be able to supply this information.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick().\n \\returns the player index, or -1 if it's not available.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetJoystickPlayerIndex"]
    pub fn SDL_GetJoystickPlayerIndex(joystick: *mut SDL_Joystick) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Set the player index of an opened joystick.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick().\n \\param player_index player index to assign to this joystick, or -1 to clear\n                     the player index and turn off player LEDs.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickPlayerIndex"]
    pub fn SDL_SetJoystickPlayerIndex(
        joystick: *mut SDL_Joystick,
        player_index: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the implementation-dependent GUID for the joystick.\n\n This function requires an open joystick.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick().\n \\returns the GUID of the given joystick. If called on an invalid index,\n          this function returns a zero GUID; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickGUIDForID\n \\sa SDL_GUIDToString"]
    pub fn SDL_GetJoystickGUID(joystick: *mut SDL_Joystick) -> SDL_GUID;
}
unsafe extern "C" {
    #[doc = " Get the USB vendor ID of an opened joystick, if available.\n\n If the vendor ID isn't available this function returns 0.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick().\n \\returns the USB vendor ID of the selected joystick, or 0 if unavailable.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickVendorForID"]
    pub fn SDL_GetJoystickVendor(joystick: *mut SDL_Joystick) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the USB product ID of an opened joystick, if available.\n\n If the product ID isn't available this function returns 0.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick().\n \\returns the USB product ID of the selected joystick, or 0 if unavailable.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickProductForID"]
    pub fn SDL_GetJoystickProduct(joystick: *mut SDL_Joystick) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the product version of an opened joystick, if available.\n\n If the product version isn't available this function returns 0.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick().\n \\returns the product version of the selected joystick, or 0 if unavailable.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickProductVersionForID"]
    pub fn SDL_GetJoystickProductVersion(joystick: *mut SDL_Joystick) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the firmware version of an opened joystick, if available.\n\n If the firmware version isn't available this function returns 0.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick().\n \\returns the firmware version of the selected joystick, or 0 if\n          unavailable.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetJoystickFirmwareVersion(joystick: *mut SDL_Joystick) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the serial number of an opened joystick, if available.\n\n Returns the serial number of the joystick, or NULL if it is not available.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick().\n \\returns the serial number of the selected joystick, or NULL if\n          unavailable.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetJoystickSerial(joystick: *mut SDL_Joystick) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the type of an opened joystick.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick().\n \\returns the SDL_JoystickType of the selected joystick.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickTypeForID"]
    pub fn SDL_GetJoystickType(joystick: *mut SDL_Joystick) -> SDL_JoystickType;
}
unsafe extern "C" {
    #[doc = " Get the device information encoded in a SDL_GUID structure.\n\n \\param guid the SDL_GUID you wish to get info about.\n \\param vendor a pointer filled in with the device VID, or 0 if not\n               available.\n \\param product a pointer filled in with the device PID, or 0 if not\n                available.\n \\param version a pointer filled in with the device version, or 0 if not\n                available.\n \\param crc16 a pointer filled in with a CRC used to distinguish different\n              products with the same VID/PID, or 0 if not available.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickGUIDForID"]
    pub fn SDL_GetJoystickGUIDInfo(
        guid: SDL_GUID,
        vendor: *mut Uint16,
        product: *mut Uint16,
        version: *mut Uint16,
        crc16: *mut Uint16,
    );
}
unsafe extern "C" {
    #[doc = " Get the status of a specified joystick.\n\n \\param joystick the joystick to query.\n \\returns true if the joystick has been opened, false if it has not; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_JoystickConnected(joystick: *mut SDL_Joystick) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the instance ID of an opened joystick.\n\n \\param joystick an SDL_Joystick structure containing joystick information.\n \\returns the instance ID of the specified joystick on success or 0 on\n          failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetJoystickID(joystick: *mut SDL_Joystick) -> SDL_JoystickID;
}
unsafe extern "C" {
    #[doc = " Get the number of general axis controls on a joystick.\n\n Often, the directional pad on a game controller will either look like 4\n separate buttons or a POV hat, and not axes, but all of this is up to the\n device and platform.\n\n \\param joystick an SDL_Joystick structure containing joystick information.\n \\returns the number of axis controls/number of axes on success or -1 on\n          failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickAxis\n \\sa SDL_GetNumJoystickBalls\n \\sa SDL_GetNumJoystickButtons\n \\sa SDL_GetNumJoystickHats"]
    pub fn SDL_GetNumJoystickAxes(joystick: *mut SDL_Joystick) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of trackballs on a joystick.\n\n Joystick trackballs have only relative motion events associated with them\n and their state cannot be polled.\n\n Most joysticks do not have trackballs.\n\n \\param joystick an SDL_Joystick structure containing joystick information.\n \\returns the number of trackballs on success or -1 on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickBall\n \\sa SDL_GetNumJoystickAxes\n \\sa SDL_GetNumJoystickButtons\n \\sa SDL_GetNumJoystickHats"]
    pub fn SDL_GetNumJoystickBalls(joystick: *mut SDL_Joystick) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of POV hats on a joystick.\n\n \\param joystick an SDL_Joystick structure containing joystick information.\n \\returns the number of POV hats on success or -1 on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickHat\n \\sa SDL_GetNumJoystickAxes\n \\sa SDL_GetNumJoystickBalls\n \\sa SDL_GetNumJoystickButtons"]
    pub fn SDL_GetNumJoystickHats(joystick: *mut SDL_Joystick) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of buttons on a joystick.\n\n \\param joystick an SDL_Joystick structure containing joystick information.\n \\returns the number of buttons on success or -1 on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickButton\n \\sa SDL_GetNumJoystickAxes\n \\sa SDL_GetNumJoystickBalls\n \\sa SDL_GetNumJoystickHats"]
    pub fn SDL_GetNumJoystickButtons(joystick: *mut SDL_Joystick) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Set the state of joystick event processing.\n\n If joystick events are disabled, you must call SDL_UpdateJoysticks()\n yourself and check the state of the joystick when you want joystick\n information.\n\n \\param enabled whether to process joystick events or not.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_JoystickEventsEnabled\n \\sa SDL_UpdateJoysticks"]
    pub fn SDL_SetJoystickEventsEnabled(enabled: bool);
}
unsafe extern "C" {
    #[doc = " Query the state of joystick event processing.\n\n If joystick events are disabled, you must call SDL_UpdateJoysticks()\n yourself and check the state of the joystick when you want joystick\n information.\n\n \\returns true if joystick events are being processed, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetJoystickEventsEnabled"]
    pub fn SDL_JoystickEventsEnabled() -> bool;
}
unsafe extern "C" {
    #[doc = " Update the current state of the open joysticks.\n\n This is called automatically by the event loop if any joystick events are\n enabled.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_UpdateJoysticks();
}
unsafe extern "C" {
    #[doc = " Get the current state of an axis control on a joystick.\n\n SDL makes no promises about what part of the joystick any given axis refers\n to. Your game should have some sort of configuration UI to let users\n specify what each axis should be bound to. Alternately, SDL's higher-level\n Game Controller API makes a great effort to apply order to this lower-level\n interface, so you know that a specific axis is the \"left thumb stick,\" etc.\n\n The value returned by SDL_GetJoystickAxis() is a signed integer (-32768 to\n 32767) representing the current position of the axis. It may be necessary\n to impose certain tolerances on these values to account for jitter.\n\n \\param joystick an SDL_Joystick structure containing joystick information.\n \\param axis the axis to query; the axis indices start at index 0.\n \\returns a 16-bit signed integer representing the current position of the\n          axis or 0 on failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetNumJoystickAxes"]
    pub fn SDL_GetJoystickAxis(joystick: *mut SDL_Joystick, axis: ::core::ffi::c_int) -> Sint16;
}
unsafe extern "C" {
    #[doc = " Get the initial state of an axis control on a joystick.\n\n The state is a value ranging from -32768 to 32767.\n\n The axis indices start at index 0.\n\n \\param joystick an SDL_Joystick structure containing joystick information.\n \\param axis the axis to query; the axis indices start at index 0.\n \\param state upon return, the initial value is supplied here.\n \\returns true if this axis has any initial value, or false if not.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetJoystickAxisInitialState(
        joystick: *mut SDL_Joystick,
        axis: ::core::ffi::c_int,
        state: *mut Sint16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the ball axis change since the last poll.\n\n Trackballs can only return relative motion since the last call to\n SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.\n\n Most joysticks do not have trackballs.\n\n \\param joystick the SDL_Joystick to query.\n \\param ball the ball index to query; ball indices start at index 0.\n \\param dx stores the difference in the x axis position since the last poll.\n \\param dy stores the difference in the y axis position since the last poll.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetNumJoystickBalls"]
    pub fn SDL_GetJoystickBall(
        joystick: *mut SDL_Joystick,
        ball: ::core::ffi::c_int,
        dx: *mut ::core::ffi::c_int,
        dy: *mut ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the current state of a POV hat on a joystick.\n\n The returned value will be one of the `SDL_HAT_*` values.\n\n \\param joystick an SDL_Joystick structure containing joystick information.\n \\param hat the hat index to get the state from; indices start at index 0.\n \\returns the current hat position.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetNumJoystickHats"]
    pub fn SDL_GetJoystickHat(joystick: *mut SDL_Joystick, hat: ::core::ffi::c_int) -> Uint8;
}
unsafe extern "C" {
    #[doc = " Get the current state of a button on a joystick.\n\n \\param joystick an SDL_Joystick structure containing joystick information.\n \\param button the button index to get the state from; indices start at\n               index 0.\n \\returns true if the button is pressed, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetNumJoystickButtons"]
    pub fn SDL_GetJoystickButton(joystick: *mut SDL_Joystick, button: ::core::ffi::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = " Start a rumble effect.\n\n Each call to this function cancels any previous rumble effect, and calling\n it with 0 intensity stops any rumbling.\n\n This function requires you to process SDL events or call\n SDL_UpdateJoysticks() to update rumble state.\n\n \\param joystick the joystick to vibrate.\n \\param low_frequency_rumble the intensity of the low frequency (left)\n                             rumble motor, from 0 to 0xFFFF.\n \\param high_frequency_rumble the intensity of the high frequency (right)\n                              rumble motor, from 0 to 0xFFFF.\n \\param duration_ms the duration of the rumble effect, in milliseconds.\n \\returns true, or false if rumble isn't supported on this joystick.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_RumbleJoystick(
        joystick: *mut SDL_Joystick,
        low_frequency_rumble: Uint16,
        high_frequency_rumble: Uint16,
        duration_ms: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Start a rumble effect in the joystick's triggers.\n\n Each call to this function cancels any previous trigger rumble effect, and\n calling it with 0 intensity stops any rumbling.\n\n Note that this is rumbling of the _triggers_ and not the game controller as\n a whole. This is currently only supported on Xbox One controllers. If you\n want the (more common) whole-controller rumble, use SDL_RumbleJoystick()\n instead.\n\n This function requires you to process SDL events or call\n SDL_UpdateJoysticks() to update rumble state.\n\n \\param joystick the joystick to vibrate.\n \\param left_rumble the intensity of the left trigger rumble motor, from 0\n                    to 0xFFFF.\n \\param right_rumble the intensity of the right trigger rumble motor, from 0\n                     to 0xFFFF.\n \\param duration_ms the duration of the rumble effect, in milliseconds.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_RumbleJoystick"]
    pub fn SDL_RumbleJoystickTriggers(
        joystick: *mut SDL_Joystick,
        left_rumble: Uint16,
        right_rumble: Uint16,
        duration_ms: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Update a joystick's LED color.\n\n An example of a joystick LED is the light on the back of a PlayStation 4's\n DualShock 4 controller.\n\n For joysticks with a single color LED, the maximum of the RGB values will\n be used as the LED brightness.\n\n \\param joystick the joystick to update.\n \\param red the intensity of the red LED.\n \\param green the intensity of the green LED.\n \\param blue the intensity of the blue LED.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetJoystickLED(
        joystick: *mut SDL_Joystick,
        red: Uint8,
        green: Uint8,
        blue: Uint8,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Send a joystick specific effect packet.\n\n \\param joystick the joystick to affect.\n \\param data the data to send to the joystick.\n \\param size the size of the data to send to the joystick.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SendJoystickEffect(
        joystick: *mut SDL_Joystick,
        data: *const ::core::ffi::c_void,
        size: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Close a joystick previously opened with SDL_OpenJoystick().\n\n \\param joystick the joystick device to close.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_OpenJoystick"]
    pub fn SDL_CloseJoystick(joystick: *mut SDL_Joystick);
}
unsafe extern "C" {
    #[doc = " Get the connection state of a joystick.\n\n \\param joystick the joystick to query.\n \\returns the connection state on success or\n          `SDL_JOYSTICK_CONNECTION_INVALID` on failure; call SDL_GetError()\n          for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetJoystickConnectionState(
        joystick: *mut SDL_Joystick,
    ) -> SDL_JoystickConnectionState;
}
unsafe extern "C" {
    #[doc = " Get the battery state of a joystick.\n\n You should never take a battery status as absolute truth. Batteries\n (especially failing batteries) are delicate hardware, and the values\n reported here are best estimates based on what that hardware reports. It's\n not uncommon for older batteries to lose stored power much faster than it\n reports, or completely drain when reporting it has 20 percent left, etc.\n\n \\param joystick the joystick to query.\n \\param percent a pointer filled in with the percentage of battery life\n                left, between 0 and 100, or NULL to ignore. This will be\n                filled in with -1 we can't determine a value or there is no\n                battery.\n \\returns the current battery state or `SDL_POWERSTATE_ERROR` on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetJoystickPowerInfo(
        joystick: *mut SDL_Joystick,
        percent: *mut ::core::ffi::c_int,
    ) -> SDL_PowerState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Gamepad {
    _unused: [u8; 0],
}
pub const SDL_GamepadType_SDL_GAMEPAD_TYPE_UNKNOWN: SDL_GamepadType = 0;
pub const SDL_GamepadType_SDL_GAMEPAD_TYPE_STANDARD: SDL_GamepadType = 1;
pub const SDL_GamepadType_SDL_GAMEPAD_TYPE_XBOX360: SDL_GamepadType = 2;
pub const SDL_GamepadType_SDL_GAMEPAD_TYPE_XBOXONE: SDL_GamepadType = 3;
pub const SDL_GamepadType_SDL_GAMEPAD_TYPE_PS3: SDL_GamepadType = 4;
pub const SDL_GamepadType_SDL_GAMEPAD_TYPE_PS4: SDL_GamepadType = 5;
pub const SDL_GamepadType_SDL_GAMEPAD_TYPE_PS5: SDL_GamepadType = 6;
pub const SDL_GamepadType_SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_PRO: SDL_GamepadType = 7;
pub const SDL_GamepadType_SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_LEFT: SDL_GamepadType = 8;
pub const SDL_GamepadType_SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_RIGHT: SDL_GamepadType = 9;
pub const SDL_GamepadType_SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_PAIR: SDL_GamepadType = 10;
pub const SDL_GamepadType_SDL_GAMEPAD_TYPE_COUNT: SDL_GamepadType = 11;
#[doc = " Standard gamepad types.\n\n This type does not necessarily map to first-party controllers from\n Microsoft/Sony/Nintendo; in many cases, third-party controllers can report\n as these, either because they were designed for a specific console, or they\n simply most closely match that console's controllers (does it have A/B/X/Y\n buttons or X/O/Square/Triangle? Does it have a touchpad? etc)."]
pub type SDL_GamepadType = ::core::ffi::c_uint;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_INVALID: SDL_GamepadButton = -1;
#[doc = "< Bottom face button (e.g. Xbox A button)"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_SOUTH: SDL_GamepadButton = 0;
#[doc = "< Right face button (e.g. Xbox B button)"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_EAST: SDL_GamepadButton = 1;
#[doc = "< Left face button (e.g. Xbox X button)"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_WEST: SDL_GamepadButton = 2;
#[doc = "< Top face button (e.g. Xbox Y button)"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_NORTH: SDL_GamepadButton = 3;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_BACK: SDL_GamepadButton = 4;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_GUIDE: SDL_GamepadButton = 5;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_START: SDL_GamepadButton = 6;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_LEFT_STICK: SDL_GamepadButton = 7;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_RIGHT_STICK: SDL_GamepadButton = 8;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_LEFT_SHOULDER: SDL_GamepadButton = 9;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_RIGHT_SHOULDER: SDL_GamepadButton = 10;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_DPAD_UP: SDL_GamepadButton = 11;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_DPAD_DOWN: SDL_GamepadButton = 12;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_DPAD_LEFT: SDL_GamepadButton = 13;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_DPAD_RIGHT: SDL_GamepadButton = 14;
#[doc = "< Additional button (e.g. Xbox Series X share button, PS5 microphone button, Nintendo Switch Pro capture button, Amazon Luna microphone button, Google Stadia capture button)"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_MISC1: SDL_GamepadButton = 15;
#[doc = "< Upper or primary paddle, under your right hand (e.g. Xbox Elite paddle P1)"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_RIGHT_PADDLE1: SDL_GamepadButton = 16;
#[doc = "< Upper or primary paddle, under your left hand (e.g. Xbox Elite paddle P3)"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_LEFT_PADDLE1: SDL_GamepadButton = 17;
#[doc = "< Lower or secondary paddle, under your right hand (e.g. Xbox Elite paddle P2)"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_RIGHT_PADDLE2: SDL_GamepadButton = 18;
#[doc = "< Lower or secondary paddle, under your left hand (e.g. Xbox Elite paddle P4)"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_LEFT_PADDLE2: SDL_GamepadButton = 19;
#[doc = "< PS4/PS5 touchpad button"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_TOUCHPAD: SDL_GamepadButton = 20;
#[doc = "< Additional button"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_MISC2: SDL_GamepadButton = 21;
#[doc = "< Additional button"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_MISC3: SDL_GamepadButton = 22;
#[doc = "< Additional button"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_MISC4: SDL_GamepadButton = 23;
#[doc = "< Additional button"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_MISC5: SDL_GamepadButton = 24;
#[doc = "< Additional button"]
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_MISC6: SDL_GamepadButton = 25;
pub const SDL_GamepadButton_SDL_GAMEPAD_BUTTON_COUNT: SDL_GamepadButton = 26;
#[doc = " The list of buttons available on a gamepad\n\n For controllers that use a diamond pattern for the face buttons, the\n south/east/west/north buttons below correspond to the locations in the\n diamond pattern. For Xbox controllers, this would be A/B/X/Y, for Nintendo\n Switch controllers, this would be B/A/Y/X, for PlayStation controllers this\n would be Cross/Circle/Square/Triangle.\n\n For controllers that don't use a diamond pattern for the face buttons, the\n south/east/west/north buttons indicate the buttons labeled A, B, C, D, or\n 1, 2, 3, 4, or for controllers that aren't labeled, they are the primary,\n secondary, etc. buttons.\n\n The activate action is often the south button and the cancel action is\n often the east button, but in some regions this is reversed, so your game\n should allow remapping actions based on user preferences.\n\n You can query the labels for the face buttons using\n SDL_GetGamepadButtonLabel()\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_GamepadButton = ::core::ffi::c_int;
pub const SDL_GamepadButtonLabel_SDL_GAMEPAD_BUTTON_LABEL_UNKNOWN: SDL_GamepadButtonLabel = 0;
pub const SDL_GamepadButtonLabel_SDL_GAMEPAD_BUTTON_LABEL_A: SDL_GamepadButtonLabel = 1;
pub const SDL_GamepadButtonLabel_SDL_GAMEPAD_BUTTON_LABEL_B: SDL_GamepadButtonLabel = 2;
pub const SDL_GamepadButtonLabel_SDL_GAMEPAD_BUTTON_LABEL_X: SDL_GamepadButtonLabel = 3;
pub const SDL_GamepadButtonLabel_SDL_GAMEPAD_BUTTON_LABEL_Y: SDL_GamepadButtonLabel = 4;
pub const SDL_GamepadButtonLabel_SDL_GAMEPAD_BUTTON_LABEL_CROSS: SDL_GamepadButtonLabel = 5;
pub const SDL_GamepadButtonLabel_SDL_GAMEPAD_BUTTON_LABEL_CIRCLE: SDL_GamepadButtonLabel = 6;
pub const SDL_GamepadButtonLabel_SDL_GAMEPAD_BUTTON_LABEL_SQUARE: SDL_GamepadButtonLabel = 7;
pub const SDL_GamepadButtonLabel_SDL_GAMEPAD_BUTTON_LABEL_TRIANGLE: SDL_GamepadButtonLabel = 8;
#[doc = " The set of gamepad button labels\n\n This isn't a complete set, just the face buttons to make it easy to show\n button prompts.\n\n For a complete set, you should look at the button and gamepad type and have\n a set of symbols that work well with your art style.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_GamepadButtonLabel = ::core::ffi::c_uint;
pub const SDL_GamepadAxis_SDL_GAMEPAD_AXIS_INVALID: SDL_GamepadAxis = -1;
pub const SDL_GamepadAxis_SDL_GAMEPAD_AXIS_LEFTX: SDL_GamepadAxis = 0;
pub const SDL_GamepadAxis_SDL_GAMEPAD_AXIS_LEFTY: SDL_GamepadAxis = 1;
pub const SDL_GamepadAxis_SDL_GAMEPAD_AXIS_RIGHTX: SDL_GamepadAxis = 2;
pub const SDL_GamepadAxis_SDL_GAMEPAD_AXIS_RIGHTY: SDL_GamepadAxis = 3;
pub const SDL_GamepadAxis_SDL_GAMEPAD_AXIS_LEFT_TRIGGER: SDL_GamepadAxis = 4;
pub const SDL_GamepadAxis_SDL_GAMEPAD_AXIS_RIGHT_TRIGGER: SDL_GamepadAxis = 5;
pub const SDL_GamepadAxis_SDL_GAMEPAD_AXIS_COUNT: SDL_GamepadAxis = 6;
#[doc = " The list of axes available on a gamepad\n\n Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to\n SDL_JOYSTICK_AXIS_MAX, and are centered within ~8000 of zero, though\n advanced UI will allow users to set or autodetect the dead zone, which\n varies between gamepads.\n\n Trigger axis values range from 0 (released) to SDL_JOYSTICK_AXIS_MAX (fully\n pressed) when reported by SDL_GetGamepadAxis(). Note that this is not the\n same range that will be reported by the lower-level SDL_GetJoystickAxis().\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_GamepadAxis = ::core::ffi::c_int;
pub const SDL_GamepadBindingType_SDL_GAMEPAD_BINDTYPE_NONE: SDL_GamepadBindingType = 0;
pub const SDL_GamepadBindingType_SDL_GAMEPAD_BINDTYPE_BUTTON: SDL_GamepadBindingType = 1;
pub const SDL_GamepadBindingType_SDL_GAMEPAD_BINDTYPE_AXIS: SDL_GamepadBindingType = 2;
pub const SDL_GamepadBindingType_SDL_GAMEPAD_BINDTYPE_HAT: SDL_GamepadBindingType = 3;
#[doc = " Types of gamepad control bindings.\n\n A gamepad is a collection of bindings that map arbitrary joystick buttons,\n axes and hat switches to specific positions on a generic console-style\n gamepad. This enum is used as part of SDL_GamepadBinding to specify those\n mappings.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_GamepadBindingType = ::core::ffi::c_uint;
#[doc = " A mapping between one joystick input to a gamepad control.\n\n A gamepad has a collection of several bindings, to say, for example, when\n joystick button number 5 is pressed, that should be treated like the\n gamepad's \"start\" button.\n\n SDL has these bindings built-in for many popular controllers, and can add\n more with a simple text string. Those strings are parsed into a collection\n of these structs to make it easier to operate on the data.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadBindings"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GamepadBinding {
    pub input_type: SDL_GamepadBindingType,
    pub input: SDL_GamepadBinding__bindgen_ty_1,
    pub output_type: SDL_GamepadBindingType,
    pub output: SDL_GamepadBinding__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_GamepadBinding__bindgen_ty_1 {
    pub button: ::core::ffi::c_int,
    pub axis: SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_1,
    pub hat: SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_1 {
    pub axis: ::core::ffi::c_int,
    pub axis_min: ::core::ffi::c_int,
    pub axis_max: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_1>() - 12usize];
    ["Alignment of SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_1::axis"]
        [::core::mem::offset_of!(SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_1, axis) - 0usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_1::axis_min"][::core::mem::offset_of!(
        SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_1,
        axis_min
    ) - 4usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_1::axis_max"][::core::mem::offset_of!(
        SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_1,
        axis_max
    ) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_2 {
    pub hat: ::core::ffi::c_int,
    pub hat_mask: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::size_of::<SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Alignment of SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::align_of::<SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_2::hat"]
        [::core::mem::offset_of!(SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_2, hat) - 0usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_2::hat_mask"][::core::mem::offset_of!(
        SDL_GamepadBinding__bindgen_ty_1__bindgen_ty_2,
        hat_mask
    ) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_GamepadBinding__bindgen_ty_1"]
        [::core::mem::size_of::<SDL_GamepadBinding__bindgen_ty_1>() - 12usize];
    ["Alignment of SDL_GamepadBinding__bindgen_ty_1"]
        [::core::mem::align_of::<SDL_GamepadBinding__bindgen_ty_1>() - 4usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_1::button"]
        [::core::mem::offset_of!(SDL_GamepadBinding__bindgen_ty_1, button) - 0usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_1::axis"]
        [::core::mem::offset_of!(SDL_GamepadBinding__bindgen_ty_1, axis) - 0usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_1::hat"]
        [::core::mem::offset_of!(SDL_GamepadBinding__bindgen_ty_1, hat) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_GamepadBinding__bindgen_ty_2 {
    pub button: SDL_GamepadButton,
    pub axis: SDL_GamepadBinding__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_GamepadBinding__bindgen_ty_2__bindgen_ty_1 {
    pub axis: SDL_GamepadAxis,
    pub axis_min: ::core::ffi::c_int,
    pub axis_max: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_GamepadBinding__bindgen_ty_2__bindgen_ty_1"]
        [::core::mem::size_of::<SDL_GamepadBinding__bindgen_ty_2__bindgen_ty_1>() - 12usize];
    ["Alignment of SDL_GamepadBinding__bindgen_ty_2__bindgen_ty_1"]
        [::core::mem::align_of::<SDL_GamepadBinding__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_2__bindgen_ty_1::axis"]
        [::core::mem::offset_of!(SDL_GamepadBinding__bindgen_ty_2__bindgen_ty_1, axis) - 0usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_2__bindgen_ty_1::axis_min"][::core::mem::offset_of!(
        SDL_GamepadBinding__bindgen_ty_2__bindgen_ty_1,
        axis_min
    ) - 4usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_2__bindgen_ty_1::axis_max"][::core::mem::offset_of!(
        SDL_GamepadBinding__bindgen_ty_2__bindgen_ty_1,
        axis_max
    ) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_GamepadBinding__bindgen_ty_2"]
        [::core::mem::size_of::<SDL_GamepadBinding__bindgen_ty_2>() - 12usize];
    ["Alignment of SDL_GamepadBinding__bindgen_ty_2"]
        [::core::mem::align_of::<SDL_GamepadBinding__bindgen_ty_2>() - 4usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_2::button"]
        [::core::mem::offset_of!(SDL_GamepadBinding__bindgen_ty_2, button) - 0usize];
    ["Offset of field: SDL_GamepadBinding__bindgen_ty_2::axis"]
        [::core::mem::offset_of!(SDL_GamepadBinding__bindgen_ty_2, axis) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_GamepadBinding"][::core::mem::size_of::<SDL_GamepadBinding>() - 32usize];
    ["Alignment of SDL_GamepadBinding"][::core::mem::align_of::<SDL_GamepadBinding>() - 4usize];
    ["Offset of field: SDL_GamepadBinding::input_type"]
        [::core::mem::offset_of!(SDL_GamepadBinding, input_type) - 0usize];
    ["Offset of field: SDL_GamepadBinding::input"]
        [::core::mem::offset_of!(SDL_GamepadBinding, input) - 4usize];
    ["Offset of field: SDL_GamepadBinding::output_type"]
        [::core::mem::offset_of!(SDL_GamepadBinding, output_type) - 16usize];
    ["Offset of field: SDL_GamepadBinding::output"]
        [::core::mem::offset_of!(SDL_GamepadBinding, output) - 20usize];
};
unsafe extern "C" {
    #[doc = " Add support for gamepads that SDL is unaware of or change the binding of an\n existing gamepad.\n\n The mapping string has the format \"GUID,name,mapping\", where GUID is the\n string value from SDL_GUIDToString(), name is the human readable string for\n the device and mappings are gamepad mappings to joystick ones. Under\n Windows there is a reserved GUID of \"xinput\" that covers all XInput\n devices. The mapping format for joystick is:\n\n - `bX`: a joystick button, index X\n - `hX.Y`: hat X with value Y\n - `aX`: axis X of the joystick\n\n Buttons can be used as a gamepad axes and vice versa.\n\n If a device with this GUID is already plugged in, SDL will generate an\n SDL_EVENT_GAMEPAD_ADDED event.\n\n This string shows an example of a valid mapping for a gamepad:\n\n ```c\n \"341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7\"\n ```\n\n \\param mapping the mapping string.\n \\returns 1 if a new mapping is added, 0 if an existing mapping is updated,\n          -1 on failure; call SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AddGamepadMappingsFromFile\n \\sa SDL_AddGamepadMappingsFromIO\n \\sa SDL_GetGamepadMapping\n \\sa SDL_GetGamepadMappingForGUID\n \\sa SDL_HINT_GAMECONTROLLERCONFIG\n \\sa SDL_HINT_GAMECONTROLLERCONFIG_FILE\n \\sa SDL_EVENT_GAMEPAD_ADDED"]
    pub fn SDL_AddGamepadMapping(mapping: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Load a set of gamepad mappings from an SDL_IOStream.\n\n You can call this function several times, if needed, to load different\n database files.\n\n If a new mapping is loaded for an already known gamepad GUID, the later\n version will overwrite the one currently loaded.\n\n Any new mappings for already plugged in controllers will generate\n SDL_EVENT_GAMEPAD_ADDED events.\n\n Mappings not belonging to the current platform or with no platform field\n specified will be ignored (i.e. mappings for Linux will be ignored in\n Windows, etc).\n\n This function will load the text database entirely in memory before\n processing it, so take this into consideration if you are in a memory\n constrained environment.\n\n \\param src the data stream for the mappings to be added.\n \\param closeio if true, calls SDL_CloseIO() on `src` before returning, even\n                in the case of an error.\n \\returns the number of mappings added or -1 on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AddGamepadMapping\n \\sa SDL_AddGamepadMappingsFromFile\n \\sa SDL_GetGamepadMapping\n \\sa SDL_GetGamepadMappingForGUID\n \\sa SDL_HINT_GAMECONTROLLERCONFIG\n \\sa SDL_HINT_GAMECONTROLLERCONFIG_FILE\n \\sa SDL_EVENT_GAMEPAD_ADDED"]
    pub fn SDL_AddGamepadMappingsFromIO(
        src: *mut SDL_IOStream,
        closeio: bool,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Load a set of gamepad mappings from a file.\n\n You can call this function several times, if needed, to load different\n database files.\n\n If a new mapping is loaded for an already known gamepad GUID, the later\n version will overwrite the one currently loaded.\n\n Any new mappings for already plugged in controllers will generate\n SDL_EVENT_GAMEPAD_ADDED events.\n\n Mappings not belonging to the current platform or with no platform field\n specified will be ignored (i.e. mappings for Linux will be ignored in\n Windows, etc).\n\n \\param file the mappings file to load.\n \\returns the number of mappings added or -1 on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AddGamepadMapping\n \\sa SDL_AddGamepadMappingsFromIO\n \\sa SDL_GetGamepadMapping\n \\sa SDL_GetGamepadMappingForGUID\n \\sa SDL_HINT_GAMECONTROLLERCONFIG\n \\sa SDL_HINT_GAMECONTROLLERCONFIG_FILE\n \\sa SDL_EVENT_GAMEPAD_ADDED"]
    pub fn SDL_AddGamepadMappingsFromFile(file: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Reinitialize the SDL mapping database to its initial state.\n\n This will generate gamepad events as needed if device mappings change.\n\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ReloadGamepadMappings() -> bool;
}
unsafe extern "C" {
    #[doc = " Get the current gamepad mappings.\n\n \\param count a pointer filled in with the number of mappings returned, can\n              be NULL.\n \\returns an array of the mapping strings, NULL-terminated, or NULL on\n          failure; call SDL_GetError() for more information. This is a\n          single allocation that should be freed with SDL_free() when it is\n          no longer needed.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadMappings(count: *mut ::core::ffi::c_int) -> *mut *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the gamepad mapping string for a given GUID.\n\n \\param guid a structure containing the GUID for which a mapping is desired.\n \\returns a mapping string or NULL on failure; call SDL_GetError() for more\n          information. This should be freed with SDL_free() when it is no\n          longer needed.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoystickGUIDForID\n \\sa SDL_GetJoystickGUID"]
    pub fn SDL_GetGamepadMappingForGUID(guid: SDL_GUID) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the current mapping of a gamepad.\n\n Details about mappings are discussed with SDL_AddGamepadMapping().\n\n \\param gamepad the gamepad you want to get the current mapping for.\n \\returns a string that has the gamepad's mapping or NULL if no mapping is\n          available; call SDL_GetError() for more information. This should\n          be freed with SDL_free() when it is no longer needed.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AddGamepadMapping\n \\sa SDL_GetGamepadMappingForID\n \\sa SDL_GetGamepadMappingForGUID\n \\sa SDL_SetGamepadMapping"]
    pub fn SDL_GetGamepadMapping(gamepad: *mut SDL_Gamepad) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Set the current mapping of a joystick or gamepad.\n\n Details about mappings are discussed with SDL_AddGamepadMapping().\n\n \\param instance_id the joystick instance ID.\n \\param mapping the mapping to use for this device, or NULL to clear the\n                mapping.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AddGamepadMapping\n \\sa SDL_GetGamepadMapping"]
    pub fn SDL_SetGamepadMapping(
        instance_id: SDL_JoystickID,
        mapping: *const ::core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Return whether a gamepad is currently connected.\n\n \\returns true if a gamepad is connected, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepads"]
    pub fn SDL_HasGamepad() -> bool;
}
unsafe extern "C" {
    #[doc = " Get a list of currently connected gamepads.\n\n \\param count a pointer filled in with the number of gamepads returned, may\n              be NULL.\n \\returns a 0 terminated array of joystick instance IDs or NULL on failure;\n          call SDL_GetError() for more information. This should be freed\n          with SDL_free() when it is no longer needed.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_HasGamepad\n \\sa SDL_OpenGamepad"]
    pub fn SDL_GetGamepads(count: *mut ::core::ffi::c_int) -> *mut SDL_JoystickID;
}
unsafe extern "C" {
    #[doc = " Check if the given joystick is supported by the gamepad interface.\n\n \\param instance_id the joystick instance ID.\n \\returns true if the given joystick is supported by the gamepad interface,\n          false if it isn't or it's an invalid index.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetJoysticks\n \\sa SDL_OpenGamepad"]
    pub fn SDL_IsGamepad(instance_id: SDL_JoystickID) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the implementation dependent name of a gamepad.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID.\n \\returns the name of the selected gamepad. If no name can be found, this\n          function returns NULL; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadName\n \\sa SDL_GetGamepads"]
    pub fn SDL_GetGamepadNameForID(instance_id: SDL_JoystickID) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the implementation dependent path of a gamepad.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID.\n \\returns the path of the selected gamepad. If no path can be found, this\n          function returns NULL; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadPath\n \\sa SDL_GetGamepads"]
    pub fn SDL_GetGamepadPathForID(instance_id: SDL_JoystickID) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the player index of a gamepad.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID.\n \\returns the player index of a gamepad, or -1 if it's not available.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadPlayerIndex\n \\sa SDL_GetGamepads"]
    pub fn SDL_GetGamepadPlayerIndexForID(instance_id: SDL_JoystickID) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the implementation-dependent GUID of a gamepad.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID.\n \\returns the GUID of the selected gamepad. If called on an invalid index,\n          this function returns a zero GUID.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GUIDToString\n \\sa SDL_GetGamepads"]
    pub fn SDL_GetGamepadGUIDForID(instance_id: SDL_JoystickID) -> SDL_GUID;
}
unsafe extern "C" {
    #[doc = " Get the USB vendor ID of a gamepad, if available.\n\n This can be called before any gamepads are opened. If the vendor ID isn't\n available this function returns 0.\n\n \\param instance_id the joystick instance ID.\n \\returns the USB vendor ID of the selected gamepad. If called on an invalid\n          index, this function returns zero.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadVendor\n \\sa SDL_GetGamepads"]
    pub fn SDL_GetGamepadVendorForID(instance_id: SDL_JoystickID) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the USB product ID of a gamepad, if available.\n\n This can be called before any gamepads are opened. If the product ID isn't\n available this function returns 0.\n\n \\param instance_id the joystick instance ID.\n \\returns the USB product ID of the selected gamepad. If called on an\n          invalid index, this function returns zero.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadProduct\n \\sa SDL_GetGamepads"]
    pub fn SDL_GetGamepadProductForID(instance_id: SDL_JoystickID) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the product version of a gamepad, if available.\n\n This can be called before any gamepads are opened. If the product version\n isn't available this function returns 0.\n\n \\param instance_id the joystick instance ID.\n \\returns the product version of the selected gamepad. If called on an\n          invalid index, this function returns zero.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadProductVersion\n \\sa SDL_GetGamepads"]
    pub fn SDL_GetGamepadProductVersionForID(instance_id: SDL_JoystickID) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the type of a gamepad.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID.\n \\returns the gamepad type.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadType\n \\sa SDL_GetGamepads\n \\sa SDL_GetRealGamepadTypeForID"]
    pub fn SDL_GetGamepadTypeForID(instance_id: SDL_JoystickID) -> SDL_GamepadType;
}
unsafe extern "C" {
    #[doc = " Get the type of a gamepad, ignoring any mapping override.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID.\n \\returns the gamepad type.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadTypeForID\n \\sa SDL_GetGamepads\n \\sa SDL_GetRealGamepadType"]
    pub fn SDL_GetRealGamepadTypeForID(instance_id: SDL_JoystickID) -> SDL_GamepadType;
}
unsafe extern "C" {
    #[doc = " Get the mapping of a gamepad.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID.\n \\returns the mapping string. Returns NULL if no mapping is available. This\n          should be freed with SDL_free() when it is no longer needed.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepads\n \\sa SDL_GetGamepadMapping"]
    pub fn SDL_GetGamepadMappingForID(instance_id: SDL_JoystickID) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Open a gamepad for use.\n\n \\param instance_id the joystick instance ID.\n \\returns a gamepad identifier or NULL if an error occurred; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CloseGamepad\n \\sa SDL_IsGamepad"]
    pub fn SDL_OpenGamepad(instance_id: SDL_JoystickID) -> *mut SDL_Gamepad;
}
unsafe extern "C" {
    #[doc = " Get the SDL_Gamepad associated with a joystick instance ID, if it has been\n opened.\n\n \\param instance_id the joystick instance ID of the gamepad.\n \\returns an SDL_Gamepad on success or NULL on failure or if it hasn't been\n          opened yet; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadFromID(instance_id: SDL_JoystickID) -> *mut SDL_Gamepad;
}
unsafe extern "C" {
    #[doc = " Get the SDL_Gamepad associated with a player index.\n\n \\param player_index the player index, which different from the instance ID.\n \\returns the SDL_Gamepad associated with a player index.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadPlayerIndex\n \\sa SDL_SetGamepadPlayerIndex"]
    pub fn SDL_GetGamepadFromPlayerIndex(player_index: ::core::ffi::c_int) -> *mut SDL_Gamepad;
}
unsafe extern "C" {
    #[doc = " Get the properties associated with an opened gamepad.\n\n These properties are shared with the underlying joystick object.\n\n The following read-only properties are provided by SDL:\n\n - `SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN`: true if this gamepad has an LED\n   that has adjustable brightness\n - `SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN`: true if this gamepad has an LED\n   that has adjustable color\n - `SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN`: true if this gamepad has a\n   player LED\n - `SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN`: true if this gamepad has\n   left/right rumble\n - `SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this gamepad has\n   simple trigger rumble\n\n \\param gamepad a gamepad identifier previously returned by\n                SDL_OpenGamepad().\n \\returns a valid property ID on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadProperties(gamepad: *mut SDL_Gamepad) -> SDL_PropertiesID;
}
unsafe extern "C" {
    #[doc = " Get the instance ID of an opened gamepad.\n\n \\param gamepad a gamepad identifier previously returned by\n                SDL_OpenGamepad().\n \\returns the instance ID of the specified gamepad on success or 0 on\n          failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadID(gamepad: *mut SDL_Gamepad) -> SDL_JoystickID;
}
unsafe extern "C" {
    #[doc = " Get the implementation-dependent name for an opened gamepad.\n\n \\param gamepad a gamepad identifier previously returned by\n                SDL_OpenGamepad().\n \\returns the implementation dependent name for the gamepad, or NULL if\n          there is no name or the identifier passed is invalid.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadNameForID"]
    pub fn SDL_GetGamepadName(gamepad: *mut SDL_Gamepad) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the implementation-dependent path for an opened gamepad.\n\n \\param gamepad a gamepad identifier previously returned by\n                SDL_OpenGamepad().\n \\returns the implementation dependent path for the gamepad, or NULL if\n          there is no path or the identifier passed is invalid.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadPathForID"]
    pub fn SDL_GetGamepadPath(gamepad: *mut SDL_Gamepad) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the type of an opened gamepad.\n\n \\param gamepad the gamepad object to query.\n \\returns the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not\n          available.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadTypeForID"]
    pub fn SDL_GetGamepadType(gamepad: *mut SDL_Gamepad) -> SDL_GamepadType;
}
unsafe extern "C" {
    #[doc = " Get the type of an opened gamepad, ignoring any mapping override.\n\n \\param gamepad the gamepad object to query.\n \\returns the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not\n          available.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetRealGamepadTypeForID"]
    pub fn SDL_GetRealGamepadType(gamepad: *mut SDL_Gamepad) -> SDL_GamepadType;
}
unsafe extern "C" {
    #[doc = " Get the player index of an opened gamepad.\n\n For XInput gamepads this returns the XInput user index.\n\n \\param gamepad the gamepad object to query.\n \\returns the player index for gamepad, or -1 if it's not available.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetGamepadPlayerIndex"]
    pub fn SDL_GetGamepadPlayerIndex(gamepad: *mut SDL_Gamepad) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Set the player index of an opened gamepad.\n\n \\param gamepad the gamepad object to adjust.\n \\param player_index player index to assign to this gamepad, or -1 to clear\n                     the player index and turn off player LEDs.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadPlayerIndex"]
    pub fn SDL_SetGamepadPlayerIndex(
        gamepad: *mut SDL_Gamepad,
        player_index: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the USB vendor ID of an opened gamepad, if available.\n\n If the vendor ID isn't available this function returns 0.\n\n \\param gamepad the gamepad object to query.\n \\returns the USB vendor ID, or zero if unavailable.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadVendorForID"]
    pub fn SDL_GetGamepadVendor(gamepad: *mut SDL_Gamepad) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the USB product ID of an opened gamepad, if available.\n\n If the product ID isn't available this function returns 0.\n\n \\param gamepad the gamepad object to query.\n \\returns the USB product ID, or zero if unavailable.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadProductForID"]
    pub fn SDL_GetGamepadProduct(gamepad: *mut SDL_Gamepad) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the product version of an opened gamepad, if available.\n\n If the product version isn't available this function returns 0.\n\n \\param gamepad the gamepad object to query.\n \\returns the USB product version, or zero if unavailable.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadProductVersionForID"]
    pub fn SDL_GetGamepadProductVersion(gamepad: *mut SDL_Gamepad) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the firmware version of an opened gamepad, if available.\n\n If the firmware version isn't available this function returns 0.\n\n \\param gamepad the gamepad object to query.\n \\returns the gamepad firmware version, or zero if unavailable.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadFirmwareVersion(gamepad: *mut SDL_Gamepad) -> Uint16;
}
unsafe extern "C" {
    #[doc = " Get the serial number of an opened gamepad, if available.\n\n Returns the serial number of the gamepad, or NULL if it is not available.\n\n \\param gamepad the gamepad object to query.\n \\returns the serial number, or NULL if unavailable.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadSerial(gamepad: *mut SDL_Gamepad) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the Steam Input handle of an opened gamepad, if available.\n\n Returns an InputHandle_t for the gamepad that can be used with Steam Input\n API: https://partner.steamgames.com/doc/api/ISteamInput\n\n \\param gamepad the gamepad object to query.\n \\returns the gamepad handle, or 0 if unavailable.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadSteamHandle(gamepad: *mut SDL_Gamepad) -> Uint64;
}
unsafe extern "C" {
    #[doc = " Get the connection state of a gamepad.\n\n \\param gamepad the gamepad object to query.\n \\returns the connection state on success or\n          `SDL_JOYSTICK_CONNECTION_INVALID` on failure; call SDL_GetError()\n          for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadConnectionState(gamepad: *mut SDL_Gamepad) -> SDL_JoystickConnectionState;
}
unsafe extern "C" {
    #[doc = " Get the battery state of a gamepad.\n\n You should never take a battery status as absolute truth. Batteries\n (especially failing batteries) are delicate hardware, and the values\n reported here are best estimates based on what that hardware reports. It's\n not uncommon for older batteries to lose stored power much faster than it\n reports, or completely drain when reporting it has 20 percent left, etc.\n\n \\param gamepad the gamepad object to query.\n \\param percent a pointer filled in with the percentage of battery life\n                left, between 0 and 100, or NULL to ignore. This will be\n                filled in with -1 we can't determine a value or there is no\n                battery.\n \\returns the current battery state.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadPowerInfo(
        gamepad: *mut SDL_Gamepad,
        percent: *mut ::core::ffi::c_int,
    ) -> SDL_PowerState;
}
unsafe extern "C" {
    #[doc = " Check if a gamepad has been opened and is currently connected.\n\n \\param gamepad a gamepad identifier previously returned by\n                SDL_OpenGamepad().\n \\returns true if the gamepad has been opened and is currently connected, or\n          false if not.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GamepadConnected(gamepad: *mut SDL_Gamepad) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the underlying joystick from a gamepad.\n\n This function will give you a SDL_Joystick object, which allows you to use\n the SDL_Joystick functions with a SDL_Gamepad object. This would be useful\n for getting a joystick's position at any given time, even if it hasn't\n moved (moving it would produce an event, which would have the axis' value).\n\n The pointer returned is owned by the SDL_Gamepad. You should not call\n SDL_CloseJoystick() on it, for example, since doing so will likely cause\n SDL to crash.\n\n \\param gamepad the gamepad object that you want to get a joystick from.\n \\returns an SDL_Joystick object, or NULL on failure; call SDL_GetError()\n          for more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadJoystick(gamepad: *mut SDL_Gamepad) -> *mut SDL_Joystick;
}
unsafe extern "C" {
    #[doc = " Set the state of gamepad event processing.\n\n If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself\n and check the state of the gamepad when you want gamepad information.\n\n \\param enabled whether to process gamepad events or not.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GamepadEventsEnabled\n \\sa SDL_UpdateGamepads"]
    pub fn SDL_SetGamepadEventsEnabled(enabled: bool);
}
unsafe extern "C" {
    #[doc = " Query the state of gamepad event processing.\n\n If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself\n and check the state of the gamepad when you want gamepad information.\n\n \\returns true if gamepad events are being processed, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetGamepadEventsEnabled"]
    pub fn SDL_GamepadEventsEnabled() -> bool;
}
unsafe extern "C" {
    #[doc = " Get the SDL joystick layer bindings for a gamepad.\n\n \\param gamepad a gamepad.\n \\param count a pointer filled in with the number of bindings returned.\n \\returns a NULL terminated array of pointers to bindings or NULL on\n          failure; call SDL_GetError() for more information. This is a\n          single allocation that should be freed with SDL_free() when it is\n          no longer needed.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadBindings(
        gamepad: *mut SDL_Gamepad,
        count: *mut ::core::ffi::c_int,
    ) -> *mut *mut SDL_GamepadBinding;
}
unsafe extern "C" {
    #[doc = " Manually pump gamepad updates if not using the loop.\n\n This function is called automatically by the event loop if events are\n enabled. Under such circumstances, it will not be necessary to call this\n function.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_UpdateGamepads();
}
unsafe extern "C" {
    #[doc = " Convert a string into SDL_GamepadType enum.\n\n This function is called internally to translate SDL_Gamepad mapping strings\n for the underlying joystick device into the consistent SDL_Gamepad mapping.\n You do not normally need to call this function unless you are parsing\n SDL_Gamepad mappings in your own code.\n\n \\param str string representing a SDL_GamepadType type.\n \\returns the SDL_GamepadType enum corresponding to the input string, or\n          `SDL_GAMEPAD_TYPE_UNKNOWN` if no match was found.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadStringForType"]
    pub fn SDL_GetGamepadTypeFromString(str_: *const ::core::ffi::c_char) -> SDL_GamepadType;
}
unsafe extern "C" {
    #[doc = " Convert from an SDL_GamepadType enum to a string.\n\n \\param type an enum value for a given SDL_GamepadType.\n \\returns a string for the given type, or NULL if an invalid type is\n          specified. The string returned is of the format used by\n          SDL_Gamepad mapping strings.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadTypeFromString"]
    pub fn SDL_GetGamepadStringForType(type_: SDL_GamepadType) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Convert a string into SDL_GamepadAxis enum.\n\n This function is called internally to translate SDL_Gamepad mapping strings\n for the underlying joystick device into the consistent SDL_Gamepad mapping.\n You do not normally need to call this function unless you are parsing\n SDL_Gamepad mappings in your own code.\n\n Note specially that \"righttrigger\" and \"lefttrigger\" map to\n `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,\n respectively.\n\n \\param str string representing a SDL_Gamepad axis.\n \\returns the SDL_GamepadAxis enum corresponding to the input string, or\n          `SDL_GAMEPAD_AXIS_INVALID` if no match was found.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadStringForAxis"]
    pub fn SDL_GetGamepadAxisFromString(str_: *const ::core::ffi::c_char) -> SDL_GamepadAxis;
}
unsafe extern "C" {
    #[doc = " Convert from an SDL_GamepadAxis enum to a string.\n\n \\param axis an enum value for a given SDL_GamepadAxis.\n \\returns a string for the given axis, or NULL if an invalid axis is\n          specified. The string returned is of the format used by\n          SDL_Gamepad mapping strings.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadAxisFromString"]
    pub fn SDL_GetGamepadStringForAxis(axis: SDL_GamepadAxis) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Query whether a gamepad has a given axis.\n\n This merely reports whether the gamepad's mapping defined this axis, as\n that is all the information SDL has about the physical device.\n\n \\param gamepad a gamepad.\n \\param axis an axis enum value (an SDL_GamepadAxis value).\n \\returns true if the gamepad has this axis, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GamepadHasButton\n \\sa SDL_GetGamepadAxis"]
    pub fn SDL_GamepadHasAxis(gamepad: *mut SDL_Gamepad, axis: SDL_GamepadAxis) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the current state of an axis control on a gamepad.\n\n The axis indices start at index 0.\n\n For thumbsticks, the state is a value ranging from -32768 (up/left) to\n 32767 (down/right).\n\n Triggers range from 0 when released to 32767 when fully pressed, and never\n return a negative value. Note that this differs from the value reported by\n the lower-level SDL_GetJoystickAxis(), which normally uses the full range.\n\n \\param gamepad a gamepad.\n \\param axis an axis index (one of the SDL_GamepadAxis values).\n \\returns axis state (including 0) on success or 0 (also) on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GamepadHasAxis\n \\sa SDL_GetGamepadButton"]
    pub fn SDL_GetGamepadAxis(gamepad: *mut SDL_Gamepad, axis: SDL_GamepadAxis) -> Sint16;
}
unsafe extern "C" {
    #[doc = " Convert a string into an SDL_GamepadButton enum.\n\n This function is called internally to translate SDL_Gamepad mapping strings\n for the underlying joystick device into the consistent SDL_Gamepad mapping.\n You do not normally need to call this function unless you are parsing\n SDL_Gamepad mappings in your own code.\n\n \\param str string representing a SDL_Gamepad axis.\n \\returns the SDL_GamepadButton enum corresponding to the input string, or\n          `SDL_GAMEPAD_BUTTON_INVALID` if no match was found.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadStringForButton"]
    pub fn SDL_GetGamepadButtonFromString(str_: *const ::core::ffi::c_char) -> SDL_GamepadButton;
}
unsafe extern "C" {
    #[doc = " Convert from an SDL_GamepadButton enum to a string.\n\n \\param button an enum value for a given SDL_GamepadButton.\n \\returns a string for the given button, or NULL if an invalid button is\n          specified. The string returned is of the format used by\n          SDL_Gamepad mapping strings.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadButtonFromString"]
    pub fn SDL_GetGamepadStringForButton(button: SDL_GamepadButton) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Query whether a gamepad has a given button.\n\n This merely reports whether the gamepad's mapping defined this button, as\n that is all the information SDL has about the physical device.\n\n \\param gamepad a gamepad.\n \\param button a button enum value (an SDL_GamepadButton value).\n \\returns true if the gamepad has this button, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GamepadHasAxis"]
    pub fn SDL_GamepadHasButton(gamepad: *mut SDL_Gamepad, button: SDL_GamepadButton) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the current state of a button on a gamepad.\n\n \\param gamepad a gamepad.\n \\param button a button index (one of the SDL_GamepadButton values).\n \\returns true if the button is pressed, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GamepadHasButton\n \\sa SDL_GetGamepadAxis"]
    pub fn SDL_GetGamepadButton(gamepad: *mut SDL_Gamepad, button: SDL_GamepadButton) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the label of a button on a gamepad.\n\n \\param type the type of gamepad to check.\n \\param button a button index (one of the SDL_GamepadButton values).\n \\returns the SDL_GamepadButtonLabel enum corresponding to the button label.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadButtonLabel"]
    pub fn SDL_GetGamepadButtonLabelForType(
        type_: SDL_GamepadType,
        button: SDL_GamepadButton,
    ) -> SDL_GamepadButtonLabel;
}
unsafe extern "C" {
    #[doc = " Get the label of a button on a gamepad.\n\n \\param gamepad a gamepad.\n \\param button a button index (one of the SDL_GamepadButton values).\n \\returns the SDL_GamepadButtonLabel enum corresponding to the button label.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadButtonLabelForType"]
    pub fn SDL_GetGamepadButtonLabel(
        gamepad: *mut SDL_Gamepad,
        button: SDL_GamepadButton,
    ) -> SDL_GamepadButtonLabel;
}
unsafe extern "C" {
    #[doc = " Get the number of touchpads on a gamepad.\n\n \\param gamepad a gamepad.\n \\returns number of touchpads.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetNumGamepadTouchpadFingers"]
    pub fn SDL_GetNumGamepadTouchpads(gamepad: *mut SDL_Gamepad) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of supported simultaneous fingers on a touchpad on a game\n gamepad.\n\n \\param gamepad a gamepad.\n \\param touchpad a touchpad.\n \\returns number of supported simultaneous fingers.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadTouchpadFinger\n \\sa SDL_GetNumGamepadTouchpads"]
    pub fn SDL_GetNumGamepadTouchpadFingers(
        gamepad: *mut SDL_Gamepad,
        touchpad: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current state of a finger on a touchpad on a gamepad.\n\n \\param gamepad a gamepad.\n \\param touchpad a touchpad.\n \\param finger a finger.\n \\param down a pointer filled with true if the finger is down, false\n             otherwise, may be NULL.\n \\param x a pointer filled with the x position, normalized 0 to 1, with the\n          origin in the upper left, may be NULL.\n \\param y a pointer filled with the y position, normalized 0 to 1, with the\n          origin in the upper left, may be NULL.\n \\param pressure a pointer filled with pressure value, may be NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetNumGamepadTouchpadFingers"]
    pub fn SDL_GetGamepadTouchpadFinger(
        gamepad: *mut SDL_Gamepad,
        touchpad: ::core::ffi::c_int,
        finger: ::core::ffi::c_int,
        down: *mut bool,
        x: *mut f32,
        y: *mut f32,
        pressure: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Return whether a gamepad has a particular sensor.\n\n \\param gamepad the gamepad to query.\n \\param type the type of sensor to query.\n \\returns true if the sensor exists, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadSensorData\n \\sa SDL_GetGamepadSensorDataRate\n \\sa SDL_SetGamepadSensorEnabled"]
    pub fn SDL_GamepadHasSensor(gamepad: *mut SDL_Gamepad, type_: SDL_SensorType) -> bool;
}
unsafe extern "C" {
    #[doc = " Set whether data reporting for a gamepad sensor is enabled.\n\n \\param gamepad the gamepad to update.\n \\param type the type of sensor to enable/disable.\n \\param enabled whether data reporting should be enabled.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GamepadHasSensor\n \\sa SDL_GamepadSensorEnabled"]
    pub fn SDL_SetGamepadSensorEnabled(
        gamepad: *mut SDL_Gamepad,
        type_: SDL_SensorType,
        enabled: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Query whether sensor data reporting is enabled for a gamepad.\n\n \\param gamepad the gamepad to query.\n \\param type the type of sensor to query.\n \\returns true if the sensor is enabled, false otherwise.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetGamepadSensorEnabled"]
    pub fn SDL_GamepadSensorEnabled(gamepad: *mut SDL_Gamepad, type_: SDL_SensorType) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the data rate (number of events per second) of a gamepad sensor.\n\n \\param gamepad the gamepad to query.\n \\param type the type of sensor to query.\n \\returns the data rate, or 0.0f if the data rate is not available.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadSensorDataRate(gamepad: *mut SDL_Gamepad, type_: SDL_SensorType) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the current state of a gamepad sensor.\n\n The number of values and interpretation of the data is sensor dependent.\n See SDL_sensor.h for the details for each type of sensor.\n\n \\param gamepad the gamepad to query.\n \\param type the type of sensor to query.\n \\param data a pointer filled with the current sensor state.\n \\param num_values the number of values to write to data.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetGamepadSensorData(
        gamepad: *mut SDL_Gamepad,
        type_: SDL_SensorType,
        data: *mut f32,
        num_values: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Start a rumble effect on a gamepad.\n\n Each call to this function cancels any previous rumble effect, and calling\n it with 0 intensity stops any rumbling.\n\n This function requires you to process SDL events or call\n SDL_UpdateJoysticks() to update rumble state.\n\n \\param gamepad the gamepad to vibrate.\n \\param low_frequency_rumble the intensity of the low frequency (left)\n                             rumble motor, from 0 to 0xFFFF.\n \\param high_frequency_rumble the intensity of the high frequency (right)\n                              rumble motor, from 0 to 0xFFFF.\n \\param duration_ms the duration of the rumble effect, in milliseconds.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_RumbleGamepad(
        gamepad: *mut SDL_Gamepad,
        low_frequency_rumble: Uint16,
        high_frequency_rumble: Uint16,
        duration_ms: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Start a rumble effect in the gamepad's triggers.\n\n Each call to this function cancels any previous trigger rumble effect, and\n calling it with 0 intensity stops any rumbling.\n\n Note that this is rumbling of the _triggers_ and not the gamepad as a\n whole. This is currently only supported on Xbox One gamepads. If you want\n the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.\n\n This function requires you to process SDL events or call\n SDL_UpdateJoysticks() to update rumble state.\n\n \\param gamepad the gamepad to vibrate.\n \\param left_rumble the intensity of the left trigger rumble motor, from 0\n                    to 0xFFFF.\n \\param right_rumble the intensity of the right trigger rumble motor, from 0\n                     to 0xFFFF.\n \\param duration_ms the duration of the rumble effect, in milliseconds.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_RumbleGamepad"]
    pub fn SDL_RumbleGamepadTriggers(
        gamepad: *mut SDL_Gamepad,
        left_rumble: Uint16,
        right_rumble: Uint16,
        duration_ms: Uint32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Update a gamepad's LED color.\n\n An example of a joystick LED is the light on the back of a PlayStation 4's\n DualShock 4 controller.\n\n For gamepads with a single color LED, the maximum of the RGB values will be\n used as the LED brightness.\n\n \\param gamepad the gamepad to update.\n \\param red the intensity of the red LED.\n \\param green the intensity of the green LED.\n \\param blue the intensity of the blue LED.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetGamepadLED(
        gamepad: *mut SDL_Gamepad,
        red: Uint8,
        green: Uint8,
        blue: Uint8,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Send a gamepad specific effect packet.\n\n \\param gamepad the gamepad to affect.\n \\param data the data to send to the gamepad.\n \\param size the size of the data to send to the gamepad.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SendGamepadEffect(
        gamepad: *mut SDL_Gamepad,
        data: *const ::core::ffi::c_void,
        size: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Close a gamepad previously opened with SDL_OpenGamepad().\n\n \\param gamepad a gamepad identifier previously returned by\n                SDL_OpenGamepad().\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_OpenGamepad"]
    pub fn SDL_CloseGamepad(gamepad: *mut SDL_Gamepad);
}
unsafe extern "C" {
    #[doc = " Return the sfSymbolsName for a given button on a gamepad on Apple\n platforms.\n\n \\param gamepad the gamepad to query.\n \\param button a button on the gamepad.\n \\returns the sfSymbolsName or NULL if the name can't be found.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadAppleSFSymbolsNameForAxis"]
    pub fn SDL_GetGamepadAppleSFSymbolsNameForButton(
        gamepad: *mut SDL_Gamepad,
        button: SDL_GamepadButton,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.\n\n \\param gamepad the gamepad to query.\n \\param axis an axis on the gamepad.\n \\returns the sfSymbolsName or NULL if the name can't be found.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGamepadAppleSFSymbolsNameForButton"]
    pub fn SDL_GetGamepadAppleSFSymbolsNameForAxis(
        gamepad: *mut SDL_Gamepad,
        axis: SDL_GamepadAxis,
    ) -> *const ::core::ffi::c_char;
}
pub const SDL_Scancode_SDL_SCANCODE_UNKNOWN: SDL_Scancode = 0;
pub const SDL_Scancode_SDL_SCANCODE_A: SDL_Scancode = 4;
pub const SDL_Scancode_SDL_SCANCODE_B: SDL_Scancode = 5;
pub const SDL_Scancode_SDL_SCANCODE_C: SDL_Scancode = 6;
pub const SDL_Scancode_SDL_SCANCODE_D: SDL_Scancode = 7;
pub const SDL_Scancode_SDL_SCANCODE_E: SDL_Scancode = 8;
pub const SDL_Scancode_SDL_SCANCODE_F: SDL_Scancode = 9;
pub const SDL_Scancode_SDL_SCANCODE_G: SDL_Scancode = 10;
pub const SDL_Scancode_SDL_SCANCODE_H: SDL_Scancode = 11;
pub const SDL_Scancode_SDL_SCANCODE_I: SDL_Scancode = 12;
pub const SDL_Scancode_SDL_SCANCODE_J: SDL_Scancode = 13;
pub const SDL_Scancode_SDL_SCANCODE_K: SDL_Scancode = 14;
pub const SDL_Scancode_SDL_SCANCODE_L: SDL_Scancode = 15;
pub const SDL_Scancode_SDL_SCANCODE_M: SDL_Scancode = 16;
pub const SDL_Scancode_SDL_SCANCODE_N: SDL_Scancode = 17;
pub const SDL_Scancode_SDL_SCANCODE_O: SDL_Scancode = 18;
pub const SDL_Scancode_SDL_SCANCODE_P: SDL_Scancode = 19;
pub const SDL_Scancode_SDL_SCANCODE_Q: SDL_Scancode = 20;
pub const SDL_Scancode_SDL_SCANCODE_R: SDL_Scancode = 21;
pub const SDL_Scancode_SDL_SCANCODE_S: SDL_Scancode = 22;
pub const SDL_Scancode_SDL_SCANCODE_T: SDL_Scancode = 23;
pub const SDL_Scancode_SDL_SCANCODE_U: SDL_Scancode = 24;
pub const SDL_Scancode_SDL_SCANCODE_V: SDL_Scancode = 25;
pub const SDL_Scancode_SDL_SCANCODE_W: SDL_Scancode = 26;
pub const SDL_Scancode_SDL_SCANCODE_X: SDL_Scancode = 27;
pub const SDL_Scancode_SDL_SCANCODE_Y: SDL_Scancode = 28;
pub const SDL_Scancode_SDL_SCANCODE_Z: SDL_Scancode = 29;
pub const SDL_Scancode_SDL_SCANCODE_1: SDL_Scancode = 30;
pub const SDL_Scancode_SDL_SCANCODE_2: SDL_Scancode = 31;
pub const SDL_Scancode_SDL_SCANCODE_3: SDL_Scancode = 32;
pub const SDL_Scancode_SDL_SCANCODE_4: SDL_Scancode = 33;
pub const SDL_Scancode_SDL_SCANCODE_5: SDL_Scancode = 34;
pub const SDL_Scancode_SDL_SCANCODE_6: SDL_Scancode = 35;
pub const SDL_Scancode_SDL_SCANCODE_7: SDL_Scancode = 36;
pub const SDL_Scancode_SDL_SCANCODE_8: SDL_Scancode = 37;
pub const SDL_Scancode_SDL_SCANCODE_9: SDL_Scancode = 38;
pub const SDL_Scancode_SDL_SCANCODE_0: SDL_Scancode = 39;
pub const SDL_Scancode_SDL_SCANCODE_RETURN: SDL_Scancode = 40;
pub const SDL_Scancode_SDL_SCANCODE_ESCAPE: SDL_Scancode = 41;
pub const SDL_Scancode_SDL_SCANCODE_BACKSPACE: SDL_Scancode = 42;
pub const SDL_Scancode_SDL_SCANCODE_TAB: SDL_Scancode = 43;
pub const SDL_Scancode_SDL_SCANCODE_SPACE: SDL_Scancode = 44;
pub const SDL_Scancode_SDL_SCANCODE_MINUS: SDL_Scancode = 45;
pub const SDL_Scancode_SDL_SCANCODE_EQUALS: SDL_Scancode = 46;
pub const SDL_Scancode_SDL_SCANCODE_LEFTBRACKET: SDL_Scancode = 47;
pub const SDL_Scancode_SDL_SCANCODE_RIGHTBRACKET: SDL_Scancode = 48;
#[doc = "< Located at the lower left of the return\n   key on ISO keyboards and at the right end\n   of the QWERTY row on ANSI keyboards.\n   Produces REVERSE SOLIDUS (backslash) and\n   VERTICAL LINE in a US layout, REVERSE\n   SOLIDUS and VERTICAL LINE in a UK Mac\n   layout, NUMBER SIGN and TILDE in a UK\n   Windows layout, DOLLAR SIGN and POUND SIGN\n   in a Swiss German layout, NUMBER SIGN and\n   APOSTROPHE in a German layout, GRAVE\n   ACCENT and POUND SIGN in a French Mac\n   layout, and ASTERISK and MICRO SIGN in a\n   French Windows layout."]
pub const SDL_Scancode_SDL_SCANCODE_BACKSLASH: SDL_Scancode = 49;
#[doc = "< ISO USB keyboards actually use this code\n   instead of 49 for the same key, but all\n   OSes I've seen treat the two codes\n   identically. So, as an implementor, unless\n   your keyboard generates both of those\n   codes and your OS treats them differently,\n   you should generate SDL_SCANCODE_BACKSLASH\n   instead of this code. As a user, you\n   should not rely on this code because SDL\n   will never generate it with most (all?)\n   keyboards."]
pub const SDL_Scancode_SDL_SCANCODE_NONUSHASH: SDL_Scancode = 50;
pub const SDL_Scancode_SDL_SCANCODE_SEMICOLON: SDL_Scancode = 51;
pub const SDL_Scancode_SDL_SCANCODE_APOSTROPHE: SDL_Scancode = 52;
#[doc = "< Located in the top left corner (on both ANSI\n   and ISO keyboards). Produces GRAVE ACCENT and\n   TILDE in a US Windows layout and in US and UK\n   Mac layouts on ANSI keyboards, GRAVE ACCENT\n   and NOT SIGN in a UK Windows layout, SECTION\n   SIGN and PLUS-MINUS SIGN in US and UK Mac\n   layouts on ISO keyboards, SECTION SIGN and\n   DEGREE SIGN in a Swiss German layout (Mac:\n   only on ISO keyboards), CIRCUMFLEX ACCENT and\n   DEGREE SIGN in a German layout (Mac: only on\n   ISO keyboards), SUPERSCRIPT TWO and TILDE in a\n   French Windows layout, COMMERCIAL AT and\n   NUMBER SIGN in a French Mac layout on ISO\n   keyboards, and LESS-THAN SIGN and GREATER-THAN\n   SIGN in a Swiss German, German, or French Mac\n   layout on ANSI keyboards."]
pub const SDL_Scancode_SDL_SCANCODE_GRAVE: SDL_Scancode = 53;
pub const SDL_Scancode_SDL_SCANCODE_COMMA: SDL_Scancode = 54;
pub const SDL_Scancode_SDL_SCANCODE_PERIOD: SDL_Scancode = 55;
pub const SDL_Scancode_SDL_SCANCODE_SLASH: SDL_Scancode = 56;
pub const SDL_Scancode_SDL_SCANCODE_CAPSLOCK: SDL_Scancode = 57;
pub const SDL_Scancode_SDL_SCANCODE_F1: SDL_Scancode = 58;
pub const SDL_Scancode_SDL_SCANCODE_F2: SDL_Scancode = 59;
pub const SDL_Scancode_SDL_SCANCODE_F3: SDL_Scancode = 60;
pub const SDL_Scancode_SDL_SCANCODE_F4: SDL_Scancode = 61;
pub const SDL_Scancode_SDL_SCANCODE_F5: SDL_Scancode = 62;
pub const SDL_Scancode_SDL_SCANCODE_F6: SDL_Scancode = 63;
pub const SDL_Scancode_SDL_SCANCODE_F7: SDL_Scancode = 64;
pub const SDL_Scancode_SDL_SCANCODE_F8: SDL_Scancode = 65;
pub const SDL_Scancode_SDL_SCANCODE_F9: SDL_Scancode = 66;
pub const SDL_Scancode_SDL_SCANCODE_F10: SDL_Scancode = 67;
pub const SDL_Scancode_SDL_SCANCODE_F11: SDL_Scancode = 68;
pub const SDL_Scancode_SDL_SCANCODE_F12: SDL_Scancode = 69;
pub const SDL_Scancode_SDL_SCANCODE_PRINTSCREEN: SDL_Scancode = 70;
pub const SDL_Scancode_SDL_SCANCODE_SCROLLLOCK: SDL_Scancode = 71;
pub const SDL_Scancode_SDL_SCANCODE_PAUSE: SDL_Scancode = 72;
#[doc = "< insert on PC, help on some Mac keyboards (but\ndoes send code 73, not 117)"]
pub const SDL_Scancode_SDL_SCANCODE_INSERT: SDL_Scancode = 73;
pub const SDL_Scancode_SDL_SCANCODE_HOME: SDL_Scancode = 74;
pub const SDL_Scancode_SDL_SCANCODE_PAGEUP: SDL_Scancode = 75;
pub const SDL_Scancode_SDL_SCANCODE_DELETE: SDL_Scancode = 76;
pub const SDL_Scancode_SDL_SCANCODE_END: SDL_Scancode = 77;
pub const SDL_Scancode_SDL_SCANCODE_PAGEDOWN: SDL_Scancode = 78;
pub const SDL_Scancode_SDL_SCANCODE_RIGHT: SDL_Scancode = 79;
pub const SDL_Scancode_SDL_SCANCODE_LEFT: SDL_Scancode = 80;
pub const SDL_Scancode_SDL_SCANCODE_DOWN: SDL_Scancode = 81;
pub const SDL_Scancode_SDL_SCANCODE_UP: SDL_Scancode = 82;
#[doc = "< num lock on PC, clear on Mac keyboards"]
pub const SDL_Scancode_SDL_SCANCODE_NUMLOCKCLEAR: SDL_Scancode = 83;
pub const SDL_Scancode_SDL_SCANCODE_KP_DIVIDE: SDL_Scancode = 84;
pub const SDL_Scancode_SDL_SCANCODE_KP_MULTIPLY: SDL_Scancode = 85;
pub const SDL_Scancode_SDL_SCANCODE_KP_MINUS: SDL_Scancode = 86;
pub const SDL_Scancode_SDL_SCANCODE_KP_PLUS: SDL_Scancode = 87;
pub const SDL_Scancode_SDL_SCANCODE_KP_ENTER: SDL_Scancode = 88;
pub const SDL_Scancode_SDL_SCANCODE_KP_1: SDL_Scancode = 89;
pub const SDL_Scancode_SDL_SCANCODE_KP_2: SDL_Scancode = 90;
pub const SDL_Scancode_SDL_SCANCODE_KP_3: SDL_Scancode = 91;
pub const SDL_Scancode_SDL_SCANCODE_KP_4: SDL_Scancode = 92;
pub const SDL_Scancode_SDL_SCANCODE_KP_5: SDL_Scancode = 93;
pub const SDL_Scancode_SDL_SCANCODE_KP_6: SDL_Scancode = 94;
pub const SDL_Scancode_SDL_SCANCODE_KP_7: SDL_Scancode = 95;
pub const SDL_Scancode_SDL_SCANCODE_KP_8: SDL_Scancode = 96;
pub const SDL_Scancode_SDL_SCANCODE_KP_9: SDL_Scancode = 97;
pub const SDL_Scancode_SDL_SCANCODE_KP_0: SDL_Scancode = 98;
pub const SDL_Scancode_SDL_SCANCODE_KP_PERIOD: SDL_Scancode = 99;
#[doc = "< This is the additional key that ISO\n   keyboards have over ANSI ones,\n   located between left shift and Y.\n   Produces GRAVE ACCENT and TILDE in a\n   US or UK Mac layout, REVERSE SOLIDUS\n   (backslash) and VERTICAL LINE in a\n   US or UK Windows layout, and\n   LESS-THAN SIGN and GREATER-THAN SIGN\n   in a Swiss German, German, or French\n   layout."]
pub const SDL_Scancode_SDL_SCANCODE_NONUSBACKSLASH: SDL_Scancode = 100;
#[doc = "< windows contextual menu, compose"]
pub const SDL_Scancode_SDL_SCANCODE_APPLICATION: SDL_Scancode = 101;
#[doc = "< The USB document says this is a status flag,\n   not a physical key - but some Mac keyboards\n   do have a power key."]
pub const SDL_Scancode_SDL_SCANCODE_POWER: SDL_Scancode = 102;
pub const SDL_Scancode_SDL_SCANCODE_KP_EQUALS: SDL_Scancode = 103;
pub const SDL_Scancode_SDL_SCANCODE_F13: SDL_Scancode = 104;
pub const SDL_Scancode_SDL_SCANCODE_F14: SDL_Scancode = 105;
pub const SDL_Scancode_SDL_SCANCODE_F15: SDL_Scancode = 106;
pub const SDL_Scancode_SDL_SCANCODE_F16: SDL_Scancode = 107;
pub const SDL_Scancode_SDL_SCANCODE_F17: SDL_Scancode = 108;
pub const SDL_Scancode_SDL_SCANCODE_F18: SDL_Scancode = 109;
pub const SDL_Scancode_SDL_SCANCODE_F19: SDL_Scancode = 110;
pub const SDL_Scancode_SDL_SCANCODE_F20: SDL_Scancode = 111;
pub const SDL_Scancode_SDL_SCANCODE_F21: SDL_Scancode = 112;
pub const SDL_Scancode_SDL_SCANCODE_F22: SDL_Scancode = 113;
pub const SDL_Scancode_SDL_SCANCODE_F23: SDL_Scancode = 114;
pub const SDL_Scancode_SDL_SCANCODE_F24: SDL_Scancode = 115;
pub const SDL_Scancode_SDL_SCANCODE_EXECUTE: SDL_Scancode = 116;
#[doc = "< AL Integrated Help Center"]
pub const SDL_Scancode_SDL_SCANCODE_HELP: SDL_Scancode = 117;
#[doc = "< Menu (show menu)"]
pub const SDL_Scancode_SDL_SCANCODE_MENU: SDL_Scancode = 118;
pub const SDL_Scancode_SDL_SCANCODE_SELECT: SDL_Scancode = 119;
#[doc = "< AC Stop"]
pub const SDL_Scancode_SDL_SCANCODE_STOP: SDL_Scancode = 120;
#[doc = "< AC Redo/Repeat"]
pub const SDL_Scancode_SDL_SCANCODE_AGAIN: SDL_Scancode = 121;
#[doc = "< AC Undo"]
pub const SDL_Scancode_SDL_SCANCODE_UNDO: SDL_Scancode = 122;
#[doc = "< AC Cut"]
pub const SDL_Scancode_SDL_SCANCODE_CUT: SDL_Scancode = 123;
#[doc = "< AC Copy"]
pub const SDL_Scancode_SDL_SCANCODE_COPY: SDL_Scancode = 124;
#[doc = "< AC Paste"]
pub const SDL_Scancode_SDL_SCANCODE_PASTE: SDL_Scancode = 125;
#[doc = "< AC Find"]
pub const SDL_Scancode_SDL_SCANCODE_FIND: SDL_Scancode = 126;
pub const SDL_Scancode_SDL_SCANCODE_MUTE: SDL_Scancode = 127;
pub const SDL_Scancode_SDL_SCANCODE_VOLUMEUP: SDL_Scancode = 128;
pub const SDL_Scancode_SDL_SCANCODE_VOLUMEDOWN: SDL_Scancode = 129;
pub const SDL_Scancode_SDL_SCANCODE_KP_COMMA: SDL_Scancode = 133;
pub const SDL_Scancode_SDL_SCANCODE_KP_EQUALSAS400: SDL_Scancode = 134;
#[doc = "< used on Asian keyboards, see\nfootnotes in USB doc"]
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL1: SDL_Scancode = 135;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL2: SDL_Scancode = 136;
#[doc = "< Yen"]
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL3: SDL_Scancode = 137;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL4: SDL_Scancode = 138;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL5: SDL_Scancode = 139;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL6: SDL_Scancode = 140;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL7: SDL_Scancode = 141;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL8: SDL_Scancode = 142;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL9: SDL_Scancode = 143;
#[doc = "< Hangul/English toggle"]
pub const SDL_Scancode_SDL_SCANCODE_LANG1: SDL_Scancode = 144;
#[doc = "< Hanja conversion"]
pub const SDL_Scancode_SDL_SCANCODE_LANG2: SDL_Scancode = 145;
#[doc = "< Katakana"]
pub const SDL_Scancode_SDL_SCANCODE_LANG3: SDL_Scancode = 146;
#[doc = "< Hiragana"]
pub const SDL_Scancode_SDL_SCANCODE_LANG4: SDL_Scancode = 147;
#[doc = "< Zenkaku/Hankaku"]
pub const SDL_Scancode_SDL_SCANCODE_LANG5: SDL_Scancode = 148;
#[doc = "< reserved"]
pub const SDL_Scancode_SDL_SCANCODE_LANG6: SDL_Scancode = 149;
#[doc = "< reserved"]
pub const SDL_Scancode_SDL_SCANCODE_LANG7: SDL_Scancode = 150;
#[doc = "< reserved"]
pub const SDL_Scancode_SDL_SCANCODE_LANG8: SDL_Scancode = 151;
#[doc = "< reserved"]
pub const SDL_Scancode_SDL_SCANCODE_LANG9: SDL_Scancode = 152;
#[doc = "< Erase-Eaze"]
pub const SDL_Scancode_SDL_SCANCODE_ALTERASE: SDL_Scancode = 153;
pub const SDL_Scancode_SDL_SCANCODE_SYSREQ: SDL_Scancode = 154;
#[doc = "< AC Cancel"]
pub const SDL_Scancode_SDL_SCANCODE_CANCEL: SDL_Scancode = 155;
pub const SDL_Scancode_SDL_SCANCODE_CLEAR: SDL_Scancode = 156;
pub const SDL_Scancode_SDL_SCANCODE_PRIOR: SDL_Scancode = 157;
pub const SDL_Scancode_SDL_SCANCODE_RETURN2: SDL_Scancode = 158;
pub const SDL_Scancode_SDL_SCANCODE_SEPARATOR: SDL_Scancode = 159;
pub const SDL_Scancode_SDL_SCANCODE_OUT: SDL_Scancode = 160;
pub const SDL_Scancode_SDL_SCANCODE_OPER: SDL_Scancode = 161;
pub const SDL_Scancode_SDL_SCANCODE_CLEARAGAIN: SDL_Scancode = 162;
pub const SDL_Scancode_SDL_SCANCODE_CRSEL: SDL_Scancode = 163;
pub const SDL_Scancode_SDL_SCANCODE_EXSEL: SDL_Scancode = 164;
pub const SDL_Scancode_SDL_SCANCODE_KP_00: SDL_Scancode = 176;
pub const SDL_Scancode_SDL_SCANCODE_KP_000: SDL_Scancode = 177;
pub const SDL_Scancode_SDL_SCANCODE_THOUSANDSSEPARATOR: SDL_Scancode = 178;
pub const SDL_Scancode_SDL_SCANCODE_DECIMALSEPARATOR: SDL_Scancode = 179;
pub const SDL_Scancode_SDL_SCANCODE_CURRENCYUNIT: SDL_Scancode = 180;
pub const SDL_Scancode_SDL_SCANCODE_CURRENCYSUBUNIT: SDL_Scancode = 181;
pub const SDL_Scancode_SDL_SCANCODE_KP_LEFTPAREN: SDL_Scancode = 182;
pub const SDL_Scancode_SDL_SCANCODE_KP_RIGHTPAREN: SDL_Scancode = 183;
pub const SDL_Scancode_SDL_SCANCODE_KP_LEFTBRACE: SDL_Scancode = 184;
pub const SDL_Scancode_SDL_SCANCODE_KP_RIGHTBRACE: SDL_Scancode = 185;
pub const SDL_Scancode_SDL_SCANCODE_KP_TAB: SDL_Scancode = 186;
pub const SDL_Scancode_SDL_SCANCODE_KP_BACKSPACE: SDL_Scancode = 187;
pub const SDL_Scancode_SDL_SCANCODE_KP_A: SDL_Scancode = 188;
pub const SDL_Scancode_SDL_SCANCODE_KP_B: SDL_Scancode = 189;
pub const SDL_Scancode_SDL_SCANCODE_KP_C: SDL_Scancode = 190;
pub const SDL_Scancode_SDL_SCANCODE_KP_D: SDL_Scancode = 191;
pub const SDL_Scancode_SDL_SCANCODE_KP_E: SDL_Scancode = 192;
pub const SDL_Scancode_SDL_SCANCODE_KP_F: SDL_Scancode = 193;
pub const SDL_Scancode_SDL_SCANCODE_KP_XOR: SDL_Scancode = 194;
pub const SDL_Scancode_SDL_SCANCODE_KP_POWER: SDL_Scancode = 195;
pub const SDL_Scancode_SDL_SCANCODE_KP_PERCENT: SDL_Scancode = 196;
pub const SDL_Scancode_SDL_SCANCODE_KP_LESS: SDL_Scancode = 197;
pub const SDL_Scancode_SDL_SCANCODE_KP_GREATER: SDL_Scancode = 198;
pub const SDL_Scancode_SDL_SCANCODE_KP_AMPERSAND: SDL_Scancode = 199;
pub const SDL_Scancode_SDL_SCANCODE_KP_DBLAMPERSAND: SDL_Scancode = 200;
pub const SDL_Scancode_SDL_SCANCODE_KP_VERTICALBAR: SDL_Scancode = 201;
pub const SDL_Scancode_SDL_SCANCODE_KP_DBLVERTICALBAR: SDL_Scancode = 202;
pub const SDL_Scancode_SDL_SCANCODE_KP_COLON: SDL_Scancode = 203;
pub const SDL_Scancode_SDL_SCANCODE_KP_HASH: SDL_Scancode = 204;
pub const SDL_Scancode_SDL_SCANCODE_KP_SPACE: SDL_Scancode = 205;
pub const SDL_Scancode_SDL_SCANCODE_KP_AT: SDL_Scancode = 206;
pub const SDL_Scancode_SDL_SCANCODE_KP_EXCLAM: SDL_Scancode = 207;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMSTORE: SDL_Scancode = 208;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMRECALL: SDL_Scancode = 209;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMCLEAR: SDL_Scancode = 210;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMADD: SDL_Scancode = 211;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMSUBTRACT: SDL_Scancode = 212;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMMULTIPLY: SDL_Scancode = 213;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMDIVIDE: SDL_Scancode = 214;
pub const SDL_Scancode_SDL_SCANCODE_KP_PLUSMINUS: SDL_Scancode = 215;
pub const SDL_Scancode_SDL_SCANCODE_KP_CLEAR: SDL_Scancode = 216;
pub const SDL_Scancode_SDL_SCANCODE_KP_CLEARENTRY: SDL_Scancode = 217;
pub const SDL_Scancode_SDL_SCANCODE_KP_BINARY: SDL_Scancode = 218;
pub const SDL_Scancode_SDL_SCANCODE_KP_OCTAL: SDL_Scancode = 219;
pub const SDL_Scancode_SDL_SCANCODE_KP_DECIMAL: SDL_Scancode = 220;
pub const SDL_Scancode_SDL_SCANCODE_KP_HEXADECIMAL: SDL_Scancode = 221;
pub const SDL_Scancode_SDL_SCANCODE_LCTRL: SDL_Scancode = 224;
pub const SDL_Scancode_SDL_SCANCODE_LSHIFT: SDL_Scancode = 225;
#[doc = "< alt, option"]
pub const SDL_Scancode_SDL_SCANCODE_LALT: SDL_Scancode = 226;
#[doc = "< windows, command (apple), meta"]
pub const SDL_Scancode_SDL_SCANCODE_LGUI: SDL_Scancode = 227;
pub const SDL_Scancode_SDL_SCANCODE_RCTRL: SDL_Scancode = 228;
pub const SDL_Scancode_SDL_SCANCODE_RSHIFT: SDL_Scancode = 229;
#[doc = "< alt gr, option"]
pub const SDL_Scancode_SDL_SCANCODE_RALT: SDL_Scancode = 230;
#[doc = "< windows, command (apple), meta"]
pub const SDL_Scancode_SDL_SCANCODE_RGUI: SDL_Scancode = 231;
#[doc = "< I'm not sure if this is really not covered\n   by any of the above, but since there's a\n   special SDL_KMOD_MODE for it I'm adding it here"]
pub const SDL_Scancode_SDL_SCANCODE_MODE: SDL_Scancode = 257;
#[doc = "< Sleep"]
pub const SDL_Scancode_SDL_SCANCODE_SLEEP: SDL_Scancode = 258;
#[doc = "< Wake"]
pub const SDL_Scancode_SDL_SCANCODE_WAKE: SDL_Scancode = 259;
#[doc = "< Channel Increment"]
pub const SDL_Scancode_SDL_SCANCODE_CHANNEL_INCREMENT: SDL_Scancode = 260;
#[doc = "< Channel Decrement"]
pub const SDL_Scancode_SDL_SCANCODE_CHANNEL_DECREMENT: SDL_Scancode = 261;
#[doc = "< Play"]
pub const SDL_Scancode_SDL_SCANCODE_MEDIA_PLAY: SDL_Scancode = 262;
#[doc = "< Pause"]
pub const SDL_Scancode_SDL_SCANCODE_MEDIA_PAUSE: SDL_Scancode = 263;
#[doc = "< Record"]
pub const SDL_Scancode_SDL_SCANCODE_MEDIA_RECORD: SDL_Scancode = 264;
#[doc = "< Fast Forward"]
pub const SDL_Scancode_SDL_SCANCODE_MEDIA_FAST_FORWARD: SDL_Scancode = 265;
#[doc = "< Rewind"]
pub const SDL_Scancode_SDL_SCANCODE_MEDIA_REWIND: SDL_Scancode = 266;
#[doc = "< Next Track"]
pub const SDL_Scancode_SDL_SCANCODE_MEDIA_NEXT_TRACK: SDL_Scancode = 267;
#[doc = "< Previous Track"]
pub const SDL_Scancode_SDL_SCANCODE_MEDIA_PREVIOUS_TRACK: SDL_Scancode = 268;
#[doc = "< Stop"]
pub const SDL_Scancode_SDL_SCANCODE_MEDIA_STOP: SDL_Scancode = 269;
#[doc = "< Eject"]
pub const SDL_Scancode_SDL_SCANCODE_MEDIA_EJECT: SDL_Scancode = 270;
#[doc = "< Play / Pause"]
pub const SDL_Scancode_SDL_SCANCODE_MEDIA_PLAY_PAUSE: SDL_Scancode = 271;
pub const SDL_Scancode_SDL_SCANCODE_MEDIA_SELECT: SDL_Scancode = 272;
#[doc = "< AC New"]
pub const SDL_Scancode_SDL_SCANCODE_AC_NEW: SDL_Scancode = 273;
#[doc = "< AC Open"]
pub const SDL_Scancode_SDL_SCANCODE_AC_OPEN: SDL_Scancode = 274;
#[doc = "< AC Close"]
pub const SDL_Scancode_SDL_SCANCODE_AC_CLOSE: SDL_Scancode = 275;
#[doc = "< AC Exit"]
pub const SDL_Scancode_SDL_SCANCODE_AC_EXIT: SDL_Scancode = 276;
#[doc = "< AC Save"]
pub const SDL_Scancode_SDL_SCANCODE_AC_SAVE: SDL_Scancode = 277;
#[doc = "< AC Print"]
pub const SDL_Scancode_SDL_SCANCODE_AC_PRINT: SDL_Scancode = 278;
#[doc = "< AC Properties"]
pub const SDL_Scancode_SDL_SCANCODE_AC_PROPERTIES: SDL_Scancode = 279;
#[doc = "< AC Search"]
pub const SDL_Scancode_SDL_SCANCODE_AC_SEARCH: SDL_Scancode = 280;
#[doc = "< AC Home"]
pub const SDL_Scancode_SDL_SCANCODE_AC_HOME: SDL_Scancode = 281;
#[doc = "< AC Back"]
pub const SDL_Scancode_SDL_SCANCODE_AC_BACK: SDL_Scancode = 282;
#[doc = "< AC Forward"]
pub const SDL_Scancode_SDL_SCANCODE_AC_FORWARD: SDL_Scancode = 283;
#[doc = "< AC Stop"]
pub const SDL_Scancode_SDL_SCANCODE_AC_STOP: SDL_Scancode = 284;
#[doc = "< AC Refresh"]
pub const SDL_Scancode_SDL_SCANCODE_AC_REFRESH: SDL_Scancode = 285;
#[doc = "< AC Bookmarks"]
pub const SDL_Scancode_SDL_SCANCODE_AC_BOOKMARKS: SDL_Scancode = 286;
#[doc = "< Usually situated below the display on phones and\nused as a multi-function feature key for selecting\na software defined function shown on the bottom left\nof the display."]
pub const SDL_Scancode_SDL_SCANCODE_SOFTLEFT: SDL_Scancode = 287;
#[doc = "< Usually situated below the display on phones and\nused as a multi-function feature key for selecting\na software defined function shown on the bottom right\nof the display."]
pub const SDL_Scancode_SDL_SCANCODE_SOFTRIGHT: SDL_Scancode = 288;
#[doc = "< Used for accepting phone calls."]
pub const SDL_Scancode_SDL_SCANCODE_CALL: SDL_Scancode = 289;
#[doc = "< Used for rejecting phone calls."]
pub const SDL_Scancode_SDL_SCANCODE_ENDCALL: SDL_Scancode = 290;
#[doc = "< 400-500 reserved for dynamic keycodes"]
pub const SDL_Scancode_SDL_SCANCODE_RESERVED: SDL_Scancode = 400;
#[doc = "< not a key, just marks the number of scancodes for array bounds"]
pub const SDL_Scancode_SDL_SCANCODE_COUNT: SDL_Scancode = 512;
#[doc = " The SDL keyboard scancode representation.\n\n An SDL scancode is the physical representation of a key on the keyboard,\n independent of language and keyboard mapping.\n\n Values of this type are used to represent keyboard keys, among other places\n in the `scancode` field of the SDL_KeyboardEvent structure.\n\n The values in this enumeration are based on the USB usage page standard:\n https://usb.org/sites/default/files/hut1_5.pdf\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_Scancode = ::core::ffi::c_uint;
#[doc = " The SDL virtual key representation.\n\n Values of this type are used to represent keyboard keys using the current\n layout of the keyboard. These values include Unicode values representing\n the unmodified character that would be generated by pressing the key, or an\n `SDLK_*` constant for those keys that do not generate characters.\n\n A special exception is the number keys at the top of the keyboard which map\n to SDLK_0...SDLK_9 on AZERTY layouts.\n\n Keys with the `SDLK_EXTENDED_MASK` bit set do not map to a scancode or\n unicode code point.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_Keycode = Uint32;
#[doc = " Valid key modifiers (possibly OR'd together).\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_Keymod = Uint16;
#[doc = " This is a unique ID for a display for the time it is connected to the\n system, and is never reused for the lifetime of the application.\n\n If the display is disconnected and reconnected, it will get a new ID.\n\n The value 0 is an invalid ID.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_DisplayID = Uint32;
#[doc = " This is a unique ID for a window.\n\n The value 0 is an invalid ID.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_WindowID = Uint32;
#[doc = "< Unknown system theme"]
pub const SDL_SystemTheme_SDL_SYSTEM_THEME_UNKNOWN: SDL_SystemTheme = 0;
#[doc = "< Light colored system theme"]
pub const SDL_SystemTheme_SDL_SYSTEM_THEME_LIGHT: SDL_SystemTheme = 1;
#[doc = "< Dark colored system theme"]
pub const SDL_SystemTheme_SDL_SYSTEM_THEME_DARK: SDL_SystemTheme = 2;
#[doc = " System theme.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_SystemTheme = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_DisplayModeData {
    _unused: [u8; 0],
}
#[doc = " The structure that defines a display mode.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_GetFullscreenDisplayModes\n \\sa SDL_GetDesktopDisplayMode\n \\sa SDL_GetCurrentDisplayMode\n \\sa SDL_SetWindowFullscreenMode\n \\sa SDL_GetWindowFullscreenMode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_DisplayMode {
    #[doc = "< the display this mode is associated with"]
    pub displayID: SDL_DisplayID,
    #[doc = "< pixel format"]
    pub format: SDL_PixelFormat,
    #[doc = "< width"]
    pub w: ::core::ffi::c_int,
    #[doc = "< height"]
    pub h: ::core::ffi::c_int,
    #[doc = "< scale converting size to pixels (e.g. a 1920x1080 mode with 2.0 scale would have 3840x2160 pixels)"]
    pub pixel_density: f32,
    #[doc = "< refresh rate (or 0.0f for unspecified)"]
    pub refresh_rate: f32,
    #[doc = "< precise refresh rate numerator (or 0 for unspecified)"]
    pub refresh_rate_numerator: ::core::ffi::c_int,
    #[doc = "< precise refresh rate denominator"]
    pub refresh_rate_denominator: ::core::ffi::c_int,
    #[doc = "< Private"]
    pub internal: *mut SDL_DisplayModeData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_DisplayMode"][::core::mem::size_of::<SDL_DisplayMode>() - 40usize];
    ["Alignment of SDL_DisplayMode"][::core::mem::align_of::<SDL_DisplayMode>() - 8usize];
    ["Offset of field: SDL_DisplayMode::displayID"]
        [::core::mem::offset_of!(SDL_DisplayMode, displayID) - 0usize];
    ["Offset of field: SDL_DisplayMode::format"]
        [::core::mem::offset_of!(SDL_DisplayMode, format) - 4usize];
    ["Offset of field: SDL_DisplayMode::w"][::core::mem::offset_of!(SDL_DisplayMode, w) - 8usize];
    ["Offset of field: SDL_DisplayMode::h"][::core::mem::offset_of!(SDL_DisplayMode, h) - 12usize];
    ["Offset of field: SDL_DisplayMode::pixel_density"]
        [::core::mem::offset_of!(SDL_DisplayMode, pixel_density) - 16usize];
    ["Offset of field: SDL_DisplayMode::refresh_rate"]
        [::core::mem::offset_of!(SDL_DisplayMode, refresh_rate) - 20usize];
    ["Offset of field: SDL_DisplayMode::refresh_rate_numerator"]
        [::core::mem::offset_of!(SDL_DisplayMode, refresh_rate_numerator) - 24usize];
    ["Offset of field: SDL_DisplayMode::refresh_rate_denominator"]
        [::core::mem::offset_of!(SDL_DisplayMode, refresh_rate_denominator) - 28usize];
    ["Offset of field: SDL_DisplayMode::internal"]
        [::core::mem::offset_of!(SDL_DisplayMode, internal) - 32usize];
};
#[doc = "< The display orientation can't be determined"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_UNKNOWN: SDL_DisplayOrientation = 0;
#[doc = "< The display is in landscape mode, with the right side up, relative to portrait mode"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_LANDSCAPE: SDL_DisplayOrientation = 1;
#[doc = "< The display is in landscape mode, with the left side up, relative to portrait mode"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_LANDSCAPE_FLIPPED: SDL_DisplayOrientation = 2;
#[doc = "< The display is in portrait mode"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_PORTRAIT: SDL_DisplayOrientation = 3;
#[doc = "< The display is in portrait mode, upside down"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_PORTRAIT_FLIPPED: SDL_DisplayOrientation = 4;
#[doc = " Display orientation values; the way a display is rotated.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_DisplayOrientation = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Window {
    _unused: [u8; 0],
}
#[doc = " The flags on a window.\n\n These cover a lot of true/false, or on/off, window state. Some of it is\n immutable after being set through SDL_CreateWindow(), some of it can be\n changed on existing windows by the app, and some of it might be altered by\n the user or system outside of the app's control.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowFlags"]
pub type SDL_WindowFlags = Uint64;
#[doc = "< Cancel any window flash state"]
pub const SDL_FlashOperation_SDL_FLASH_CANCEL: SDL_FlashOperation = 0;
#[doc = "< Flash the window briefly to get attention"]
pub const SDL_FlashOperation_SDL_FLASH_BRIEFLY: SDL_FlashOperation = 1;
#[doc = "< Flash the window until it gets focus"]
pub const SDL_FlashOperation_SDL_FLASH_UNTIL_FOCUSED: SDL_FlashOperation = 2;
#[doc = " Window flash operation.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_FlashOperation = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_GLContextState {
    _unused: [u8; 0],
}
#[doc = " An opaque handle to an OpenGL context.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_GL_CreateContext"]
pub type SDL_GLContext = *mut SDL_GLContextState;
#[doc = " Opaque type for an EGL display.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_EGLDisplay = *mut ::core::ffi::c_void;
#[doc = " Opaque type for an EGL config.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_EGLConfig = *mut ::core::ffi::c_void;
#[doc = " Opaque type for an EGL surface.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_EGLSurface = *mut ::core::ffi::c_void;
#[doc = " An EGL attribute, used when creating an EGL context.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_EGLAttrib = isize;
#[doc = " An EGL integer attribute, used when creating an EGL surface.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_EGLint = ::core::ffi::c_int;
#[doc = " EGL platform attribute initialization callback.\n\n This is called when SDL is attempting to create an EGL context, to let the\n app add extra attributes to its eglGetPlatformDisplay() call.\n\n The callback should return a pointer to an EGL attribute array terminated\n with `EGL_NONE`. If this function returns NULL, the SDL_CreateWindow\n process will fail gracefully.\n\n The returned pointer should be allocated with SDL_malloc() and will be\n passed to SDL_free().\n\n The arrays returned by each callback will be appended to the existing\n attribute arrays defined by SDL.\n\n \\param userdata an app-controlled pointer that is passed to the callback.\n \\returns a newly-allocated array of attributes, terminated with `EGL_NONE`.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_EGL_SetAttributeCallbacks"]
pub type SDL_EGLAttribArrayCallback = ::core::option::Option<
    unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void) -> *mut SDL_EGLAttrib,
>;
#[doc = " EGL surface/context attribute initialization callback types.\n\n This is called when SDL is attempting to create an EGL surface, to let the\n app add extra attributes to its eglCreateWindowSurface() or\n eglCreateContext calls.\n\n For convenience, the EGLDisplay and EGLConfig to use are provided to the\n callback.\n\n The callback should return a pointer to an EGL attribute array terminated\n with `EGL_NONE`. If this function returns NULL, the SDL_CreateWindow\n process will fail gracefully.\n\n The returned pointer should be allocated with SDL_malloc() and will be\n passed to SDL_free().\n\n The arrays returned by each callback will be appended to the existing\n attribute arrays defined by SDL.\n\n \\param userdata an app-controlled pointer that is passed to the callback.\n \\param display the EGL display to be used.\n \\param config the EGL config to be used.\n \\returns a newly-allocated array of attributes, terminated with `EGL_NONE`.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_EGL_SetAttributeCallbacks"]
pub type SDL_EGLIntArrayCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::core::ffi::c_void,
        display: SDL_EGLDisplay,
        config: SDL_EGLConfig,
    ) -> *mut SDL_EGLint,
>;
#[doc = "< the minimum number of bits for the red channel of the color buffer; defaults to 3."]
pub const SDL_GLAttr_SDL_GL_RED_SIZE: SDL_GLAttr = 0;
#[doc = "< the minimum number of bits for the green channel of the color buffer; defaults to 3."]
pub const SDL_GLAttr_SDL_GL_GREEN_SIZE: SDL_GLAttr = 1;
#[doc = "< the minimum number of bits for the blue channel of the color buffer; defaults to 2."]
pub const SDL_GLAttr_SDL_GL_BLUE_SIZE: SDL_GLAttr = 2;
#[doc = "< the minimum number of bits for the alpha channel of the color buffer; defaults to 0."]
pub const SDL_GLAttr_SDL_GL_ALPHA_SIZE: SDL_GLAttr = 3;
#[doc = "< the minimum number of bits for frame buffer size; defaults to 0."]
pub const SDL_GLAttr_SDL_GL_BUFFER_SIZE: SDL_GLAttr = 4;
#[doc = "< whether the output is single or double buffered; defaults to double buffering on."]
pub const SDL_GLAttr_SDL_GL_DOUBLEBUFFER: SDL_GLAttr = 5;
#[doc = "< the minimum number of bits in the depth buffer; defaults to 16."]
pub const SDL_GLAttr_SDL_GL_DEPTH_SIZE: SDL_GLAttr = 6;
#[doc = "< the minimum number of bits in the stencil buffer; defaults to 0."]
pub const SDL_GLAttr_SDL_GL_STENCIL_SIZE: SDL_GLAttr = 7;
#[doc = "< the minimum number of bits for the red channel of the accumulation buffer; defaults to 0."]
pub const SDL_GLAttr_SDL_GL_ACCUM_RED_SIZE: SDL_GLAttr = 8;
#[doc = "< the minimum number of bits for the green channel of the accumulation buffer; defaults to 0."]
pub const SDL_GLAttr_SDL_GL_ACCUM_GREEN_SIZE: SDL_GLAttr = 9;
#[doc = "< the minimum number of bits for the blue channel of the accumulation buffer; defaults to 0."]
pub const SDL_GLAttr_SDL_GL_ACCUM_BLUE_SIZE: SDL_GLAttr = 10;
#[doc = "< the minimum number of bits for the alpha channel of the accumulation buffer; defaults to 0."]
pub const SDL_GLAttr_SDL_GL_ACCUM_ALPHA_SIZE: SDL_GLAttr = 11;
#[doc = "< whether the output is stereo 3D; defaults to off."]
pub const SDL_GLAttr_SDL_GL_STEREO: SDL_GLAttr = 12;
#[doc = "< the number of buffers used for multisample anti-aliasing; defaults to 0."]
pub const SDL_GLAttr_SDL_GL_MULTISAMPLEBUFFERS: SDL_GLAttr = 13;
#[doc = "< the number of samples used around the current pixel used for multisample anti-aliasing."]
pub const SDL_GLAttr_SDL_GL_MULTISAMPLESAMPLES: SDL_GLAttr = 14;
#[doc = "< set to 1 to require hardware acceleration, set to 0 to force software rendering; defaults to allow either."]
pub const SDL_GLAttr_SDL_GL_ACCELERATED_VISUAL: SDL_GLAttr = 15;
#[doc = "< not used (deprecated)."]
pub const SDL_GLAttr_SDL_GL_RETAINED_BACKING: SDL_GLAttr = 16;
#[doc = "< OpenGL context major version."]
pub const SDL_GLAttr_SDL_GL_CONTEXT_MAJOR_VERSION: SDL_GLAttr = 17;
#[doc = "< OpenGL context minor version."]
pub const SDL_GLAttr_SDL_GL_CONTEXT_MINOR_VERSION: SDL_GLAttr = 18;
#[doc = "< some combination of 0 or more of elements of the SDL_GLContextFlag enumeration; defaults to 0."]
pub const SDL_GLAttr_SDL_GL_CONTEXT_FLAGS: SDL_GLAttr = 19;
#[doc = "< type of GL context (Core, Compatibility, ES). See SDL_GLProfile; default value depends on platform."]
pub const SDL_GLAttr_SDL_GL_CONTEXT_PROFILE_MASK: SDL_GLAttr = 20;
#[doc = "< OpenGL context sharing; defaults to 0."]
pub const SDL_GLAttr_SDL_GL_SHARE_WITH_CURRENT_CONTEXT: SDL_GLAttr = 21;
#[doc = "< requests sRGB capable visual; defaults to 0."]
pub const SDL_GLAttr_SDL_GL_FRAMEBUFFER_SRGB_CAPABLE: SDL_GLAttr = 22;
#[doc = "< sets context the release behavior. See SDL_GLContextReleaseFlag; defaults to FLUSH."]
pub const SDL_GLAttr_SDL_GL_CONTEXT_RELEASE_BEHAVIOR: SDL_GLAttr = 23;
#[doc = "< set context reset notification. See SDL_GLContextResetNotification; defaults to NO_NOTIFICATION."]
pub const SDL_GLAttr_SDL_GL_CONTEXT_RESET_NOTIFICATION: SDL_GLAttr = 24;
pub const SDL_GLAttr_SDL_GL_CONTEXT_NO_ERROR: SDL_GLAttr = 25;
pub const SDL_GLAttr_SDL_GL_FLOATBUFFERS: SDL_GLAttr = 26;
pub const SDL_GLAttr_SDL_GL_EGL_PLATFORM: SDL_GLAttr = 27;
#[doc = " An enumeration of OpenGL configuration attributes.\n\n While you can set most OpenGL attributes normally, the attributes listed\n above must be known before SDL creates the window that will be used with\n the OpenGL context. These attributes are set and read with\n SDL_GL_SetAttribute() and SDL_GL_GetAttribute().\n\n In some cases, these attributes are minimum requests; the GL does not\n promise to give you exactly what you asked for. It's possible to ask for a\n 16-bit depth buffer and get a 24-bit one instead, for example, or to ask\n for no stencil buffer and still have one available. Context creation should\n fail if the GL can't provide your requested attributes at a minimum, but\n you should check to see exactly what you got.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_GLAttr = ::core::ffi::c_uint;
#[doc = " Possible values to be set for the SDL_GL_CONTEXT_PROFILE_MASK attribute.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_GLProfile = Uint32;
#[doc = " Possible flags to be set for the SDL_GL_CONTEXT_FLAGS attribute.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_GLContextFlag = Uint32;
#[doc = " Possible values to be set for the SDL_GL_CONTEXT_RELEASE_BEHAVIOR\n attribute.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_GLContextReleaseFlag = Uint32;
#[doc = " Possible values to be set SDL_GL_CONTEXT_RESET_NOTIFICATION attribute.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_GLContextResetNotification = Uint32;
unsafe extern "C" {
    #[doc = " Get the number of video drivers compiled into SDL.\n\n \\returns the number of built in video drivers.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetVideoDriver"]
    pub fn SDL_GetNumVideoDrivers() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Get the name of a built in video driver.\n\n The video drivers are presented in the order in which they are normally\n checked during initialization.\n\n The names of drivers are all simple, low-ASCII identifiers, like \"cocoa\",\n \"x11\" or \"windows\". These never have Unicode characters, and are not meant\n to be proper names.\n\n \\param index the index of a video driver.\n \\returns the name of the video driver with the given **index**.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetNumVideoDrivers"]
    pub fn SDL_GetVideoDriver(index: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the currently initialized video driver.\n\n The names of drivers are all simple, low-ASCII identifiers, like \"cocoa\",\n \"x11\" or \"windows\". These never have Unicode characters, and are not meant\n to be proper names.\n\n \\returns the name of the current video driver or NULL if no driver has been\n          initialized.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetNumVideoDrivers\n \\sa SDL_GetVideoDriver"]
    pub fn SDL_GetCurrentVideoDriver() -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the current system theme.\n\n \\returns the current system theme, light, dark, or unknown.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetSystemTheme() -> SDL_SystemTheme;
}
unsafe extern "C" {
    #[doc = " Get a list of currently connected displays.\n\n \\param count a pointer filled in with the number of displays returned, may\n              be NULL.\n \\returns a 0 terminated array of display instance IDs or NULL on failure;\n          call SDL_GetError() for more information. This should be freed\n          with SDL_free() when it is no longer needed.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetDisplays(count: *mut ::core::ffi::c_int) -> *mut SDL_DisplayID;
}
unsafe extern "C" {
    #[doc = " Return the primary display.\n\n \\returns the instance ID of the primary display on success or 0 on failure;\n          call SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetPrimaryDisplay() -> SDL_DisplayID;
}
unsafe extern "C" {
    #[doc = " Get the properties associated with a display.\n\n The following read-only properties are provided by SDL:\n\n - `SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN`: true if the display has HDR\n   headroom above the SDR white point. This is for informational and\n   diagnostic purposes only, as not all platforms provide this information\n   at the display level.\n\n On KMS/DRM:\n\n - `SDL_PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER`: the \"panel\n   orientation\" property for the display in degrees of clockwise rotation.\n   Note that this is provided only as a hint, and the application is\n   responsible for any coordinate transformations needed to conform to the\n   requested display orientation.\n\n \\param displayID the instance ID of the display to query.\n \\returns a valid property ID on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetDisplayProperties(displayID: SDL_DisplayID) -> SDL_PropertiesID;
}
unsafe extern "C" {
    #[doc = " Get the name of a display in UTF-8 encoding.\n\n \\param displayID the instance ID of the display to query.\n \\returns the name of a display or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayName(displayID: SDL_DisplayID) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the desktop area represented by a display.\n\n The primary display is often located at (0,0), but may be placed at a\n different location depending on monitor layout.\n\n \\param displayID the instance ID of the display to query.\n \\param rect the SDL_Rect structure filled in with the display bounds.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetDisplayUsableBounds\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayBounds(displayID: SDL_DisplayID, rect: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the usable desktop area represented by a display, in screen\n coordinates.\n\n This is the same area as SDL_GetDisplayBounds() reports, but with portions\n reserved by the system removed. For example, on Apple's macOS, this\n subtracts the area occupied by the menu bar and dock.\n\n Setting a window to be fullscreen generally bypasses these unusable areas,\n so these are good guidelines for the maximum space available to a\n non-fullscreen window.\n\n \\param displayID the instance ID of the display to query.\n \\param rect the SDL_Rect structure filled in with the display bounds.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetDisplayBounds\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayUsableBounds(displayID: SDL_DisplayID, rect: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the orientation of a display when it is unrotated.\n\n \\param displayID the instance ID of the display to query.\n \\returns the SDL_DisplayOrientation enum value of the display, or\n          `SDL_ORIENTATION_UNKNOWN` if it isn't available.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetNaturalDisplayOrientation(displayID: SDL_DisplayID) -> SDL_DisplayOrientation;
}
unsafe extern "C" {
    #[doc = " Get the orientation of a display.\n\n \\param displayID the instance ID of the display to query.\n \\returns the SDL_DisplayOrientation enum value of the display, or\n          `SDL_ORIENTATION_UNKNOWN` if it isn't available.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetCurrentDisplayOrientation(displayID: SDL_DisplayID) -> SDL_DisplayOrientation;
}
unsafe extern "C" {
    #[doc = " Get the content scale of a display.\n\n The content scale is the expected scale for content based on the DPI\n settings of the display. For example, a 4K display might have a 2.0 (200%)\n display scale, which means that the user expects UI elements to be twice as\n big on this display, to aid in readability.\n\n After window creation, SDL_GetWindowDisplayScale() should be used to query\n the content scale factor for individual windows instead of querying the\n display for a window and calling this function, as the per-window content\n scale factor may differ from the base value of the display it is on,\n particularly on high-DPI and/or multi-monitor desktop configurations.\n\n \\param displayID the instance ID of the display to query.\n \\returns the content scale of the display, or 0.0f on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowDisplayScale\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayContentScale(displayID: SDL_DisplayID) -> f32;
}
unsafe extern "C" {
    #[doc = " Get a list of fullscreen display modes available on a display.\n\n The display modes are sorted in this priority:\n\n - w -> largest to smallest\n - h -> largest to smallest\n - bits per pixel -> more colors to fewer colors\n - packed pixel layout -> largest to smallest\n - refresh rate -> highest to lowest\n - pixel density -> lowest to highest\n\n \\param displayID the instance ID of the display to query.\n \\param count a pointer filled in with the number of display modes returned,\n              may be NULL.\n \\returns a NULL terminated array of display mode pointers or NULL on\n          failure; call SDL_GetError() for more information. This is a\n          single allocation that should be freed with SDL_free() when it is\n          no longer needed.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetFullscreenDisplayModes(
        displayID: SDL_DisplayID,
        count: *mut ::core::ffi::c_int,
    ) -> *mut *mut SDL_DisplayMode;
}
unsafe extern "C" {
    #[doc = " Get the closest match to the requested display mode.\n\n The available display modes are scanned and `closest` is filled in with the\n closest mode matching the requested mode and returned. The mode format and\n refresh rate default to the desktop mode if they are set to 0. The modes\n are scanned with size being first priority, format being second priority,\n and finally checking the refresh rate. If all the available modes are too\n small, then false is returned.\n\n \\param displayID the instance ID of the display to query.\n \\param w the width in pixels of the desired display mode.\n \\param h the height in pixels of the desired display mode.\n \\param refresh_rate the refresh rate of the desired display mode, or 0.0f\n                     for the desktop refresh rate.\n \\param include_high_density_modes boolean to include high density modes in\n                                   the search.\n \\param closest a pointer filled in with the closest display mode equal to\n                or larger than the desired mode.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetDisplays\n \\sa SDL_GetFullscreenDisplayModes"]
    pub fn SDL_GetClosestFullscreenDisplayMode(
        displayID: SDL_DisplayID,
        w: ::core::ffi::c_int,
        h: ::core::ffi::c_int,
        refresh_rate: f32,
        include_high_density_modes: bool,
        closest: *mut SDL_DisplayMode,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get information about the desktop's display mode.\n\n There's a difference between this function and SDL_GetCurrentDisplayMode()\n when SDL runs fullscreen and has changed the resolution. In that case this\n function will return the previous native display mode, and not the current\n display mode.\n\n \\param displayID the instance ID of the display to query.\n \\returns a pointer to the desktop display mode or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetCurrentDisplayMode\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDesktopDisplayMode(displayID: SDL_DisplayID) -> *const SDL_DisplayMode;
}
unsafe extern "C" {
    #[doc = " Get information about the current display mode.\n\n There's a difference between this function and SDL_GetDesktopDisplayMode()\n when SDL runs fullscreen and has changed the resolution. In that case this\n function will return the current display mode, and not the previous native\n display mode.\n\n \\param displayID the instance ID of the display to query.\n \\returns a pointer to the desktop display mode or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetDesktopDisplayMode\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetCurrentDisplayMode(displayID: SDL_DisplayID) -> *const SDL_DisplayMode;
}
unsafe extern "C" {
    #[doc = " Get the display containing a point.\n\n \\param point the point to query.\n \\returns the instance ID of the display containing the point or 0 on\n          failure; call SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetDisplayBounds\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayForPoint(point: *const SDL_Point) -> SDL_DisplayID;
}
unsafe extern "C" {
    #[doc = " Get the display primarily containing a rect.\n\n \\param rect the rect to query.\n \\returns the instance ID of the display entirely containing the rect or\n          closest to the center of the rect on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetDisplayBounds\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayForRect(rect: *const SDL_Rect) -> SDL_DisplayID;
}
unsafe extern "C" {
    #[doc = " Get the display associated with a window.\n\n \\param window the window to query.\n \\returns the instance ID of the display containing the center of the window\n          on success or 0 on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetDisplayBounds\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayForWindow(window: *mut SDL_Window) -> SDL_DisplayID;
}
unsafe extern "C" {
    #[doc = " Get the pixel density of a window.\n\n This is a ratio of pixel size to window size. For example, if the window is\n 1920x1080 and it has a high density back buffer of 3840x2160 pixels, it\n would have a pixel density of 2.0.\n\n \\param window the window to query.\n \\returns the pixel density or 0.0f on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowDisplayScale"]
    pub fn SDL_GetWindowPixelDensity(window: *mut SDL_Window) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the content display scale relative to a window's pixel size.\n\n This is a combination of the window pixel density and the display content\n scale, and is the expected scale for displaying content in this window. For\n example, if a 3840x2160 window had a display scale of 2.0, the user expects\n the content to take twice as many pixels and be the same physical size as\n if it were being displayed in a 1920x1080 window with a display scale of\n 1.0.\n\n Conceptually this value corresponds to the scale display setting, and is\n updated when that setting is changed, or the window moves to a display with\n a different scale setting.\n\n \\param window the window to query.\n \\returns the display scale, or 0.0f on failure; call SDL_GetError() for\n          more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetWindowDisplayScale(window: *mut SDL_Window) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the display mode to use when a window is visible and fullscreen.\n\n This only affects the display mode used when the window is fullscreen. To\n change the window size when the window is not fullscreen, use\n SDL_SetWindowSize().\n\n If the window is currently in the fullscreen state, this request is\n asynchronous on some windowing systems and the new mode dimensions may not\n be applied immediately upon the return of this function. If an immediate\n change is required, call SDL_SyncWindow() to block until the changes have\n taken effect.\n\n When the new mode takes effect, an SDL_EVENT_WINDOW_RESIZED and/or an\n SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event will be emitted with the new mode\n dimensions.\n\n \\param window the window to affect.\n \\param mode a pointer to the display mode to use, which can be NULL for\n             borderless fullscreen desktop mode, or one of the fullscreen\n             modes returned by SDL_GetFullscreenDisplayModes() to set an\n             exclusive fullscreen mode.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowFullscreenMode\n \\sa SDL_SetWindowFullscreen\n \\sa SDL_SyncWindow"]
    pub fn SDL_SetWindowFullscreenMode(
        window: *mut SDL_Window,
        mode: *const SDL_DisplayMode,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Query the display mode to use when a window is visible at fullscreen.\n\n \\param window the window to query.\n \\returns a pointer to the exclusive fullscreen mode to use or NULL for\n          borderless fullscreen desktop mode.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowFullscreenMode\n \\sa SDL_SetWindowFullscreen"]
    pub fn SDL_GetWindowFullscreenMode(window: *mut SDL_Window) -> *const SDL_DisplayMode;
}
unsafe extern "C" {
    #[doc = " Get the raw ICC profile data for the screen the window is currently on.\n\n \\param window the window to query.\n \\param size the size of the ICC profile.\n \\returns the raw ICC profile data on success or NULL on failure; call\n          SDL_GetError() for more information. This should be freed with\n          SDL_free() when it is no longer needed.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetWindowICCProfile(
        window: *mut SDL_Window,
        size: *mut usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Get the pixel format associated with the window.\n\n \\param window the window to query.\n \\returns the pixel format of the window on success or\n          SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetWindowPixelFormat(window: *mut SDL_Window) -> SDL_PixelFormat;
}
unsafe extern "C" {
    #[doc = " Get a list of valid windows.\n\n \\param count a pointer filled in with the number of windows returned, may\n              be NULL.\n \\returns a NULL terminated array of SDL_Window pointers or NULL on failure;\n          call SDL_GetError() for more information. This is a single\n          allocation that should be freed with SDL_free() when it is no\n          longer needed.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetWindows(count: *mut ::core::ffi::c_int) -> *mut *mut SDL_Window;
}
unsafe extern "C" {
    #[doc = " Create a window with the specified dimensions and flags.\n\n `flags` may be any of the following OR'd together:\n\n - `SDL_WINDOW_FULLSCREEN`: fullscreen window at desktop resolution\n - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context\n - `SDL_WINDOW_OCCLUDED`: window partially or completely obscured by another\n   window\n - `SDL_WINDOW_HIDDEN`: window is not visible\n - `SDL_WINDOW_BORDERLESS`: no window decoration\n - `SDL_WINDOW_RESIZABLE`: window can be resized\n - `SDL_WINDOW_MINIMIZED`: window is minimized\n - `SDL_WINDOW_MAXIMIZED`: window is maximized\n - `SDL_WINDOW_MOUSE_GRABBED`: window has grabbed mouse focus\n - `SDL_WINDOW_INPUT_FOCUS`: window has input focus\n - `SDL_WINDOW_MOUSE_FOCUS`: window has mouse focus\n - `SDL_WINDOW_EXTERNAL`: window not created by SDL\n - `SDL_WINDOW_MODAL`: window is modal\n - `SDL_WINDOW_HIGH_PIXEL_DENSITY`: window uses high pixel density back\n   buffer if possible\n - `SDL_WINDOW_MOUSE_CAPTURE`: window has mouse captured (unrelated to\n   MOUSE_GRABBED)\n - `SDL_WINDOW_ALWAYS_ON_TOP`: window should always be above others\n - `SDL_WINDOW_UTILITY`: window should be treated as a utility window, not\n   showing in the task bar and window list\n - `SDL_WINDOW_TOOLTIP`: window should be treated as a tooltip and does not\n   get mouse or keyboard focus, requires a parent window\n - `SDL_WINDOW_POPUP_MENU`: window should be treated as a popup menu,\n   requires a parent window\n - `SDL_WINDOW_KEYBOARD_GRABBED`: window has grabbed keyboard input\n - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance\n - `SDL_WINDOW_METAL`: window usable with a Metal instance\n - `SDL_WINDOW_TRANSPARENT`: window with transparent buffer\n - `SDL_WINDOW_NOT_FOCUSABLE`: window should not be focusable\n\n The SDL_Window is implicitly shown if SDL_WINDOW_HIDDEN is not set.\n\n On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist\n property to YES, otherwise you will not receive a High-DPI OpenGL canvas.\n\n The window pixel size may differ from its window coordinate size if the\n window is on a high pixel density display. Use SDL_GetWindowSize() to query\n the client area's size in window coordinates, and\n SDL_GetWindowSizeInPixels() or SDL_GetRenderOutputSize() to query the\n drawable size in pixels. Note that the drawable size can vary after the\n window is created and should be queried again if you get an\n SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event.\n\n If the window is created with any of the SDL_WINDOW_OPENGL or\n SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function\n (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the\n corresponding UnloadLibrary function is called by SDL_DestroyWindow().\n\n If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,\n SDL_CreateWindow() will fail, because SDL_Vulkan_LoadLibrary() will fail.\n\n If SDL_WINDOW_METAL is specified on an OS that does not support Metal,\n SDL_CreateWindow() will fail.\n\n If you intend to use this window with an SDL_Renderer, you should use\n SDL_CreateWindowAndRenderer() instead of this function, to avoid window\n flicker.\n\n On non-Apple devices, SDL requires you to either not link to the Vulkan\n loader or link to a dynamic library version. This limitation may be removed\n in a future version of SDL.\n\n \\param title the title of the window, in UTF-8 encoding.\n \\param w the width of the window.\n \\param h the height of the window.\n \\param flags 0, or one or more SDL_WindowFlags OR'd together.\n \\returns the window that was created or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateWindowAndRenderer\n \\sa SDL_CreatePopupWindow\n \\sa SDL_CreateWindowWithProperties\n \\sa SDL_DestroyWindow"]
    pub fn SDL_CreateWindow(
        title: *const ::core::ffi::c_char,
        w: ::core::ffi::c_int,
        h: ::core::ffi::c_int,
        flags: SDL_WindowFlags,
    ) -> *mut SDL_Window;
}
unsafe extern "C" {
    #[doc = " Create a child popup window of the specified parent window.\n\n The flags parameter **must** contain at least one of the following:\n\n - `SDL_WINDOW_TOOLTIP`: The popup window is a tooltip and will not pass any\n   input events.\n - `SDL_WINDOW_POPUP_MENU`: The popup window is a popup menu. The topmost\n   popup menu will implicitly gain the keyboard focus.\n\n The following flags are not relevant to popup window creation and will be\n ignored:\n\n - `SDL_WINDOW_MINIMIZED`\n - `SDL_WINDOW_MAXIMIZED`\n - `SDL_WINDOW_FULLSCREEN`\n - `SDL_WINDOW_BORDERLESS`\n\n The following flags are incompatible with popup window creation and will\n cause it to fail:\n\n - `SDL_WINDOW_UTILITY`\n - `SDL_WINDOW_MODAL`\n\n The parent parameter **must** be non-null and a valid window. The parent of\n a popup window can be either a regular, toplevel window, or another popup\n window.\n\n Popup windows cannot be minimized, maximized, made fullscreen, raised,\n flash, be made a modal window, be the parent of a toplevel window, or grab\n the mouse and/or keyboard. Attempts to do so will fail.\n\n Popup windows implicitly do not have a border/decorations and do not appear\n on the taskbar/dock or in lists of windows such as alt-tab menus.\n\n If a parent window is hidden or destroyed, any child popup windows will be\n recursively hidden or destroyed as well. Child popup windows not explicitly\n hidden will be restored when the parent is shown.\n\n \\param parent the parent of the window, must not be NULL.\n \\param offset_x the x position of the popup window relative to the origin\n                 of the parent.\n \\param offset_y the y position of the popup window relative to the origin\n                 of the parent window.\n \\param w the width of the window.\n \\param h the height of the window.\n \\param flags SDL_WINDOW_TOOLTIP or SDL_WINDOW_POPUP_MENU, and zero or more\n              additional SDL_WindowFlags OR'd together.\n \\returns the window that was created or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateWindow\n \\sa SDL_CreateWindowWithProperties\n \\sa SDL_DestroyWindow\n \\sa SDL_GetWindowParent"]
    pub fn SDL_CreatePopupWindow(
        parent: *mut SDL_Window,
        offset_x: ::core::ffi::c_int,
        offset_y: ::core::ffi::c_int,
        w: ::core::ffi::c_int,
        h: ::core::ffi::c_int,
        flags: SDL_WindowFlags,
    ) -> *mut SDL_Window;
}
unsafe extern "C" {
    #[doc = " Create a window with the specified properties.\n\n These are the supported properties:\n\n - `SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN`: true if the window should\n   be always on top\n - `SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN`: true if the window has no\n   window decoration\n - `SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN`: true if the\n   window will be used with an externally managed graphics context.\n - `SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN`: true if the window should\n   accept keyboard input (defaults true)\n - `SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN`: true if the window should\n   start in fullscreen mode at desktop resolution\n - `SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER`: the height of the window\n - `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN`: true if the window should start\n   hidden\n - `SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN`: true if the window\n   uses a high pixel density buffer if possible\n - `SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN`: true if the window should\n   start maximized\n - `SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN`: true if the window is a popup menu\n - `SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN`: true if the window will be used\n   with Metal rendering\n - `SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN`: true if the window should\n   start minimized\n - `SDL_PROP_WINDOW_CREATE_MODAL_BOOLEAN`: true if the window is modal to\n   its parent\n - `SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN`: true if the window starts\n   with grabbed mouse focus\n - `SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`: true if the window will be used\n   with OpenGL rendering\n - `SDL_PROP_WINDOW_CREATE_PARENT_POINTER`: an SDL_Window that will be the\n   parent of this window, required for windows with the \"tooltip\", \"menu\",\n   and \"modal\" properties\n - `SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN`: true if the window should be\n   resizable\n - `SDL_PROP_WINDOW_CREATE_TITLE_STRING`: the title of the window, in UTF-8\n   encoding\n - `SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN`: true if the window show\n   transparent in the areas with alpha of 0\n - `SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN`: true if the window is a tooltip\n - `SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN`: true if the window is a utility\n   window, not showing in the task bar and window list\n - `SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN`: true if the window will be used\n   with Vulkan rendering\n - `SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER`: the width of the window\n - `SDL_PROP_WINDOW_CREATE_X_NUMBER`: the x position of the window, or\n   `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is\n   relative to the parent for windows with the \"tooltip\" or \"menu\" property\n   set.\n - `SDL_PROP_WINDOW_CREATE_Y_NUMBER`: the y position of the window, or\n   `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is\n   relative to the parent for windows with the \"tooltip\" or \"menu\" property\n   set.\n\n These are additional supported properties on macOS:\n\n - `SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER`: the\n   `(__unsafe_unretained)` NSWindow associated with the window, if you want\n   to wrap an existing window.\n - `SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER`: the `(__unsafe_unretained)`\n   NSView associated with the window, defaults to `[window contentView]`\n\n These are additional supported properties on Wayland:\n\n - `SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN` - true if\n   the application wants to use the Wayland surface for a custom role and\n   does not want it attached to an XDG toplevel window. See\n   [README/wayland](README/wayland) for more information on using custom\n   surfaces.\n - `SDL_PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN` - true if the\n   application wants an associated `wl_egl_window` object to be created and\n   attached to the window, even if the window does not have the OpenGL\n   property or `SDL_WINDOW_OPENGL` flag set.\n - `SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER` - the wl_surface\n   associated with the window, if you want to wrap an existing window. See\n   [README/wayland](README/wayland) for more information.\n\n These are additional supported properties on Windows:\n\n - `SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER`: the HWND associated with the\n   window, if you want to wrap an existing window.\n - `SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER`: optional,\n   another window to share pixel format with, useful for OpenGL windows\n\n These are additional supported properties with X11:\n\n - `SDL_PROP_WINDOW_CREATE_X11_WINDOW_NUMBER`: the X11 Window associated\n   with the window, if you want to wrap an existing window.\n\n The window is implicitly shown if the \"hidden\" property is not set.\n\n Windows with the \"tooltip\" and \"menu\" properties are popup windows and have\n the behaviors and guidelines outlined in SDL_CreatePopupWindow().\n\n If this window is being created to be used with an SDL_Renderer, you should\n not add a graphics API specific property\n (`SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`, etc), as SDL will handle that\n internally when it chooses a renderer. However, SDL might need to recreate\n your window at that point, which may cause the window to appear briefly,\n and then flicker as it is recreated. The correct approach to this is to\n create the window with the `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN` property\n set to true, then create the renderer, then show the window with\n SDL_ShowWindow().\n\n \\param props the properties to use.\n \\returns the window that was created or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateProperties\n \\sa SDL_CreateWindow\n \\sa SDL_DestroyWindow"]
    pub fn SDL_CreateWindowWithProperties(props: SDL_PropertiesID) -> *mut SDL_Window;
}
unsafe extern "C" {
    #[doc = " Get the numeric ID of a window.\n\n The numeric ID is what SDL_WindowEvent references, and is necessary to map\n these events to specific SDL_Window objects.\n\n \\param window the window to query.\n \\returns the ID of the window on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowFromID"]
    pub fn SDL_GetWindowID(window: *mut SDL_Window) -> SDL_WindowID;
}
unsafe extern "C" {
    #[doc = " Get a window from a stored ID.\n\n The numeric ID is what SDL_WindowEvent references, and is necessary to map\n these events to specific SDL_Window objects.\n\n \\param id the ID of the window.\n \\returns the window associated with `id` or NULL if it doesn't exist; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowID"]
    pub fn SDL_GetWindowFromID(id: SDL_WindowID) -> *mut SDL_Window;
}
unsafe extern "C" {
    #[doc = " Get parent of a window.\n\n \\param window the window to query.\n \\returns the parent of the window on success or NULL if the window has no\n          parent.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreatePopupWindow"]
    pub fn SDL_GetWindowParent(window: *mut SDL_Window) -> *mut SDL_Window;
}
unsafe extern "C" {
    #[doc = " Get the properties associated with a window.\n\n The following read-only properties are provided by SDL:\n\n - `SDL_PROP_WINDOW_SHAPE_POINTER`: the surface associated with a shaped\n   window\n - `SDL_PROP_WINDOW_HDR_ENABLED_BOOLEAN`: true if the window has HDR\n   headroom above the SDR white point. This property can change dynamically\n   when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.\n - `SDL_PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT`: the value of SDR white in the\n   SDL_COLORSPACE_SRGB_LINEAR colorspace. On Windows this corresponds to the\n   SDR white level in scRGB colorspace, and on Apple platforms this is\n   always 1.0 for EDR content. This property can change dynamically when\n   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.\n - `SDL_PROP_WINDOW_HDR_HEADROOM_FLOAT`: the additional high dynamic range\n   that can be displayed, in terms of the SDR white point. When HDR is not\n   enabled, this will be 1.0. This property can change dynamically when\n   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.\n\n On Android:\n\n - `SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER`: the ANativeWindow associated\n   with the window\n - `SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER`: the EGLSurface associated with\n   the window\n\n On iOS:\n\n - `SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER`: the `(__unsafe_unretained)`\n   UIWindow associated with the window\n - `SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER`: the NSInteger tag\n   associated with metal views on the window\n - `SDL_PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER`: the OpenGL view's\n   framebuffer object. It must be bound when rendering to the screen using\n   OpenGL.\n - `SDL_PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER`: the OpenGL view's\n   renderbuffer object. It must be bound when SDL_GL_SwapWindow is called.\n - `SDL_PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER`: the OpenGL\n   view's resolve framebuffer, when MSAA is used.\n\n On KMS/DRM:\n\n - `SDL_PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER`: the device index associated\n   with the window (e.g. the X in /dev/dri/cardX)\n - `SDL_PROP_WINDOW_KMSDRM_DRM_FD_NUMBER`: the DRM FD associated with the\n   window\n - `SDL_PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER`: the GBM device associated\n   with the window\n\n On macOS:\n\n - `SDL_PROP_WINDOW_COCOA_WINDOW_POINTER`: the `(__unsafe_unretained)`\n   NSWindow associated with the window\n - `SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER`: the NSInteger tag\n   assocated with metal views on the window\n\n On OpenVR:\n\n - `SDL_PROP_WINDOW_OPENVR_OVERLAY_ID`: the OpenVR Overlay Handle ID for the\n   associated overlay window.\n\n On Vivante:\n\n - `SDL_PROP_WINDOW_VIVANTE_DISPLAY_POINTER`: the EGLNativeDisplayType\n   associated with the window\n - `SDL_PROP_WINDOW_VIVANTE_WINDOW_POINTER`: the EGLNativeWindowType\n   associated with the window\n - `SDL_PROP_WINDOW_VIVANTE_SURFACE_POINTER`: the EGLSurface associated with\n   the window\n\n On Windows:\n\n - `SDL_PROP_WINDOW_WIN32_HWND_POINTER`: the HWND associated with the window\n - `SDL_PROP_WINDOW_WIN32_HDC_POINTER`: the HDC associated with the window\n - `SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER`: the HINSTANCE associated with\n   the window\n\n On Wayland:\n\n Note: The `xdg_*` window objects do not internally persist across window\n show/hide calls. They will be null if the window is hidden and must be\n queried each time it is shown.\n\n - `SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER`: the wl_display associated with\n   the window\n - `SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER`: the wl_surface associated with\n   the window\n - `SDL_PROP_WINDOW_WAYLAND_VIEWPORT_POINTER`: the wp_viewport associated\n   with the window\n - `SDL_PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER`: the wl_egl_window\n   associated with the window\n - `SDL_PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER`: the xdg_surface associated\n   with the window\n - `SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER`: the xdg_toplevel role\n   associated with the window\n - 'SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING': the export\n   handle associated with the window\n - `SDL_PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER`: the xdg_popup role\n   associated with the window\n - `SDL_PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER`: the xdg_positioner\n   associated with the window, in popup mode\n\n On X11:\n\n - `SDL_PROP_WINDOW_X11_DISPLAY_POINTER`: the X11 Display associated with\n   the window\n - `SDL_PROP_WINDOW_X11_SCREEN_NUMBER`: the screen number associated with\n   the window\n - `SDL_PROP_WINDOW_X11_WINDOW_NUMBER`: the X11 Window associated with the\n   window\n\n \\param window the window to query.\n \\returns a valid property ID on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetWindowProperties(window: *mut SDL_Window) -> SDL_PropertiesID;
}
unsafe extern "C" {
    #[doc = " Get the window flags.\n\n \\param window the window to query.\n \\returns a mask of the SDL_WindowFlags associated with `window`.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateWindow\n \\sa SDL_HideWindow\n \\sa SDL_MaximizeWindow\n \\sa SDL_MinimizeWindow\n \\sa SDL_SetWindowFullscreen\n \\sa SDL_SetWindowMouseGrab\n \\sa SDL_ShowWindow"]
    pub fn SDL_GetWindowFlags(window: *mut SDL_Window) -> SDL_WindowFlags;
}
unsafe extern "C" {
    #[doc = " Set the title of a window.\n\n This string is expected to be in UTF-8 encoding.\n\n \\param window the window to change.\n \\param title the desired window title in UTF-8 format.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowTitle"]
    pub fn SDL_SetWindowTitle(window: *mut SDL_Window, title: *const ::core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the title of a window.\n\n \\param window the window to query.\n \\returns the title of the window in UTF-8 format or \"\" if there is no\n          title.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowTitle"]
    pub fn SDL_GetWindowTitle(window: *mut SDL_Window) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Set the icon for a window.\n\n If this function is passed a surface with alternate representations, the\n surface will be interpreted as the content to be used for 100% display\n scale, and the alternate representations will be used for high DPI\n situations. For example, if the original surface is 32x32, then on a 2x\n macOS display or 200% display scale on Windows, a 64x64 version of the\n image will be used, if available. If a matching version of the image isn't\n available, the closest larger size image will be downscaled to the\n appropriate size and be used instead, if available. Otherwise, the closest\n smaller image will be upscaled and be used instead.\n\n \\param window the window to change.\n \\param icon an SDL_Surface structure containing the icon for the window.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetWindowIcon(window: *mut SDL_Window, icon: *mut SDL_Surface) -> bool;
}
unsafe extern "C" {
    #[doc = " Request that the window's position be set.\n\n If the window is in an exclusive fullscreen or maximized state, this\n request has no effect.\n\n This can be used to reposition fullscreen-desktop windows onto a different\n display, however, as exclusive fullscreen windows are locked to a specific\n display, they can only be repositioned programmatically via\n SDL_SetWindowFullscreenMode().\n\n On some windowing systems this request is asynchronous and the new\n coordinates may not have have been applied immediately upon the return of\n this function. If an immediate change is required, call SDL_SyncWindow() to\n block until the changes have taken effect.\n\n When the window position changes, an SDL_EVENT_WINDOW_MOVED event will be\n emitted with the window's new coordinates. Note that the new coordinates\n may not match the exact coordinates requested, as some windowing systems\n can restrict the position of the window in certain scenarios (e.g.\n constraining the position so the window is always within desktop bounds).\n Additionally, as this is just a request, it can be denied by the windowing\n system.\n\n \\param window the window to reposition.\n \\param x the x coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or\n          `SDL_WINDOWPOS_UNDEFINED`.\n \\param y the y coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or\n          `SDL_WINDOWPOS_UNDEFINED`.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowPosition\n \\sa SDL_SyncWindow"]
    pub fn SDL_SetWindowPosition(
        window: *mut SDL_Window,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the position of a window.\n\n This is the current position of the window as last reported by the\n windowing system.\n\n If you do not need the value for one of the positions a NULL may be passed\n in the `x` or `y` parameter.\n\n \\param window the window to query.\n \\param x a pointer filled in with the x position of the window, may be\n          NULL.\n \\param y a pointer filled in with the y position of the window, may be\n          NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowPosition"]
    pub fn SDL_GetWindowPosition(
        window: *mut SDL_Window,
        x: *mut ::core::ffi::c_int,
        y: *mut ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Request that the size of a window's client area be set.\n\n If the window is in a fullscreen or maximized state, this request has no\n effect.\n\n To change the exclusive fullscreen mode of a window, use\n SDL_SetWindowFullscreenMode().\n\n On some windowing systems, this request is asynchronous and the new window\n size may not have have been applied immediately upon the return of this\n function. If an immediate change is required, call SDL_SyncWindow() to\n block until the changes have taken effect.\n\n When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be\n emitted with the new window dimensions. Note that the new dimensions may\n not match the exact size requested, as some windowing systems can restrict\n the window size in certain scenarios (e.g. constraining the size of the\n content area to remain within the usable desktop bounds). Additionally, as\n this is just a request, it can be denied by the windowing system.\n\n \\param window the window to change.\n \\param w the width of the window, must be > 0.\n \\param h the height of the window, must be > 0.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowSize\n \\sa SDL_SetWindowFullscreenMode\n \\sa SDL_SyncWindow"]
    pub fn SDL_SetWindowSize(
        window: *mut SDL_Window,
        w: ::core::ffi::c_int,
        h: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the size of a window's client area.\n\n The window pixel size may differ from its window coordinate size if the\n window is on a high pixel density display. Use SDL_GetWindowSizeInPixels()\n or SDL_GetRenderOutputSize() to get the real client area size in pixels.\n\n \\param window the window to query the width and height from.\n \\param w a pointer filled in with the width of the window, may be NULL.\n \\param h a pointer filled in with the height of the window, may be NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetRenderOutputSize\n \\sa SDL_GetWindowSizeInPixels\n \\sa SDL_SetWindowSize"]
    pub fn SDL_GetWindowSize(
        window: *mut SDL_Window,
        w: *mut ::core::ffi::c_int,
        h: *mut ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the safe area for this window.\n\n Some devices have portions of the screen which are partially obscured or\n not interactive, possibly due to on-screen controls, curved edges, camera\n notches, TV overscan, etc. This function provides the area of the window\n which is safe to have interactable content. You should continue rendering\n into the rest of the window, but it should not contain visually important\n or interactible content.\n\n \\param window the window to query.\n \\param rect a pointer filled in with the client area that is safe for\n             interactive content.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetWindowSafeArea(window: *mut SDL_Window, rect: *mut SDL_Rect) -> bool;
}
unsafe extern "C" {
    #[doc = " Request that the aspect ratio of a window's client area be set.\n\n The aspect ratio is the ratio of width divided by height, e.g. 2560x1600\n would be 1.6. Larger aspect ratios are wider and smaller aspect ratios are\n narrower.\n\n If, at the time of this request, the window in a fixed-size state, such as\n maximized or fullscreen, the request will be deferred until the window\n exits this state and becomes resizable again.\n\n On some windowing systems, this request is asynchronous and the new window\n aspect ratio may not have have been applied immediately upon the return of\n this function. If an immediate change is required, call SDL_SyncWindow() to\n block until the changes have taken effect.\n\n When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be\n emitted with the new window dimensions. Note that the new dimensions may\n not match the exact aspect ratio requested, as some windowing systems can\n restrict the window size in certain scenarios (e.g. constraining the size\n of the content area to remain within the usable desktop bounds).\n Additionally, as this is just a request, it can be denied by the windowing\n system.\n\n \\param window the window to change.\n \\param min_aspect the minimum aspect ratio of the window, or 0.0f for no\n                   limit.\n \\param max_aspect the maximum aspect ratio of the window, or 0.0f for no\n                   limit.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowAspectRatio\n \\sa SDL_SyncWindow"]
    pub fn SDL_SetWindowAspectRatio(
        window: *mut SDL_Window,
        min_aspect: f32,
        max_aspect: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the size of a window's client area.\n\n \\param window the window to query the width and height from.\n \\param min_aspect a pointer filled in with the minimum aspect ratio of the\n                   window, may be NULL.\n \\param max_aspect a pointer filled in with the maximum aspect ratio of the\n                   window, may be NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowAspectRatio"]
    pub fn SDL_GetWindowAspectRatio(
        window: *mut SDL_Window,
        min_aspect: *mut f32,
        max_aspect: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the size of a window's borders (decorations) around the client area.\n\n Note: If this function fails (returns false), the size values will be\n initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the\n window in question was borderless.\n\n Note: This function may fail on systems where the window has not yet been\n decorated by the display server (for example, immediately after calling\n SDL_CreateWindow). It is recommended that you wait at least until the\n window has been presented and composited, so that the window system has a\n chance to decorate the window and provide the border dimensions to SDL.\n\n This function also returns false if getting the information is not\n supported.\n\n \\param window the window to query the size values of the border\n               (decorations) from.\n \\param top pointer to variable for storing the size of the top border; NULL\n            is permitted.\n \\param left pointer to variable for storing the size of the left border;\n             NULL is permitted.\n \\param bottom pointer to variable for storing the size of the bottom\n               border; NULL is permitted.\n \\param right pointer to variable for storing the size of the right border;\n              NULL is permitted.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowSize"]
    pub fn SDL_GetWindowBordersSize(
        window: *mut SDL_Window,
        top: *mut ::core::ffi::c_int,
        left: *mut ::core::ffi::c_int,
        bottom: *mut ::core::ffi::c_int,
        right: *mut ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the size of a window's client area, in pixels.\n\n \\param window the window from which the drawable size should be queried.\n \\param w a pointer to variable for storing the width in pixels, may be\n          NULL.\n \\param h a pointer to variable for storing the height in pixels, may be\n          NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateWindow\n \\sa SDL_GetWindowSize"]
    pub fn SDL_GetWindowSizeInPixels(
        window: *mut SDL_Window,
        w: *mut ::core::ffi::c_int,
        h: *mut ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the minimum size of a window's client area.\n\n \\param window the window to change.\n \\param min_w the minimum width of the window, or 0 for no limit.\n \\param min_h the minimum height of the window, or 0 for no limit.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowMinimumSize\n \\sa SDL_SetWindowMaximumSize"]
    pub fn SDL_SetWindowMinimumSize(
        window: *mut SDL_Window,
        min_w: ::core::ffi::c_int,
        min_h: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the minimum size of a window's client area.\n\n \\param window the window to query.\n \\param w a pointer filled in with the minimum width of the window, may be\n          NULL.\n \\param h a pointer filled in with the minimum height of the window, may be\n          NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowMaximumSize\n \\sa SDL_SetWindowMinimumSize"]
    pub fn SDL_GetWindowMinimumSize(
        window: *mut SDL_Window,
        w: *mut ::core::ffi::c_int,
        h: *mut ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the maximum size of a window's client area.\n\n \\param window the window to change.\n \\param max_w the maximum width of the window, or 0 for no limit.\n \\param max_h the maximum height of the window, or 0 for no limit.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowMaximumSize\n \\sa SDL_SetWindowMinimumSize"]
    pub fn SDL_SetWindowMaximumSize(
        window: *mut SDL_Window,
        max_w: ::core::ffi::c_int,
        max_h: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the maximum size of a window's client area.\n\n \\param window the window to query.\n \\param w a pointer filled in with the maximum width of the window, may be\n          NULL.\n \\param h a pointer filled in with the maximum height of the window, may be\n          NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowMinimumSize\n \\sa SDL_SetWindowMaximumSize"]
    pub fn SDL_GetWindowMaximumSize(
        window: *mut SDL_Window,
        w: *mut ::core::ffi::c_int,
        h: *mut ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the border state of a window.\n\n This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add\n or remove the border from the actual window. This is a no-op if the\n window's border already matches the requested state.\n\n You can't change the border state of a fullscreen window.\n\n \\param window the window of which to change the border state.\n \\param bordered false to remove border, true to add border.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowFlags"]
    pub fn SDL_SetWindowBordered(window: *mut SDL_Window, bordered: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the user-resizable state of a window.\n\n This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and\n allow/disallow user resizing of the window. This is a no-op if the window's\n resizable state already matches the requested state.\n\n You can't change the resizable state of a fullscreen window.\n\n \\param window the window of which to change the resizable state.\n \\param resizable true to allow resizing, false to disallow.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowFlags"]
    pub fn SDL_SetWindowResizable(window: *mut SDL_Window, resizable: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the window to always be above the others.\n\n This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This\n will bring the window to the front and keep the window above the rest.\n\n \\param window the window of which to change the always on top state.\n \\param on_top true to set the window always on top, false to disable.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowFlags"]
    pub fn SDL_SetWindowAlwaysOnTop(window: *mut SDL_Window, on_top: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Show a window.\n\n \\param window the window to show.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_HideWindow\n \\sa SDL_RaiseWindow"]
    pub fn SDL_ShowWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Hide a window.\n\n \\param window the window to hide.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_ShowWindow\n \\sa SDL_WINDOW_HIDDEN"]
    pub fn SDL_HideWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Request that a window be raised above other windows and gain the input\n focus.\n\n The result of this request is subject to desktop window manager policy,\n particularly if raising the requested window would result in stealing focus\n from another application. If the window is successfully raised and gains\n input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and\n the window will have the SDL_WINDOW_INPUT_FOCUS flag set.\n\n \\param window the window to raise.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_RaiseWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Request that the window be made as large as possible.\n\n Non-resizable windows can't be maximized. The window must have the\n SDL_WINDOW_RESIZABLE flag set, or this will have no effect.\n\n On some windowing systems this request is asynchronous and the new window\n state may not have have been applied immediately upon the return of this\n function. If an immediate change is required, call SDL_SyncWindow() to\n block until the changes have taken effect.\n\n When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be\n emitted. Note that, as this is just a request, the windowing system can\n deny the state change.\n\n When maximizing a window, whether the constraints set via\n SDL_SetWindowMaximumSize() are honored depends on the policy of the window\n manager. Win32 and macOS enforce the constraints when maximizing, while X11\n and Wayland window managers may vary.\n\n \\param window the window to maximize.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_MinimizeWindow\n \\sa SDL_RestoreWindow\n \\sa SDL_SyncWindow"]
    pub fn SDL_MaximizeWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Request that the window be minimized to an iconic representation.\n\n If the window is in a fullscreen state, this request has no direct effect.\n It may alter the state the window is returned to when leaving fullscreen.\n\n On some windowing systems this request is asynchronous and the new window\n state may not have been applied immediately upon the return of this\n function. If an immediate change is required, call SDL_SyncWindow() to\n block until the changes have taken effect.\n\n When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be\n emitted. Note that, as this is just a request, the windowing system can\n deny the state change.\n\n \\param window the window to minimize.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_MaximizeWindow\n \\sa SDL_RestoreWindow\n \\sa SDL_SyncWindow"]
    pub fn SDL_MinimizeWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Request that the size and position of a minimized or maximized window be\n restored.\n\n If the window is in a fullscreen state, this request has no direct effect.\n It may alter the state the window is returned to when leaving fullscreen.\n\n On some windowing systems this request is asynchronous and the new window\n state may not have have been applied immediately upon the return of this\n function. If an immediate change is required, call SDL_SyncWindow() to\n block until the changes have taken effect.\n\n When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be\n emitted. Note that, as this is just a request, the windowing system can\n deny the state change.\n\n \\param window the window to restore.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_MaximizeWindow\n \\sa SDL_MinimizeWindow\n \\sa SDL_SyncWindow"]
    pub fn SDL_RestoreWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Request that the window's fullscreen state be changed.\n\n By default a window in fullscreen state uses borderless fullscreen desktop\n mode, but a specific exclusive display mode can be set using\n SDL_SetWindowFullscreenMode().\n\n On some windowing systems this request is asynchronous and the new\n fullscreen state may not have have been applied immediately upon the return\n of this function. If an immediate change is required, call SDL_SyncWindow()\n to block until the changes have taken effect.\n\n When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or\n SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this\n is just a request, it can be denied by the windowing system.\n\n \\param window the window to change.\n \\param fullscreen true for fullscreen mode, false for windowed mode.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowFullscreenMode\n \\sa SDL_SetWindowFullscreenMode\n \\sa SDL_SyncWindow\n \\sa SDL_WINDOW_FULLSCREEN"]
    pub fn SDL_SetWindowFullscreen(window: *mut SDL_Window, fullscreen: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Block until any pending window state is finalized.\n\n On asynchronous windowing systems, this acts as a synchronization barrier\n for pending window state. It will attempt to wait until any pending window\n state has been applied and is guaranteed to return within finite time. Note\n that for how long it can potentially block depends on the underlying window\n system, as window state changes may involve somewhat lengthy animations\n that must complete before the window is in its final requested state.\n\n On windowing systems where changes are immediate, this does nothing.\n\n \\param window the window for which to wait for the pending state to be\n               applied.\n \\returns true on success or false if the operation timed out before the\n          window was in the requested state.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowSize\n \\sa SDL_SetWindowPosition\n \\sa SDL_SetWindowFullscreen\n \\sa SDL_MinimizeWindow\n \\sa SDL_MaximizeWindow\n \\sa SDL_RestoreWindow\n \\sa SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS"]
    pub fn SDL_SyncWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Return whether the window has a surface associated with it.\n\n \\param window the window to query.\n \\returns true if there is a surface associated with the window, or false\n          otherwise.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowSurface"]
    pub fn SDL_WindowHasSurface(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the SDL surface associated with the window.\n\n A new surface will be created with the optimal format for the window, if\n necessary. This surface will be freed when the window is destroyed. Do not\n free this surface.\n\n This surface will be invalidated if the window is resized. After resizing a\n window this function must be called again to return a valid surface.\n\n You may not combine this with 3D or the rendering API on this window.\n\n This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.\n\n \\param window the window to query.\n \\returns the surface associated with the window, or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DestroyWindowSurface\n \\sa SDL_WindowHasSurface\n \\sa SDL_UpdateWindowSurface\n \\sa SDL_UpdateWindowSurfaceRects"]
    pub fn SDL_GetWindowSurface(window: *mut SDL_Window) -> *mut SDL_Surface;
}
unsafe extern "C" {
    #[doc = " Toggle VSync for the window surface.\n\n When a window surface is created, vsync defaults to\n SDL_WINDOW_SURFACE_VSYNC_DISABLED.\n\n The `vsync` parameter can be 1 to synchronize present with every vertical\n refresh, 2 to synchronize present with every second vertical refresh, etc.,\n SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),\n or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is\n supported by every driver, so you should check the return value to see\n whether the requested setting is supported.\n\n \\param window the window.\n \\param vsync the vertical refresh sync interval.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowSurfaceVSync"]
    pub fn SDL_SetWindowSurfaceVSync(window: *mut SDL_Window, vsync: ::core::ffi::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = " Get VSync for the window surface.\n\n \\param window the window to query.\n \\param vsync an int filled with the current vertical refresh sync interval.\n              See SDL_SetWindowSurfaceVSync() for the meaning of the value.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowSurfaceVSync"]
    pub fn SDL_GetWindowSurfaceVSync(
        window: *mut SDL_Window,
        vsync: *mut ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Copy the window surface to the screen.\n\n This is the function you use to reflect any changes to the surface on the\n screen.\n\n This function is equivalent to the SDL 1.2 API SDL_Flip().\n\n \\param window the window to update.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowSurface\n \\sa SDL_UpdateWindowSurfaceRects"]
    pub fn SDL_UpdateWindowSurface(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Copy areas of the window surface to the screen.\n\n This is the function you use to reflect changes to portions of the surface\n on the screen.\n\n This function is equivalent to the SDL 1.2 API SDL_UpdateRects().\n\n Note that this function will update _at least_ the rectangles specified,\n but this is only intended as an optimization; in practice, this might\n update more of the screen (or all of the screen!), depending on what method\n SDL uses to send pixels to the system.\n\n \\param window the window to update.\n \\param rects an array of SDL_Rect structures representing areas of the\n              surface to copy, in pixels.\n \\param numrects the number of rectangles.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowSurface\n \\sa SDL_UpdateWindowSurface"]
    pub fn SDL_UpdateWindowSurfaceRects(
        window: *mut SDL_Window,
        rects: *const SDL_Rect,
        numrects: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Destroy the surface associated with the window.\n\n \\param window the window to update.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowSurface\n \\sa SDL_WindowHasSurface"]
    pub fn SDL_DestroyWindowSurface(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Set a window's keyboard grab mode.\n\n Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or\n the Meta/Super key. Note that not all system keyboard shortcuts can be\n captured by applications (one example is Ctrl+Alt+Del on Windows).\n\n This is primarily intended for specialized applications such as VNC clients\n or VM frontends. Normal games should not use keyboard grab.\n\n When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the\n window is full-screen to ensure the user is not trapped in your\n application. If you have a custom keyboard shortcut to exit fullscreen\n mode, you may suppress this behavior with\n `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.\n\n If the caller enables a grab while another window is currently grabbed, the\n other window loses its grab in favor of the caller's window.\n\n \\param window the window for which the keyboard grab mode should be set.\n \\param grabbed this is true to grab keyboard, and false to release.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowKeyboardGrab\n \\sa SDL_SetWindowMouseGrab"]
    pub fn SDL_SetWindowKeyboardGrab(window: *mut SDL_Window, grabbed: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Set a window's mouse grab mode.\n\n Mouse grab confines the mouse cursor to the window.\n\n \\param window the window for which the mouse grab mode should be set.\n \\param grabbed this is true to grab mouse, and false to release.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowMouseRect\n \\sa SDL_SetWindowMouseRect\n \\sa SDL_SetWindowMouseGrab\n \\sa SDL_SetWindowKeyboardGrab"]
    pub fn SDL_SetWindowMouseGrab(window: *mut SDL_Window, grabbed: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Get a window's keyboard grab mode.\n\n \\param window the window to query.\n \\returns true if keyboard is grabbed, and false otherwise.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowKeyboardGrab"]
    pub fn SDL_GetWindowKeyboardGrab(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Get a window's mouse grab mode.\n\n \\param window the window to query.\n \\returns true if mouse is grabbed, and false otherwise.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowMouseRect\n \\sa SDL_SetWindowMouseRect\n \\sa SDL_SetWindowMouseGrab\n \\sa SDL_SetWindowKeyboardGrab"]
    pub fn SDL_GetWindowMouseGrab(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the window that currently has an input grab enabled.\n\n \\returns the window if input is grabbed or NULL otherwise.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowMouseGrab\n \\sa SDL_SetWindowKeyboardGrab"]
    pub fn SDL_GetGrabbedWindow() -> *mut SDL_Window;
}
unsafe extern "C" {
    #[doc = " Confines the cursor to the specified area of a window.\n\n Note that this does NOT grab the cursor, it only defines the area a cursor\n is restricted to when the window has mouse focus.\n\n \\param window the window that will be associated with the barrier.\n \\param rect a rectangle area in window-relative coordinates. If NULL the\n             barrier for the specified window will be destroyed.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowMouseRect\n \\sa SDL_GetWindowMouseGrab\n \\sa SDL_SetWindowMouseGrab"]
    pub fn SDL_SetWindowMouseRect(window: *mut SDL_Window, rect: *const SDL_Rect) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the mouse confinement rectangle of a window.\n\n \\param window the window to query.\n \\returns a pointer to the mouse confinement rectangle of a window, or NULL\n          if there isn't one.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowMouseRect\n \\sa SDL_GetWindowMouseGrab\n \\sa SDL_SetWindowMouseGrab"]
    pub fn SDL_GetWindowMouseRect(window: *mut SDL_Window) -> *const SDL_Rect;
}
unsafe extern "C" {
    #[doc = " Set the opacity for a window.\n\n The parameter `opacity` will be clamped internally between 0.0f\n (transparent) and 1.0f (opaque).\n\n This function also returns false if setting the opacity isn't supported.\n\n \\param window the window which will be made transparent or opaque.\n \\param opacity the opacity value (0.0f - transparent, 1.0f - opaque).\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowOpacity"]
    pub fn SDL_SetWindowOpacity(window: *mut SDL_Window, opacity: f32) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the opacity of a window.\n\n If transparency isn't supported on this platform, opacity will be returned\n as 1.0f without error.\n\n \\param window the window to get the current opacity value from.\n \\returns the opacity, (0.0f - transparent, 1.0f - opaque), or -1.0f on\n          failure; call SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowOpacity"]
    pub fn SDL_GetWindowOpacity(window: *mut SDL_Window) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the window as a child of a parent window.\n\n If the window is already the child of an existing window, it will be\n reparented to the new owner. Setting the parent window to NULL unparents\n the window and removes child window status.\n\n If a parent window is hidden or destroyed, the operation will be\n recursively applied to child windows. Child windows hidden with the parent\n that did not have their hidden status explicitly set will be restored when\n the parent is shown.\n\n Attempting to set the parent of a window that is currently in the modal\n state will fail. Use SDL_SetWindowModal() to cancel the modal status before\n attempting to change the parent.\n\n Popup windows cannot change parents and attempts to do so will fail.\n\n Setting a parent window that is currently the sibling or descendent of the\n child window results in undefined behavior.\n\n \\param window the window that should become the child of a parent.\n \\param parent the new parent window for the child window.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowModal"]
    pub fn SDL_SetWindowParent(window: *mut SDL_Window, parent: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Toggle the state of the window as modal.\n\n To enable modal status on a window, the window must currently be the child\n window of a parent, or toggling modal status on will fail.\n\n \\param window the window on which to set the modal state.\n \\param modal true to toggle modal status on, false to toggle it off.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowParent\n \\sa SDL_WINDOW_MODAL"]
    pub fn SDL_SetWindowModal(window: *mut SDL_Window, modal: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Set whether the window may have input focus.\n\n \\param window the window to set focusable state.\n \\param focusable true to allow input focus, false to not allow input focus.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetWindowFocusable(window: *mut SDL_Window, focusable: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Display the system-level window menu.\n\n This default window menu is provided by the system and on some platforms\n provides functionality for setting or changing privileged state on the\n window, such as moving it between workspaces or displays, or toggling the\n always-on-top property.\n\n On platforms or desktops where this is unsupported, this function does\n nothing.\n\n \\param window the window for which the menu will be displayed.\n \\param x the x coordinate of the menu, relative to the origin (top-left) of\n          the client area.\n \\param y the y coordinate of the menu, relative to the origin (top-left) of\n          the client area.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_ShowWindowSystemMenu(
        window: *mut SDL_Window,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> bool;
}
#[doc = "< Region is normal. No special properties."]
pub const SDL_HitTestResult_SDL_HITTEST_NORMAL: SDL_HitTestResult = 0;
#[doc = "< Region can drag entire window."]
pub const SDL_HitTestResult_SDL_HITTEST_DRAGGABLE: SDL_HitTestResult = 1;
#[doc = "< Region is the resizable top-left corner border."]
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_TOPLEFT: SDL_HitTestResult = 2;
#[doc = "< Region is the resizable top border."]
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_TOP: SDL_HitTestResult = 3;
#[doc = "< Region is the resizable top-right corner border."]
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_TOPRIGHT: SDL_HitTestResult = 4;
#[doc = "< Region is the resizable right border."]
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_RIGHT: SDL_HitTestResult = 5;
#[doc = "< Region is the resizable bottom-right corner border."]
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_BOTTOMRIGHT: SDL_HitTestResult = 6;
#[doc = "< Region is the resizable bottom border."]
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_BOTTOM: SDL_HitTestResult = 7;
#[doc = "< Region is the resizable bottom-left corner border."]
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_BOTTOMLEFT: SDL_HitTestResult = 8;
#[doc = "< Region is the resizable left border."]
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_LEFT: SDL_HitTestResult = 9;
#[doc = " Possible return values from the SDL_HitTest callback.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This enum is available since SDL 3.2.0.\n\n \\sa SDL_HitTest"]
pub type SDL_HitTestResult = ::core::ffi::c_uint;
#[doc = " Callback used for hit-testing.\n\n \\param win the SDL_Window where hit-testing was set on.\n \\param area an SDL_Point which should be hit-tested.\n \\param data what was passed as `callback_data` to SDL_SetWindowHitTest().\n \\returns an SDL_HitTestResult value.\n\n \\sa SDL_SetWindowHitTest"]
pub type SDL_HitTest = ::core::option::Option<
    unsafe extern "C" fn(
        win: *mut SDL_Window,
        area: *const SDL_Point,
        data: *mut ::core::ffi::c_void,
    ) -> SDL_HitTestResult,
>;
unsafe extern "C" {
    #[doc = " Provide a callback that decides if a window region has special properties.\n\n Normally windows are dragged and resized by decorations provided by the\n system window manager (a title bar, borders, etc), but for some apps, it\n makes sense to drag them from somewhere else inside the window itself; for\n example, one might have a borderless window that wants to be draggable from\n any part, or simulate its own title bar, etc.\n\n This function lets the app provide a callback that designates pieces of a\n given window as special. This callback is run during event processing if we\n need to tell the OS to treat a region of the window specially; the use of\n this callback is known as \"hit testing.\"\n\n Mouse input may not be delivered to your application if it is within a\n special area; the OS will often apply that input to moving the window or\n resizing the window and not deliver it to the application.\n\n Specifying NULL for a callback disables hit-testing. Hit-testing is\n disabled by default.\n\n Platforms that don't support this functionality will return false\n unconditionally, even if you're attempting to disable hit-testing.\n\n Your callback may fire at any time, and its firing does not indicate any\n specific behavior (for example, on Windows, this certainly might fire when\n the OS is deciding whether to drag your window, but it fires for lots of\n other reasons, too, some unrelated to anything you probably care about _and\n when the mouse isn't actually at the location it is testing_). Since this\n can fire at any time, you should try to keep your callback efficient,\n devoid of allocations, etc.\n\n \\param window the window to set hit-testing on.\n \\param callback the function to call when doing a hit-test.\n \\param callback_data an app-defined void pointer passed to **callback**.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetWindowHitTest(
        window: *mut SDL_Window,
        callback: SDL_HitTest,
        callback_data: *mut ::core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the shape of a transparent window.\n\n This sets the alpha channel of a transparent window and any fully\n transparent areas are also transparent to mouse clicks. If you are using\n something besides the SDL render API, then you are responsible for drawing\n the alpha channel of the window to match the shape alpha channel to get\n consistent cross-platform results.\n\n The shape is copied inside this function, so you can free it afterwards. If\n your shape surface changes, you should call SDL_SetWindowShape() again to\n update the window. This is an expensive operation, so should be done\n sparingly.\n\n The window must have been created with the SDL_WINDOW_TRANSPARENT flag.\n\n \\param window the window.\n \\param shape the surface representing the shape of the window, or NULL to\n              remove any current shape.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_SetWindowShape(window: *mut SDL_Window, shape: *mut SDL_Surface) -> bool;
}
unsafe extern "C" {
    #[doc = " Request a window to demand attention from the user.\n\n \\param window the window to be flashed.\n \\param operation the operation to perform.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_FlashWindow(window: *mut SDL_Window, operation: SDL_FlashOperation) -> bool;
}
unsafe extern "C" {
    #[doc = " Destroy a window.\n\n Any child windows owned by the window will be recursively destroyed as\n well.\n\n Note that on some platforms, the visible window may not actually be removed\n from the screen until the SDL event loop is pumped again, even though the\n SDL_Window is no longer valid after this call.\n\n \\param window the window to destroy.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreatePopupWindow\n \\sa SDL_CreateWindow\n \\sa SDL_CreateWindowWithProperties"]
    pub fn SDL_DestroyWindow(window: *mut SDL_Window);
}
unsafe extern "C" {
    #[doc = " Check whether the screensaver is currently enabled.\n\n The screensaver is disabled by default.\n\n The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.\n\n \\returns true if the screensaver is enabled, false if it is disabled.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DisableScreenSaver\n \\sa SDL_EnableScreenSaver"]
    pub fn SDL_ScreenSaverEnabled() -> bool;
}
unsafe extern "C" {
    #[doc = " Allow the screen to be blanked by a screen saver.\n\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DisableScreenSaver\n \\sa SDL_ScreenSaverEnabled"]
    pub fn SDL_EnableScreenSaver() -> bool;
}
unsafe extern "C" {
    #[doc = " Prevent the screen from being blanked by a screen saver.\n\n If you disable the screensaver, it is automatically re-enabled when SDL\n quits.\n\n The screensaver is disabled by default, but this may by changed by\n SDL_HINT_VIDEO_ALLOW_SCREENSAVER.\n\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_EnableScreenSaver\n \\sa SDL_ScreenSaverEnabled"]
    pub fn SDL_DisableScreenSaver() -> bool;
}
unsafe extern "C" {
    #[doc = " Dynamically load an OpenGL library.\n\n This should be done after initializing the video driver, but before\n creating any OpenGL windows. If no OpenGL library is loaded, the default\n library will be loaded upon creation of the first OpenGL window.\n\n If you do this, you need to retrieve all of the GL functions used in your\n program from the dynamic library using SDL_GL_GetProcAddress().\n\n \\param path the platform dependent OpenGL library name, or NULL to open the\n             default OpenGL library.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GL_GetProcAddress\n \\sa SDL_GL_UnloadLibrary"]
    pub fn SDL_GL_LoadLibrary(path: *const ::core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Get an OpenGL function by name.\n\n If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all\n GL functions must be retrieved this way. Usually this is used to retrieve\n function pointers to OpenGL extensions.\n\n There are some quirks to looking up OpenGL functions that require some\n extra care from the application. If you code carefully, you can handle\n these quirks without any platform-specific code, though:\n\n - On Windows, function pointers are specific to the current GL context;\n   this means you need to have created a GL context and made it current\n   before calling SDL_GL_GetProcAddress(). If you recreate your context or\n   create a second context, you should assume that any existing function\n   pointers aren't valid to use with it. This is (currently) a\n   Windows-specific limitation, and in practice lots of drivers don't suffer\n   this limitation, but it is still the way the wgl API is documented to\n   work and you should expect crashes if you don't respect it. Store a copy\n   of the function pointers that comes and goes with context lifespan.\n - On X11, function pointers returned by this function are valid for any\n   context, and can even be looked up before a context is created at all.\n   This means that, for at least some common OpenGL implementations, if you\n   look up a function that doesn't exist, you'll get a non-NULL result that\n   is _NOT_ safe to call. You must always make sure the function is actually\n   available for a given GL context before calling it, by checking for the\n   existence of the appropriate extension with SDL_GL_ExtensionSupported(),\n   or verifying that the version of OpenGL you're using offers the function\n   as core functionality.\n - Some OpenGL drivers, on all platforms, *will* return NULL if a function\n   isn't supported, but you can't count on this behavior. Check for\n   extensions you use, and if you get a NULL anyway, act as if that\n   extension wasn't available. This is probably a bug in the driver, but you\n   can code defensively for this scenario anyhow.\n - Just because you're on Linux/Unix, don't assume you'll be using X11.\n   Next-gen display servers are waiting to replace it, and may or may not\n   make the same promises about function pointers.\n - OpenGL function pointers must be declared `APIENTRY` as in the example\n   code. This will ensure the proper calling convention is followed on\n   platforms where this matters (Win32) thereby avoiding stack corruption.\n\n \\param proc the name of an OpenGL function.\n \\returns a pointer to the named OpenGL function. The returned pointer\n          should be cast to the appropriate function signature.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GL_ExtensionSupported\n \\sa SDL_GL_LoadLibrary\n \\sa SDL_GL_UnloadLibrary"]
    pub fn SDL_GL_GetProcAddress(proc_: *const ::core::ffi::c_char) -> SDL_FunctionPointer;
}
unsafe extern "C" {
    #[doc = " Get an EGL library function by name.\n\n If an EGL library is loaded, this function allows applications to get entry\n points for EGL functions. This is useful to provide to an EGL API and\n extension loader.\n\n \\param proc the name of an EGL function.\n \\returns a pointer to the named EGL function. The returned pointer should\n          be cast to the appropriate function signature.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_EGL_GetCurrentDisplay"]
    pub fn SDL_EGL_GetProcAddress(proc_: *const ::core::ffi::c_char) -> SDL_FunctionPointer;
}
unsafe extern "C" {
    #[doc = " Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GL_LoadLibrary"]
    pub fn SDL_GL_UnloadLibrary();
}
unsafe extern "C" {
    #[doc = " Check if an OpenGL extension is supported for the current context.\n\n This function operates on the current GL context; you must have created a\n context and it must be current before calling this function. Do not assume\n that all contexts you create will have the same set of extensions\n available, or that recreating an existing context will offer the same\n extensions again.\n\n While it's probably not a massive overhead, this function is not an O(1)\n operation. Check the extensions you care about after creating the GL\n context and save that information somewhere instead of calling the function\n every time you need to know.\n\n \\param extension the name of the extension to check.\n \\returns true if the extension is supported, false otherwise.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GL_ExtensionSupported(extension: *const ::core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Reset all previously set OpenGL context attributes to their default values.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GL_GetAttribute\n \\sa SDL_GL_SetAttribute"]
    pub fn SDL_GL_ResetAttributes();
}
unsafe extern "C" {
    #[doc = " Set an OpenGL window attribute before window creation.\n\n This function sets the OpenGL attribute `attr` to `value`. The requested\n attributes should be set before creating an OpenGL window. You should use\n SDL_GL_GetAttribute() to check the values after creating the OpenGL\n context, since the values obtained can differ from the requested ones.\n\n \\param attr an SDL_GLAttr enum value specifying the OpenGL attribute to\n             set.\n \\param value the desired value for the attribute.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GL_GetAttribute\n \\sa SDL_GL_ResetAttributes"]
    pub fn SDL_GL_SetAttribute(attr: SDL_GLAttr, value: ::core::ffi::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the actual value for an attribute from the current context.\n\n \\param attr an SDL_GLAttr enum value specifying the OpenGL attribute to\n             get.\n \\param value a pointer filled in with the current value of `attr`.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GL_ResetAttributes\n \\sa SDL_GL_SetAttribute"]
    pub fn SDL_GL_GetAttribute(attr: SDL_GLAttr, value: *mut ::core::ffi::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = " Create an OpenGL context for an OpenGL window, and make it current.\n\n Windows users new to OpenGL should note that, for historical reasons, GL\n functions added after OpenGL version 1.1 are not available by default.\n Those functions must be loaded at run-time, either with an OpenGL\n extension-handling library or with SDL_GL_GetProcAddress() and its related\n functions.\n\n SDL_GLContext is opaque to the application.\n\n \\param window the window to associate with the context.\n \\returns the OpenGL context associated with `window` or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GL_DestroyContext\n \\sa SDL_GL_MakeCurrent"]
    pub fn SDL_GL_CreateContext(window: *mut SDL_Window) -> SDL_GLContext;
}
unsafe extern "C" {
    #[doc = " Set up an OpenGL context for rendering into an OpenGL window.\n\n The context must have been created with a compatible window.\n\n \\param window the window to associate with the context.\n \\param context the OpenGL context to associate with the window.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GL_CreateContext"]
    pub fn SDL_GL_MakeCurrent(window: *mut SDL_Window, context: SDL_GLContext) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the currently active OpenGL window.\n\n \\returns the currently active OpenGL window on success or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GL_GetCurrentWindow() -> *mut SDL_Window;
}
unsafe extern "C" {
    #[doc = " Get the currently active OpenGL context.\n\n \\returns the currently active OpenGL context or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GL_MakeCurrent"]
    pub fn SDL_GL_GetCurrentContext() -> SDL_GLContext;
}
unsafe extern "C" {
    #[doc = " Get the currently active EGL display.\n\n \\returns the currently active EGL display or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_EGL_GetCurrentDisplay() -> SDL_EGLDisplay;
}
unsafe extern "C" {
    #[doc = " Get the currently active EGL config.\n\n \\returns the currently active EGL config or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_EGL_GetCurrentConfig() -> SDL_EGLConfig;
}
unsafe extern "C" {
    #[doc = " Get the EGL surface associated with the window.\n\n \\param window the window to query.\n \\returns the EGLSurface pointer associated with the window, or NULL on\n          failure.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_EGL_GetWindowSurface(window: *mut SDL_Window) -> SDL_EGLSurface;
}
unsafe extern "C" {
    #[doc = " Sets the callbacks for defining custom EGLAttrib arrays for EGL\n initialization.\n\n Callbacks that aren't needed can be set to NULL.\n\n NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.\n\n \\param platformAttribCallback callback for attributes to pass to\n                               eglGetPlatformDisplay. May be NULL.\n \\param surfaceAttribCallback callback for attributes to pass to\n                              eglCreateSurface. May be NULL.\n \\param contextAttribCallback callback for attributes to pass to\n                              eglCreateContext. May be NULL.\n \\param userdata a pointer that is passed to the callbacks.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_EGL_SetAttributeCallbacks(
        platformAttribCallback: SDL_EGLAttribArrayCallback,
        surfaceAttribCallback: SDL_EGLIntArrayCallback,
        contextAttribCallback: SDL_EGLIntArrayCallback,
        userdata: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Set the swap interval for the current OpenGL context.\n\n Some systems allow specifying -1 for the interval, to enable adaptive\n vsync. Adaptive vsync works the same as vsync, but if you've already missed\n the vertical retrace for a given frame, it swaps buffers immediately, which\n might be less jarring for the user during occasional framerate drops. If an\n application requests adaptive vsync and the system does not support it,\n this function will fail and return false. In such a case, you should\n probably retry the call with 1 for the interval.\n\n Adaptive vsync is implemented for some glX drivers with\n GLX_EXT_swap_control_tear, and for some Windows drivers with\n WGL_EXT_swap_control_tear.\n\n Read more on the Khronos wiki:\n https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync\n\n \\param interval 0 for immediate updates, 1 for updates synchronized with\n                 the vertical retrace, -1 for adaptive vsync.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GL_GetSwapInterval"]
    pub fn SDL_GL_SetSwapInterval(interval: ::core::ffi::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the swap interval for the current OpenGL context.\n\n If the system can't determine the swap interval, or there isn't a valid\n current context, this function will set *interval to 0 as a safe default.\n\n \\param interval output interval value. 0 if there is no vertical retrace\n                 synchronization, 1 if the buffer swap is synchronized with\n                 the vertical retrace, and -1 if late swaps happen\n                 immediately instead of waiting for the next retrace.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GL_SetSwapInterval"]
    pub fn SDL_GL_GetSwapInterval(interval: *mut ::core::ffi::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = " Update a window with OpenGL rendering.\n\n This is used with double-buffered OpenGL contexts, which are the default.\n\n On macOS, make sure you bind 0 to the draw framebuffer before swapping the\n window, otherwise nothing will happen. If you aren't using\n glBindFramebuffer(), this is the default and you won't have to do anything\n extra.\n\n \\param window the window to change.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GL_SwapWindow(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Delete an OpenGL context.\n\n \\param context the OpenGL context to be deleted.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GL_CreateContext"]
    pub fn SDL_GL_DestroyContext(context: SDL_GLContext) -> bool;
}
#[doc = " This is a unique ID for a keyboard for the time it is connected to the\n system, and is never reused for the lifetime of the application.\n\n If the keyboard is disconnected and reconnected, it will get a new ID.\n\n The value 0 is an invalid ID.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_KeyboardID = Uint32;
unsafe extern "C" {
    #[doc = " Return whether a keyboard is currently connected.\n\n \\returns true if a keyboard is connected, false otherwise.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetKeyboards"]
    pub fn SDL_HasKeyboard() -> bool;
}
unsafe extern "C" {
    #[doc = " Get a list of currently connected keyboards.\n\n Note that this will include any device or virtual driver that includes\n keyboard functionality, including some mice, KVM switches, motherboard\n power buttons, etc. You should wait for input from a device before you\n consider it actively in use.\n\n \\param count a pointer filled in with the number of keyboards returned, may\n              be NULL.\n \\returns a 0 terminated array of keyboards instance IDs or NULL on failure;\n          call SDL_GetError() for more information. This should be freed\n          with SDL_free() when it is no longer needed.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetKeyboardNameForID\n \\sa SDL_HasKeyboard"]
    pub fn SDL_GetKeyboards(count: *mut ::core::ffi::c_int) -> *mut SDL_KeyboardID;
}
unsafe extern "C" {
    #[doc = " Get the name of a keyboard.\n\n This function returns \"\" if the keyboard doesn't have a name.\n\n \\param instance_id the keyboard instance ID.\n \\returns the name of the selected keyboard or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetKeyboards"]
    pub fn SDL_GetKeyboardNameForID(instance_id: SDL_KeyboardID) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Query the window which currently has keyboard focus.\n\n \\returns the window with keyboard focus.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetKeyboardFocus() -> *mut SDL_Window;
}
unsafe extern "C" {
    #[doc = " Get a snapshot of the current state of the keyboard.\n\n The pointer returned is a pointer to an internal SDL array. It will be\n valid for the whole lifetime of the application and should not be freed by\n the caller.\n\n A array element with a value of true means that the key is pressed and a\n value of false means that it is not. Indexes into this array are obtained\n by using SDL_Scancode values.\n\n Use SDL_PumpEvents() to update the state array.\n\n This function gives you the current state after all events have been\n processed, so if a key or button has been pressed and released before you\n process events, then the pressed state will never show up in the\n SDL_GetKeyboardState() calls.\n\n Note: This function doesn't take into account whether shift has been\n pressed or not.\n\n \\param numkeys if non-NULL, receives the length of the returned array.\n \\returns a pointer to an array of key states.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PumpEvents\n \\sa SDL_ResetKeyboard"]
    pub fn SDL_GetKeyboardState(numkeys: *mut ::core::ffi::c_int) -> *const bool;
}
unsafe extern "C" {
    #[doc = " Clear the state of the keyboard.\n\n This function will generate key up events for all pressed keys.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetKeyboardState"]
    pub fn SDL_ResetKeyboard();
}
unsafe extern "C" {
    #[doc = " Get the current key modifier state for the keyboard.\n\n \\returns an OR'd combination of the modifier keys for the keyboard. See\n          SDL_Keymod for details.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetKeyboardState\n \\sa SDL_SetModState"]
    pub fn SDL_GetModState() -> SDL_Keymod;
}
unsafe extern "C" {
    #[doc = " Set the current key modifier state for the keyboard.\n\n The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose\n modifier key states on your application. Simply pass your desired modifier\n states into `modstate`. This value may be a bitwise, OR'd combination of\n SDL_Keymod values.\n\n This does not change the keyboard state, only the key modifier flags that\n SDL reports.\n\n \\param modstate the desired SDL_Keymod for the keyboard.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetModState"]
    pub fn SDL_SetModState(modstate: SDL_Keymod);
}
unsafe extern "C" {
    #[doc = " Get the key code corresponding to the given scancode according to the\n current keyboard layout.\n\n If you want to get the keycode as it would be delivered in key events,\n including options specified in SDL_HINT_KEYCODE_OPTIONS, then you should\n pass `key_event` as true. Otherwise this function simply translates the\n scancode based on the given modifier state.\n\n \\param scancode the desired SDL_Scancode to query.\n \\param modstate the modifier state to use when translating the scancode to\n                 a keycode.\n \\param key_event true if the keycode will be used in key events.\n \\returns the SDL_Keycode that corresponds to the given SDL_Scancode.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetKeyName\n \\sa SDL_GetScancodeFromKey"]
    pub fn SDL_GetKeyFromScancode(
        scancode: SDL_Scancode,
        modstate: SDL_Keymod,
        key_event: bool,
    ) -> SDL_Keycode;
}
unsafe extern "C" {
    #[doc = " Get the scancode corresponding to the given key code according to the\n current keyboard layout.\n\n Note that there may be multiple scancode+modifier states that can generate\n this keycode, this will just return the first one found.\n\n \\param key the desired SDL_Keycode to query.\n \\param modstate a pointer to the modifier state that would be used when the\n                 scancode generates this key, may be NULL.\n \\returns the SDL_Scancode that corresponds to the given SDL_Keycode.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetKeyFromScancode\n \\sa SDL_GetScancodeName"]
    pub fn SDL_GetScancodeFromKey(key: SDL_Keycode, modstate: *mut SDL_Keymod) -> SDL_Scancode;
}
unsafe extern "C" {
    #[doc = " Set a human-readable name for a scancode.\n\n \\param scancode the desired SDL_Scancode.\n \\param name the name to use for the scancode, encoded as UTF-8. The string\n             is not copied, so the pointer given to this function must stay\n             valid while SDL is being used.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetScancodeName"]
    pub fn SDL_SetScancodeName(scancode: SDL_Scancode, name: *const ::core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Get a human-readable name for a scancode.\n\n **Warning**: The returned name is by design not stable across platforms,\n e.g. the name for `SDL_SCANCODE_LGUI` is \"Left GUI\" under Linux but \"Left\n Windows\" under Microsoft Windows, and some scancodes like\n `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even\n scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and\n `SDL_SCANCODE_RETURN2` (both called \"Return\"). This function is therefore\n unsuitable for creating a stable cross-platform two-way mapping between\n strings and scancodes.\n\n \\param scancode the desired SDL_Scancode to query.\n \\returns a pointer to the name for the scancode. If the scancode doesn't\n          have a name this function returns an empty string (\"\").\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetScancodeFromKey\n \\sa SDL_GetScancodeFromName\n \\sa SDL_SetScancodeName"]
    pub fn SDL_GetScancodeName(scancode: SDL_Scancode) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get a scancode from a human-readable name.\n\n \\param name the human-readable scancode name.\n \\returns the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't\n          recognized; call SDL_GetError() for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetKeyFromName\n \\sa SDL_GetScancodeFromKey\n \\sa SDL_GetScancodeName"]
    pub fn SDL_GetScancodeFromName(name: *const ::core::ffi::c_char) -> SDL_Scancode;
}
unsafe extern "C" {
    #[doc = " Get a human-readable name for a key.\n\n If the key doesn't have a name, this function returns an empty string (\"\").\n\n Letters will be presented in their uppercase form, if applicable.\n\n \\param key the desired SDL_Keycode to query.\n \\returns a UTF-8 encoded string of the key name.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetKeyFromName\n \\sa SDL_GetKeyFromScancode\n \\sa SDL_GetScancodeFromKey"]
    pub fn SDL_GetKeyName(key: SDL_Keycode) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get a key code from a human-readable name.\n\n \\param name the human-readable key name.\n \\returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function is not thread safe.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetKeyFromScancode\n \\sa SDL_GetKeyName\n \\sa SDL_GetScancodeFromName"]
    pub fn SDL_GetKeyFromName(name: *const ::core::ffi::c_char) -> SDL_Keycode;
}
unsafe extern "C" {
    #[doc = " Start accepting Unicode text input events in a window.\n\n This function will enable text input (SDL_EVENT_TEXT_INPUT and\n SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this\n function paired with SDL_StopTextInput().\n\n Text input events are not received by default.\n\n On some platforms using this function shows the screen keyboard and/or\n activates an IME, which can prevent some key press events from being passed\n through.\n\n \\param window the window to enable text input.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetTextInputArea\n \\sa SDL_StartTextInputWithProperties\n \\sa SDL_StopTextInput\n \\sa SDL_TextInputActive"]
    pub fn SDL_StartTextInput(window: *mut SDL_Window) -> bool;
}
#[doc = "< The input is text"]
pub const SDL_TextInputType_SDL_TEXTINPUT_TYPE_TEXT: SDL_TextInputType = 0;
#[doc = "< The input is a person's name"]
pub const SDL_TextInputType_SDL_TEXTINPUT_TYPE_TEXT_NAME: SDL_TextInputType = 1;
#[doc = "< The input is an e-mail address"]
pub const SDL_TextInputType_SDL_TEXTINPUT_TYPE_TEXT_EMAIL: SDL_TextInputType = 2;
#[doc = "< The input is a username"]
pub const SDL_TextInputType_SDL_TEXTINPUT_TYPE_TEXT_USERNAME: SDL_TextInputType = 3;
#[doc = "< The input is a secure password that is hidden"]
pub const SDL_TextInputType_SDL_TEXTINPUT_TYPE_TEXT_PASSWORD_HIDDEN: SDL_TextInputType = 4;
#[doc = "< The input is a secure password that is visible"]
pub const SDL_TextInputType_SDL_TEXTINPUT_TYPE_TEXT_PASSWORD_VISIBLE: SDL_TextInputType = 5;
#[doc = "< The input is a number"]
pub const SDL_TextInputType_SDL_TEXTINPUT_TYPE_NUMBER: SDL_TextInputType = 6;
#[doc = "< The input is a secure PIN that is hidden"]
pub const SDL_TextInputType_SDL_TEXTINPUT_TYPE_NUMBER_PASSWORD_HIDDEN: SDL_TextInputType = 7;
#[doc = "< The input is a secure PIN that is visible"]
pub const SDL_TextInputType_SDL_TEXTINPUT_TYPE_NUMBER_PASSWORD_VISIBLE: SDL_TextInputType = 8;
#[doc = " Text input type.\n\n These are the valid values for SDL_PROP_TEXTINPUT_TYPE_NUMBER. Not every\n value is valid on every platform, but where a value isn't supported, a\n reasonable fallback will be used.\n\n \\since This enum is available since SDL 3.2.0.\n\n \\sa SDL_StartTextInputWithProperties"]
pub type SDL_TextInputType = ::core::ffi::c_uint;
#[doc = "< No auto-capitalization will be done"]
pub const SDL_Capitalization_SDL_CAPITALIZE_NONE: SDL_Capitalization = 0;
#[doc = "< The first letter of sentences will be capitalized"]
pub const SDL_Capitalization_SDL_CAPITALIZE_SENTENCES: SDL_Capitalization = 1;
#[doc = "< The first letter of words will be capitalized"]
pub const SDL_Capitalization_SDL_CAPITALIZE_WORDS: SDL_Capitalization = 2;
#[doc = "< All letters will be capitalized"]
pub const SDL_Capitalization_SDL_CAPITALIZE_LETTERS: SDL_Capitalization = 3;
#[doc = " Auto capitalization type.\n\n These are the valid values for SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER.\n Not every value is valid on every platform, but where a value isn't\n supported, a reasonable fallback will be used.\n\n \\since This enum is available since SDL 3.2.0.\n\n \\sa SDL_StartTextInputWithProperties"]
pub type SDL_Capitalization = ::core::ffi::c_uint;
unsafe extern "C" {
    #[doc = " Start accepting Unicode text input events in a window, with properties\n describing the input.\n\n This function will enable text input (SDL_EVENT_TEXT_INPUT and\n SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this\n function paired with SDL_StopTextInput().\n\n Text input events are not received by default.\n\n On some platforms using this function shows the screen keyboard and/or\n activates an IME, which can prevent some key press events from being passed\n through.\n\n These are the supported properties:\n\n - `SDL_PROP_TEXTINPUT_TYPE_NUMBER` - an SDL_TextInputType value that\n   describes text being input, defaults to SDL_TEXTINPUT_TYPE_TEXT.\n - `SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER` - an SDL_Capitalization value\n   that describes how text should be capitalized, defaults to\n   SDL_CAPITALIZE_SENTENCES for normal text entry, SDL_CAPITALIZE_WORDS for\n   SDL_TEXTINPUT_TYPE_TEXT_NAME, and SDL_CAPITALIZE_NONE for e-mail\n   addresses, usernames, and passwords.\n - `SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN` - true to enable auto completion\n   and auto correction, defaults to true.\n - `SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN` - true if multiple lines of text\n   are allowed. This defaults to true if SDL_HINT_RETURN_KEY_HIDES_IME is\n   \"0\" or is not set, and defaults to false if SDL_HINT_RETURN_KEY_HIDES_IME\n   is \"1\".\n\n On Android you can directly specify the input type:\n\n - `SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER` - the text input type to\n   use, overriding other properties. This is documented at\n   https://developer.android.com/reference/android/text/InputType\n\n \\param window the window to enable text input.\n \\param props the properties to use.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetTextInputArea\n \\sa SDL_StartTextInput\n \\sa SDL_StopTextInput\n \\sa SDL_TextInputActive"]
    pub fn SDL_StartTextInputWithProperties(
        window: *mut SDL_Window,
        props: SDL_PropertiesID,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Check whether or not Unicode text input events are enabled for a window.\n\n \\param window the window to check.\n \\returns true if text input events are enabled else false.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_StartTextInput"]
    pub fn SDL_TextInputActive(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Stop receiving any text input events in a window.\n\n If SDL_StartTextInput() showed the screen keyboard, this function will hide\n it.\n\n \\param window the window to disable text input.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_StartTextInput"]
    pub fn SDL_StopTextInput(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Dismiss the composition window/IME without disabling the subsystem.\n\n \\param window the window to affect.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_StartTextInput\n \\sa SDL_StopTextInput"]
    pub fn SDL_ClearComposition(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the area used to type Unicode text input.\n\n Native input methods may place a window with word suggestions near the\n cursor, without covering the text being entered.\n\n \\param window the window for which to set the text input area.\n \\param rect the SDL_Rect representing the text input area, in window\n             coordinates, or NULL to clear it.\n \\param cursor the offset of the current cursor location relative to\n               `rect->x`, in window coordinates.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetTextInputArea\n \\sa SDL_StartTextInput"]
    pub fn SDL_SetTextInputArea(
        window: *mut SDL_Window,
        rect: *const SDL_Rect,
        cursor: ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the area used to type Unicode text input.\n\n This returns the values previously set by SDL_SetTextInputArea().\n\n \\param window the window for which to query the text input area.\n \\param rect a pointer to an SDL_Rect filled in with the text input area,\n             may be NULL.\n \\param cursor a pointer to the offset of the current cursor location\n               relative to `rect->x`, may be NULL.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetTextInputArea"]
    pub fn SDL_GetTextInputArea(
        window: *mut SDL_Window,
        rect: *mut SDL_Rect,
        cursor: *mut ::core::ffi::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Check whether the platform has screen keyboard support.\n\n \\returns true if the platform has some screen keyboard support or false if\n          not.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_StartTextInput\n \\sa SDL_ScreenKeyboardShown"]
    pub fn SDL_HasScreenKeyboardSupport() -> bool;
}
unsafe extern "C" {
    #[doc = " Check whether the screen keyboard is shown for given window.\n\n \\param window the window for which screen keyboard should be queried.\n \\returns true if screen keyboard is shown or false if not.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_HasScreenKeyboardSupport"]
    pub fn SDL_ScreenKeyboardShown(window: *mut SDL_Window) -> bool;
}
#[doc = " This is a unique ID for a mouse for the time it is connected to the system,\n and is never reused for the lifetime of the application.\n\n If the mouse is disconnected and reconnected, it will get a new ID.\n\n The value 0 is an invalid ID.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_MouseID = Uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Cursor {
    _unused: [u8; 0],
}
#[doc = "< Default cursor. Usually an arrow."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_DEFAULT: SDL_SystemCursor = 0;
#[doc = "< Text selection. Usually an I-beam."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_TEXT: SDL_SystemCursor = 1;
#[doc = "< Wait. Usually an hourglass or watch or spinning ball."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_WAIT: SDL_SystemCursor = 2;
#[doc = "< Crosshair."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_CROSSHAIR: SDL_SystemCursor = 3;
#[doc = "< Program is busy but still interactive. Usually it's WAIT with an arrow."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_PROGRESS: SDL_SystemCursor = 4;
#[doc = "< Double arrow pointing northwest and southeast."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_NWSE_RESIZE: SDL_SystemCursor = 5;
#[doc = "< Double arrow pointing northeast and southwest."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_NESW_RESIZE: SDL_SystemCursor = 6;
#[doc = "< Double arrow pointing west and east."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_EW_RESIZE: SDL_SystemCursor = 7;
#[doc = "< Double arrow pointing north and south."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_NS_RESIZE: SDL_SystemCursor = 8;
#[doc = "< Four pointed arrow pointing north, south, east, and west."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_MOVE: SDL_SystemCursor = 9;
#[doc = "< Not permitted. Usually a slashed circle or crossbones."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_NOT_ALLOWED: SDL_SystemCursor = 10;
#[doc = "< Pointer that indicates a link. Usually a pointing hand."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_POINTER: SDL_SystemCursor = 11;
#[doc = "< Window resize top-left. This may be a single arrow or a double arrow like NWSE_RESIZE."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_NW_RESIZE: SDL_SystemCursor = 12;
#[doc = "< Window resize top. May be NS_RESIZE."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_N_RESIZE: SDL_SystemCursor = 13;
#[doc = "< Window resize top-right. May be NESW_RESIZE."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_NE_RESIZE: SDL_SystemCursor = 14;
#[doc = "< Window resize right. May be EW_RESIZE."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_E_RESIZE: SDL_SystemCursor = 15;
#[doc = "< Window resize bottom-right. May be NWSE_RESIZE."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SE_RESIZE: SDL_SystemCursor = 16;
#[doc = "< Window resize bottom. May be NS_RESIZE."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_S_RESIZE: SDL_SystemCursor = 17;
#[doc = "< Window resize bottom-left. May be NESW_RESIZE."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SW_RESIZE: SDL_SystemCursor = 18;
#[doc = "< Window resize left. May be EW_RESIZE."]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_W_RESIZE: SDL_SystemCursor = 19;
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_COUNT: SDL_SystemCursor = 20;
#[doc = " Cursor types for SDL_CreateSystemCursor().\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_SystemCursor = ::core::ffi::c_uint;
#[doc = "< The scroll direction is normal"]
pub const SDL_MouseWheelDirection_SDL_MOUSEWHEEL_NORMAL: SDL_MouseWheelDirection = 0;
#[doc = "< The scroll direction is flipped / natural"]
pub const SDL_MouseWheelDirection_SDL_MOUSEWHEEL_FLIPPED: SDL_MouseWheelDirection = 1;
#[doc = " Scroll direction types for the Scroll event\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_MouseWheelDirection = ::core::ffi::c_uint;
#[doc = " A bitmask of pressed mouse buttons, as reported by SDL_GetMouseState, etc.\n\n - Button 1: Left mouse button\n - Button 2: Middle mouse button\n - Button 3: Right mouse button\n - Button 4: Side mouse button 1\n - Button 5: Side mouse button 2\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_GetMouseState\n \\sa SDL_GetGlobalMouseState\n \\sa SDL_GetRelativeMouseState"]
pub type SDL_MouseButtonFlags = Uint32;
unsafe extern "C" {
    #[doc = " Return whether a mouse is currently connected.\n\n \\returns true if a mouse is connected, false otherwise.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetMice"]
    pub fn SDL_HasMouse() -> bool;
}
unsafe extern "C" {
    #[doc = " Get a list of currently connected mice.\n\n Note that this will include any device or virtual driver that includes\n mouse functionality, including some game controllers, KVM switches, etc.\n You should wait for input from a device before you consider it actively in\n use.\n\n \\param count a pointer filled in with the number of mice returned, may be\n              NULL.\n \\returns a 0 terminated array of mouse instance IDs or NULL on failure;\n          call SDL_GetError() for more information. This should be freed\n          with SDL_free() when it is no longer needed.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetMouseNameForID\n \\sa SDL_HasMouse"]
    pub fn SDL_GetMice(count: *mut ::core::ffi::c_int) -> *mut SDL_MouseID;
}
unsafe extern "C" {
    #[doc = " Get the name of a mouse.\n\n This function returns \"\" if the mouse doesn't have a name.\n\n \\param instance_id the mouse instance ID.\n \\returns the name of the selected mouse, or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetMice"]
    pub fn SDL_GetMouseNameForID(instance_id: SDL_MouseID) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the window which currently has mouse focus.\n\n \\returns the window with mouse focus.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetMouseFocus() -> *mut SDL_Window;
}
unsafe extern "C" {
    #[doc = " Query SDL's cache for the synchronous mouse button state and the\n window-relative SDL-cursor position.\n\n This function returns the cached synchronous state as SDL understands it\n from the last pump of the event queue.\n\n To query the platform for immediate asynchronous state, use\n SDL_GetGlobalMouseState.\n\n Passing non-NULL pointers to `x` or `y` will write the destination with\n respective x or y coordinates relative to the focused window.\n\n In Relative Mode, the SDL-cursor's position usually contradicts the\n platform-cursor's position as manually calculated from\n SDL_GetGlobalMouseState() and SDL_GetWindowPosition.\n\n \\param x a pointer to receive the SDL-cursor's x-position from the focused\n          window's top left corner, can be NULL if unused.\n \\param y a pointer to receive the SDL-cursor's y-position from the focused\n          window's top left corner, can be NULL if unused.\n \\returns a 32-bit bitmask of the button state that can be bitwise-compared\n          against the SDL_BUTTON_MASK(X) macro.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGlobalMouseState\n \\sa SDL_GetRelativeMouseState"]
    pub fn SDL_GetMouseState(x: *mut f32, y: *mut f32) -> SDL_MouseButtonFlags;
}
unsafe extern "C" {
    #[doc = " Query the platform for the asynchronous mouse button state and the\n desktop-relative platform-cursor position.\n\n This function immediately queries the platform for the most recent\n asynchronous state, more costly than retrieving SDL's cached state in\n SDL_GetMouseState().\n\n Passing non-NULL pointers to `x` or `y` will write the destination with\n respective x or y coordinates relative to the desktop.\n\n In Relative Mode, the platform-cursor's position usually contradicts the\n SDL-cursor's position as manually calculated from SDL_GetMouseState() and\n SDL_GetWindowPosition.\n\n This function can be useful if you need to track the mouse outside of a\n specific window and SDL_CaptureMouse() doesn't fit your needs. For example,\n it could be useful if you need to track the mouse while dragging a window,\n where coordinates relative to a window might not be in sync at all times.\n\n \\param x a pointer to receive the platform-cursor's x-position from the\n          desktop's top left corner, can be NULL if unused.\n \\param y a pointer to receive the platform-cursor's y-position from the\n          desktop's top left corner, can be NULL if unused.\n \\returns a 32-bit bitmask of the button state that can be bitwise-compared\n          against the SDL_BUTTON_MASK(X) macro.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CaptureMouse\n \\sa SDL_GetMouseState\n \\sa SDL_GetGlobalMouseState"]
    pub fn SDL_GetGlobalMouseState(x: *mut f32, y: *mut f32) -> SDL_MouseButtonFlags;
}
unsafe extern "C" {
    #[doc = " Query SDL's cache for the synchronous mouse button state and accumulated\n mouse delta since last call.\n\n This function returns the cached synchronous state as SDL understands it\n from the last pump of the event queue.\n\n To query the platform for immediate asynchronous state, use\n SDL_GetGlobalMouseState.\n\n Passing non-NULL pointers to `x` or `y` will write the destination with\n respective x or y deltas accumulated since the last call to this function\n (or since event initialization).\n\n This function is useful for reducing overhead by processing relative mouse\n inputs in one go per-frame instead of individually per-event, at the\n expense of losing the order between events within the frame (e.g. quickly\n pressing and releasing a button within the same frame).\n\n \\param x a pointer to receive the x mouse delta accumulated since last\n          call, can be NULL if unused.\n \\param y a pointer to receive the y mouse delta accumulated since last\n          call, can be NULL if unused.\n \\returns a 32-bit bitmask of the button state that can be bitwise-compared\n          against the SDL_BUTTON_MASK(X) macro.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetMouseState\n \\sa SDL_GetGlobalMouseState"]
    pub fn SDL_GetRelativeMouseState(x: *mut f32, y: *mut f32) -> SDL_MouseButtonFlags;
}
unsafe extern "C" {
    #[doc = " Move the mouse cursor to the given position within the window.\n\n This function generates a mouse motion event if relative mode is not\n enabled. If relative mode is enabled, you can force mouse events for the\n warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.\n\n Note that this function will appear to succeed, but not actually move the\n mouse when used over Microsoft Remote Desktop.\n\n \\param window the window to move the mouse into, or NULL for the current\n               mouse focus.\n \\param x the x coordinate within the window.\n \\param y the y coordinate within the window.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_WarpMouseGlobal"]
    pub fn SDL_WarpMouseInWindow(window: *mut SDL_Window, x: f32, y: f32);
}
unsafe extern "C" {
    #[doc = " Move the mouse to the given position in global screen space.\n\n This function generates a mouse motion event.\n\n A failure of this function usually means that it is unsupported by a\n platform.\n\n Note that this function will appear to succeed, but not actually move the\n mouse when used over Microsoft Remote Desktop.\n\n \\param x the x coordinate.\n \\param y the y coordinate.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_WarpMouseInWindow"]
    pub fn SDL_WarpMouseGlobal(x: f32, y: f32) -> bool;
}
unsafe extern "C" {
    #[doc = " Set relative mouse mode for a window.\n\n While the window has focus and relative mouse mode is enabled, the cursor\n is hidden, the mouse position is constrained to the window, and SDL will\n report continuous relative mouse motion even if the mouse is at the edge of\n the window.\n\n If you'd like to keep the mouse position fixed while in relative mode you\n can use SDL_SetWindowMouseRect(). If you'd like the cursor to be at a\n specific location when relative mode ends, you should use\n SDL_WarpMouseInWindow() before disabling relative mode.\n\n This function will flush any pending mouse motion for this window.\n\n \\param window the window to change.\n \\param enabled true to enable relative mode, false to disable.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetWindowRelativeMouseMode"]
    pub fn SDL_SetWindowRelativeMouseMode(window: *mut SDL_Window, enabled: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Query whether relative mouse mode is enabled for a window.\n\n \\param window the window to query.\n \\returns true if relative mode is enabled for a window or false otherwise.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetWindowRelativeMouseMode"]
    pub fn SDL_GetWindowRelativeMouseMode(window: *mut SDL_Window) -> bool;
}
unsafe extern "C" {
    #[doc = " Capture the mouse and to track input outside an SDL window.\n\n Capturing enables your app to obtain mouse events globally, instead of just\n within your window. Not all video targets support this function. When\n capturing is enabled, the current window will get all mouse events, but\n unlike relative mode, no change is made to the cursor and it is not\n restrained to your window.\n\n This function may also deny mouse input to other windows--both those in\n your application and others on the system--so you should use this function\n sparingly, and in small bursts. For example, you might want to track the\n mouse while the user is dragging something, until the user releases a mouse\n button. It is not recommended that you capture the mouse for long periods\n of time, such as the entire time your app is running. For that, you should\n probably use SDL_SetWindowRelativeMouseMode() or SDL_SetWindowMouseGrab(),\n depending on your goals.\n\n While captured, mouse events still report coordinates relative to the\n current (foreground) window, but those coordinates may be outside the\n bounds of the window (including negative values). Capturing is only allowed\n for the foreground window. If the window loses focus while capturing, the\n capture will be disabled automatically.\n\n While capturing is enabled, the current window will have the\n `SDL_WINDOW_MOUSE_CAPTURE` flag set.\n\n Please note that SDL will attempt to \"auto capture\" the mouse while the\n user is pressing a button; this is to try and make mouse behavior more\n consistent between platforms, and deal with the common case of a user\n dragging the mouse outside of the window. This means that if you are\n calling SDL_CaptureMouse() only to deal with this situation, you do not\n have to (although it is safe to do so). If this causes problems for your\n app, you can disable auto capture by setting the\n `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.\n\n \\param enabled true to enable capturing, false to disable.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetGlobalMouseState"]
    pub fn SDL_CaptureMouse(enabled: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Create a cursor using the specified bitmap data and mask (in MSB format).\n\n `mask` has to be in MSB (Most Significant Bit) format.\n\n The cursor width (`w`) must be a multiple of 8 bits.\n\n The cursor is created in black and white according to the following:\n\n - data=0, mask=1: white\n - data=1, mask=1: black\n - data=0, mask=0: transparent\n - data=1, mask=0: inverted color if possible, black if not.\n\n Cursors created with this function must be freed with SDL_DestroyCursor().\n\n If you want to have a color cursor, or create your cursor from an\n SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can\n hide the cursor and draw your own as part of your game's rendering, but it\n will be bound to the framerate.\n\n Also, SDL_CreateSystemCursor() is available, which provides several\n readily-available system cursors to pick from.\n\n \\param data the color value for each pixel of the cursor.\n \\param mask the mask value for each pixel of the cursor.\n \\param w the width of the cursor.\n \\param h the height of the cursor.\n \\param hot_x the x-axis offset from the left of the cursor image to the\n              mouse x position, in the range of 0 to `w` - 1.\n \\param hot_y the y-axis offset from the top of the cursor image to the\n              mouse y position, in the range of 0 to `h` - 1.\n \\returns a new cursor with the specified parameters on success or NULL on\n          failure; call SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateColorCursor\n \\sa SDL_CreateSystemCursor\n \\sa SDL_DestroyCursor\n \\sa SDL_SetCursor"]
    pub fn SDL_CreateCursor(
        data: *const Uint8,
        mask: *const Uint8,
        w: ::core::ffi::c_int,
        h: ::core::ffi::c_int,
        hot_x: ::core::ffi::c_int,
        hot_y: ::core::ffi::c_int,
    ) -> *mut SDL_Cursor;
}
unsafe extern "C" {
    #[doc = " Create a color cursor.\n\n If this function is passed a surface with alternate representations, the\n surface will be interpreted as the content to be used for 100% display\n scale, and the alternate representations will be used for high DPI\n situations. For example, if the original surface is 32x32, then on a 2x\n macOS display or 200% display scale on Windows, a 64x64 version of the\n image will be used, if available. If a matching version of the image isn't\n available, the closest larger size image will be downscaled to the\n appropriate size and be used instead, if available. Otherwise, the closest\n smaller image will be upscaled and be used instead.\n\n \\param surface an SDL_Surface structure representing the cursor image.\n \\param hot_x the x position of the cursor hot spot.\n \\param hot_y the y position of the cursor hot spot.\n \\returns the new cursor on success or NULL on failure; call SDL_GetError()\n          for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateCursor\n \\sa SDL_CreateSystemCursor\n \\sa SDL_DestroyCursor\n \\sa SDL_SetCursor"]
    pub fn SDL_CreateColorCursor(
        surface: *mut SDL_Surface,
        hot_x: ::core::ffi::c_int,
        hot_y: ::core::ffi::c_int,
    ) -> *mut SDL_Cursor;
}
unsafe extern "C" {
    #[doc = " Create a system cursor.\n\n \\param id an SDL_SystemCursor enum value.\n \\returns a cursor on success or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_DestroyCursor"]
    pub fn SDL_CreateSystemCursor(id: SDL_SystemCursor) -> *mut SDL_Cursor;
}
unsafe extern "C" {
    #[doc = " Set the active cursor.\n\n This function sets the currently active cursor to the specified one. If the\n cursor is currently visible, the change will be immediately represented on\n the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if\n this is desired for any reason.\n\n \\param cursor a cursor to make active.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetCursor"]
    pub fn SDL_SetCursor(cursor: *mut SDL_Cursor) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the active cursor.\n\n This function returns a pointer to the current cursor which is owned by the\n library. It is not necessary to free the cursor with SDL_DestroyCursor().\n\n \\returns the active cursor or NULL if there is no mouse.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetCursor"]
    pub fn SDL_GetCursor() -> *mut SDL_Cursor;
}
unsafe extern "C" {
    #[doc = " Get the default cursor.\n\n You do not have to call SDL_DestroyCursor() on the return value, but it is\n safe to do so.\n\n \\returns the default cursor on success or NULL on failuree; call\n          SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetDefaultCursor() -> *mut SDL_Cursor;
}
unsafe extern "C" {
    #[doc = " Free a previously-created cursor.\n\n Use this function to free cursor resources created with SDL_CreateCursor(),\n SDL_CreateColorCursor() or SDL_CreateSystemCursor().\n\n \\param cursor the cursor to free.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CreateColorCursor\n \\sa SDL_CreateCursor\n \\sa SDL_CreateSystemCursor"]
    pub fn SDL_DestroyCursor(cursor: *mut SDL_Cursor);
}
unsafe extern "C" {
    #[doc = " Show the cursor.\n\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CursorVisible\n \\sa SDL_HideCursor"]
    pub fn SDL_ShowCursor() -> bool;
}
unsafe extern "C" {
    #[doc = " Hide the cursor.\n\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_CursorVisible\n \\sa SDL_ShowCursor"]
    pub fn SDL_HideCursor() -> bool;
}
unsafe extern "C" {
    #[doc = " Return whether the cursor is currently being shown.\n\n \\returns `true` if the cursor is being shown, or `false` if the cursor is\n          hidden.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_HideCursor\n \\sa SDL_ShowCursor"]
    pub fn SDL_CursorVisible() -> bool;
}
#[doc = " A unique ID for a touch device.\n\n This ID is valid for the time the device is connected to the system, and is\n never reused for the lifetime of the application.\n\n The value 0 is an invalid ID.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_TouchID = Uint64;
#[doc = " A unique ID for a single finger on a touch device.\n\n This ID is valid for the time the finger (stylus, etc) is touching and will\n be unique for all fingers currently in contact, so this ID tracks the\n lifetime of a single continuous touch. This value may represent an index, a\n pointer, or some other unique ID, depending on the platform.\n\n The value 0 is an invalid ID.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_FingerID = Uint64;
pub const SDL_TouchDeviceType_SDL_TOUCH_DEVICE_INVALID: SDL_TouchDeviceType = -1;
#[doc = "< touch screen with window-relative coordinates"]
pub const SDL_TouchDeviceType_SDL_TOUCH_DEVICE_DIRECT: SDL_TouchDeviceType = 0;
#[doc = "< trackpad with absolute device coordinates"]
pub const SDL_TouchDeviceType_SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE: SDL_TouchDeviceType = 1;
#[doc = "< trackpad with screen cursor-relative coordinates"]
pub const SDL_TouchDeviceType_SDL_TOUCH_DEVICE_INDIRECT_RELATIVE: SDL_TouchDeviceType = 2;
#[doc = " An enum that describes the type of a touch device.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_TouchDeviceType = ::core::ffi::c_int;
#[doc = " Data about a single finger in a multitouch event.\n\n Each touch event is a collection of fingers that are simultaneously in\n contact with the touch device (so a \"touch\" can be a \"multitouch,\" in\n reality), and this struct reports details of the specific fingers.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_GetTouchFingers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Finger {
    #[doc = "< the finger ID"]
    pub id: SDL_FingerID,
    #[doc = "< the x-axis location of the touch event, normalized (0...1)"]
    pub x: f32,
    #[doc = "< the y-axis location of the touch event, normalized (0...1)"]
    pub y: f32,
    #[doc = "< the quantity of pressure applied, normalized (0...1)"]
    pub pressure: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_Finger"][::core::mem::size_of::<SDL_Finger>() - 24usize];
    ["Alignment of SDL_Finger"][::core::mem::align_of::<SDL_Finger>() - 8usize];
    ["Offset of field: SDL_Finger::id"][::core::mem::offset_of!(SDL_Finger, id) - 0usize];
    ["Offset of field: SDL_Finger::x"][::core::mem::offset_of!(SDL_Finger, x) - 8usize];
    ["Offset of field: SDL_Finger::y"][::core::mem::offset_of!(SDL_Finger, y) - 12usize];
    ["Offset of field: SDL_Finger::pressure"]
        [::core::mem::offset_of!(SDL_Finger, pressure) - 16usize];
};
unsafe extern "C" {
    #[doc = " Get a list of registered touch devices.\n\n On some platforms SDL first sees the touch device if it was actually used.\n Therefore the returned list might be empty, although devices are available.\n After using all devices at least once the number will be correct.\n\n \\param count a pointer filled in with the number of devices returned, may\n              be NULL.\n \\returns a 0 terminated array of touch device IDs or NULL on failure; call\n          SDL_GetError() for more information. This should be freed with\n          SDL_free() when it is no longer needed.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetTouchDevices(count: *mut ::core::ffi::c_int) -> *mut SDL_TouchID;
}
unsafe extern "C" {
    #[doc = " Get the touch device name as reported from the driver.\n\n \\param touchID the touch device instance ID.\n \\returns touch device name, or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetTouchDeviceName(touchID: SDL_TouchID) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the type of the given touch device.\n\n \\param touchID the ID of a touch device.\n \\returns touch device type.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetTouchDeviceType(touchID: SDL_TouchID) -> SDL_TouchDeviceType;
}
unsafe extern "C" {
    #[doc = " Get a list of active fingers for a given touch device.\n\n \\param touchID the ID of a touch device.\n \\param count a pointer filled in with the number of fingers returned, can\n              be NULL.\n \\returns a NULL terminated array of SDL_Finger pointers or NULL on failure;\n          call SDL_GetError() for more information. This is a single\n          allocation that should be freed with SDL_free() when it is no\n          longer needed.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GetTouchFingers(
        touchID: SDL_TouchID,
        count: *mut ::core::ffi::c_int,
    ) -> *mut *mut SDL_Finger;
}
#[doc = " SDL pen instance IDs.\n\n Zero is used to signify an invalid/null device.\n\n These show up in pen events when SDL sees input from them. They remain\n consistent as long as SDL can recognize a tool to be the same pen; but if a\n pen physically leaves the area and returns, it might get a new ID.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_PenID = Uint32;
#[doc = " Pen input flags, as reported by various pen events' `pen_state` field.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_PenInputFlags = Uint32;
#[doc = "< Pen pressure.  Unidirectional: 0 to 1.0"]
pub const SDL_PenAxis_SDL_PEN_AXIS_PRESSURE: SDL_PenAxis = 0;
#[doc = "< Pen horizontal tilt angle.  Bidirectional: -90.0 to 90.0 (left-to-right)."]
pub const SDL_PenAxis_SDL_PEN_AXIS_XTILT: SDL_PenAxis = 1;
#[doc = "< Pen vertical tilt angle.  Bidirectional: -90.0 to 90.0 (top-to-down)."]
pub const SDL_PenAxis_SDL_PEN_AXIS_YTILT: SDL_PenAxis = 2;
#[doc = "< Pen distance to drawing surface.  Unidirectional: 0.0 to 1.0"]
pub const SDL_PenAxis_SDL_PEN_AXIS_DISTANCE: SDL_PenAxis = 3;
#[doc = "< Pen barrel rotation.  Bidirectional: -180 to 179.9 (clockwise, 0 is facing up, -180.0 is facing down)."]
pub const SDL_PenAxis_SDL_PEN_AXIS_ROTATION: SDL_PenAxis = 4;
#[doc = "< Pen finger wheel or slider (e.g., Airbrush Pen).  Unidirectional: 0 to 1.0"]
pub const SDL_PenAxis_SDL_PEN_AXIS_SLIDER: SDL_PenAxis = 5;
#[doc = "< Pressure from squeezing the pen (\"barrel pressure\")."]
pub const SDL_PenAxis_SDL_PEN_AXIS_TANGENTIAL_PRESSURE: SDL_PenAxis = 6;
#[doc = "< Total known pen axis types in this version of SDL. This number may grow in future releases!"]
pub const SDL_PenAxis_SDL_PEN_AXIS_COUNT: SDL_PenAxis = 7;
#[doc = " Pen axis indices.\n\n These are the valid values for the `axis` field in SDL_PenAxisEvent. All\n axes are either normalised to 0..1 or report a (positive or negative) angle\n in degrees, with 0.0 representing the centre. Not all pens/backends support\n all axes: unsupported axes are always zero.\n\n To convert angles for tilt and rotation into vector representation, use\n SDL_sinf on the XTILT, YTILT, or ROTATION component, for example:\n\n `SDL_sinf(xtilt * SDL_PI_F / 180.0)`.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_PenAxis = ::core::ffi::c_uint;
#[doc = "< Unused (do not remove)"]
pub const SDL_EventType_SDL_EVENT_FIRST: SDL_EventType = 0;
#[doc = "< User-requested quit"]
pub const SDL_EventType_SDL_EVENT_QUIT: SDL_EventType = 256;
#[doc = "< The application is being terminated by the OS. This event must be handled in a callback set with SDL_AddEventWatch().\nCalled on iOS in applicationWillTerminate()\nCalled on Android in onDestroy()"]
pub const SDL_EventType_SDL_EVENT_TERMINATING: SDL_EventType = 257;
#[doc = "< The application is low on memory, free memory if possible. This event must be handled in a callback set with SDL_AddEventWatch().\nCalled on iOS in applicationDidReceiveMemoryWarning()\nCalled on Android in onTrimMemory()"]
pub const SDL_EventType_SDL_EVENT_LOW_MEMORY: SDL_EventType = 258;
#[doc = "< The application is about to enter the background. This event must be handled in a callback set with SDL_AddEventWatch().\nCalled on iOS in applicationWillResignActive()\nCalled on Android in onPause()"]
pub const SDL_EventType_SDL_EVENT_WILL_ENTER_BACKGROUND: SDL_EventType = 259;
#[doc = "< The application did enter the background and may not get CPU for some time. This event must be handled in a callback set with SDL_AddEventWatch().\nCalled on iOS in applicationDidEnterBackground()\nCalled on Android in onPause()"]
pub const SDL_EventType_SDL_EVENT_DID_ENTER_BACKGROUND: SDL_EventType = 260;
#[doc = "< The application is about to enter the foreground. This event must be handled in a callback set with SDL_AddEventWatch().\nCalled on iOS in applicationWillEnterForeground()\nCalled on Android in onResume()"]
pub const SDL_EventType_SDL_EVENT_WILL_ENTER_FOREGROUND: SDL_EventType = 261;
#[doc = "< The application is now interactive. This event must be handled in a callback set with SDL_AddEventWatch().\nCalled on iOS in applicationDidBecomeActive()\nCalled on Android in onResume()"]
pub const SDL_EventType_SDL_EVENT_DID_ENTER_FOREGROUND: SDL_EventType = 262;
#[doc = "< The user's locale preferences have changed."]
pub const SDL_EventType_SDL_EVENT_LOCALE_CHANGED: SDL_EventType = 263;
#[doc = "< The system theme changed"]
pub const SDL_EventType_SDL_EVENT_SYSTEM_THEME_CHANGED: SDL_EventType = 264;
#[doc = "< Display orientation has changed to data1"]
pub const SDL_EventType_SDL_EVENT_DISPLAY_ORIENTATION: SDL_EventType = 337;
#[doc = "< Display has been added to the system"]
pub const SDL_EventType_SDL_EVENT_DISPLAY_ADDED: SDL_EventType = 338;
#[doc = "< Display has been removed from the system"]
pub const SDL_EventType_SDL_EVENT_DISPLAY_REMOVED: SDL_EventType = 339;
#[doc = "< Display has changed position"]
pub const SDL_EventType_SDL_EVENT_DISPLAY_MOVED: SDL_EventType = 340;
#[doc = "< Display has changed desktop mode"]
pub const SDL_EventType_SDL_EVENT_DISPLAY_DESKTOP_MODE_CHANGED: SDL_EventType = 341;
#[doc = "< Display has changed current mode"]
pub const SDL_EventType_SDL_EVENT_DISPLAY_CURRENT_MODE_CHANGED: SDL_EventType = 342;
#[doc = "< Display has changed content scale"]
pub const SDL_EventType_SDL_EVENT_DISPLAY_CONTENT_SCALE_CHANGED: SDL_EventType = 343;
pub const SDL_EventType_SDL_EVENT_DISPLAY_FIRST: SDL_EventType = 337;
pub const SDL_EventType_SDL_EVENT_DISPLAY_LAST: SDL_EventType = 343;
#[doc = "< Window has been shown"]
pub const SDL_EventType_SDL_EVENT_WINDOW_SHOWN: SDL_EventType = 514;
#[doc = "< Window has been hidden"]
pub const SDL_EventType_SDL_EVENT_WINDOW_HIDDEN: SDL_EventType = 515;
#[doc = "< Window has been exposed and should be redrawn, and can be redrawn directly from event watchers for this event"]
pub const SDL_EventType_SDL_EVENT_WINDOW_EXPOSED: SDL_EventType = 516;
#[doc = "< Window has been moved to data1, data2"]
pub const SDL_EventType_SDL_EVENT_WINDOW_MOVED: SDL_EventType = 517;
#[doc = "< Window has been resized to data1xdata2"]
pub const SDL_EventType_SDL_EVENT_WINDOW_RESIZED: SDL_EventType = 518;
#[doc = "< The pixel size of the window has changed to data1xdata2"]
pub const SDL_EventType_SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED: SDL_EventType = 519;
#[doc = "< The pixel size of a Metal view associated with the window has changed"]
pub const SDL_EventType_SDL_EVENT_WINDOW_METAL_VIEW_RESIZED: SDL_EventType = 520;
#[doc = "< Window has been minimized"]
pub const SDL_EventType_SDL_EVENT_WINDOW_MINIMIZED: SDL_EventType = 521;
#[doc = "< Window has been maximized"]
pub const SDL_EventType_SDL_EVENT_WINDOW_MAXIMIZED: SDL_EventType = 522;
#[doc = "< Window has been restored to normal size and position"]
pub const SDL_EventType_SDL_EVENT_WINDOW_RESTORED: SDL_EventType = 523;
#[doc = "< Window has gained mouse focus"]
pub const SDL_EventType_SDL_EVENT_WINDOW_MOUSE_ENTER: SDL_EventType = 524;
#[doc = "< Window has lost mouse focus"]
pub const SDL_EventType_SDL_EVENT_WINDOW_MOUSE_LEAVE: SDL_EventType = 525;
#[doc = "< Window has gained keyboard focus"]
pub const SDL_EventType_SDL_EVENT_WINDOW_FOCUS_GAINED: SDL_EventType = 526;
#[doc = "< Window has lost keyboard focus"]
pub const SDL_EventType_SDL_EVENT_WINDOW_FOCUS_LOST: SDL_EventType = 527;
#[doc = "< The window manager requests that the window be closed"]
pub const SDL_EventType_SDL_EVENT_WINDOW_CLOSE_REQUESTED: SDL_EventType = 528;
#[doc = "< Window had a hit test that wasn't SDL_HITTEST_NORMAL"]
pub const SDL_EventType_SDL_EVENT_WINDOW_HIT_TEST: SDL_EventType = 529;
#[doc = "< The ICC profile of the window's display has changed"]
pub const SDL_EventType_SDL_EVENT_WINDOW_ICCPROF_CHANGED: SDL_EventType = 530;
#[doc = "< Window has been moved to display data1"]
pub const SDL_EventType_SDL_EVENT_WINDOW_DISPLAY_CHANGED: SDL_EventType = 531;
#[doc = "< Window display scale has been changed"]
pub const SDL_EventType_SDL_EVENT_WINDOW_DISPLAY_SCALE_CHANGED: SDL_EventType = 532;
#[doc = "< The window safe area has been changed"]
pub const SDL_EventType_SDL_EVENT_WINDOW_SAFE_AREA_CHANGED: SDL_EventType = 533;
#[doc = "< The window has been occluded"]
pub const SDL_EventType_SDL_EVENT_WINDOW_OCCLUDED: SDL_EventType = 534;
#[doc = "< The window has entered fullscreen mode"]
pub const SDL_EventType_SDL_EVENT_WINDOW_ENTER_FULLSCREEN: SDL_EventType = 535;
#[doc = "< The window has left fullscreen mode"]
pub const SDL_EventType_SDL_EVENT_WINDOW_LEAVE_FULLSCREEN: SDL_EventType = 536;
#[doc = "< The window with the associated ID is being or has been destroyed. If this message is being handled\nin an event watcher, the window handle is still valid and can still be used to retrieve any properties\nassociated with the window. Otherwise, the handle has already been destroyed and all resources\nassociated with it are invalid"]
pub const SDL_EventType_SDL_EVENT_WINDOW_DESTROYED: SDL_EventType = 537;
#[doc = "< Window HDR properties have changed"]
pub const SDL_EventType_SDL_EVENT_WINDOW_HDR_STATE_CHANGED: SDL_EventType = 538;
pub const SDL_EventType_SDL_EVENT_WINDOW_FIRST: SDL_EventType = 514;
pub const SDL_EventType_SDL_EVENT_WINDOW_LAST: SDL_EventType = 538;
#[doc = "< Key pressed"]
pub const SDL_EventType_SDL_EVENT_KEY_DOWN: SDL_EventType = 768;
#[doc = "< Key released"]
pub const SDL_EventType_SDL_EVENT_KEY_UP: SDL_EventType = 769;
#[doc = "< Keyboard text editing (composition)"]
pub const SDL_EventType_SDL_EVENT_TEXT_EDITING: SDL_EventType = 770;
#[doc = "< Keyboard text input"]
pub const SDL_EventType_SDL_EVENT_TEXT_INPUT: SDL_EventType = 771;
#[doc = "< Keymap changed due to a system event such as an\ninput language or keyboard layout change."]
pub const SDL_EventType_SDL_EVENT_KEYMAP_CHANGED: SDL_EventType = 772;
#[doc = "< A new keyboard has been inserted into the system"]
pub const SDL_EventType_SDL_EVENT_KEYBOARD_ADDED: SDL_EventType = 773;
#[doc = "< A keyboard has been removed"]
pub const SDL_EventType_SDL_EVENT_KEYBOARD_REMOVED: SDL_EventType = 774;
#[doc = "< Keyboard text editing candidates"]
pub const SDL_EventType_SDL_EVENT_TEXT_EDITING_CANDIDATES: SDL_EventType = 775;
#[doc = "< Mouse moved"]
pub const SDL_EventType_SDL_EVENT_MOUSE_MOTION: SDL_EventType = 1024;
#[doc = "< Mouse button pressed"]
pub const SDL_EventType_SDL_EVENT_MOUSE_BUTTON_DOWN: SDL_EventType = 1025;
#[doc = "< Mouse button released"]
pub const SDL_EventType_SDL_EVENT_MOUSE_BUTTON_UP: SDL_EventType = 1026;
#[doc = "< Mouse wheel motion"]
pub const SDL_EventType_SDL_EVENT_MOUSE_WHEEL: SDL_EventType = 1027;
#[doc = "< A new mouse has been inserted into the system"]
pub const SDL_EventType_SDL_EVENT_MOUSE_ADDED: SDL_EventType = 1028;
#[doc = "< A mouse has been removed"]
pub const SDL_EventType_SDL_EVENT_MOUSE_REMOVED: SDL_EventType = 1029;
#[doc = "< Joystick axis motion"]
pub const SDL_EventType_SDL_EVENT_JOYSTICK_AXIS_MOTION: SDL_EventType = 1536;
#[doc = "< Joystick trackball motion"]
pub const SDL_EventType_SDL_EVENT_JOYSTICK_BALL_MOTION: SDL_EventType = 1537;
#[doc = "< Joystick hat position change"]
pub const SDL_EventType_SDL_EVENT_JOYSTICK_HAT_MOTION: SDL_EventType = 1538;
#[doc = "< Joystick button pressed"]
pub const SDL_EventType_SDL_EVENT_JOYSTICK_BUTTON_DOWN: SDL_EventType = 1539;
#[doc = "< Joystick button released"]
pub const SDL_EventType_SDL_EVENT_JOYSTICK_BUTTON_UP: SDL_EventType = 1540;
#[doc = "< A new joystick has been inserted into the system"]
pub const SDL_EventType_SDL_EVENT_JOYSTICK_ADDED: SDL_EventType = 1541;
#[doc = "< An opened joystick has been removed"]
pub const SDL_EventType_SDL_EVENT_JOYSTICK_REMOVED: SDL_EventType = 1542;
#[doc = "< Joystick battery level change"]
pub const SDL_EventType_SDL_EVENT_JOYSTICK_BATTERY_UPDATED: SDL_EventType = 1543;
#[doc = "< Joystick update is complete"]
pub const SDL_EventType_SDL_EVENT_JOYSTICK_UPDATE_COMPLETE: SDL_EventType = 1544;
#[doc = "< Gamepad axis motion"]
pub const SDL_EventType_SDL_EVENT_GAMEPAD_AXIS_MOTION: SDL_EventType = 1616;
#[doc = "< Gamepad button pressed"]
pub const SDL_EventType_SDL_EVENT_GAMEPAD_BUTTON_DOWN: SDL_EventType = 1617;
#[doc = "< Gamepad button released"]
pub const SDL_EventType_SDL_EVENT_GAMEPAD_BUTTON_UP: SDL_EventType = 1618;
#[doc = "< A new gamepad has been inserted into the system"]
pub const SDL_EventType_SDL_EVENT_GAMEPAD_ADDED: SDL_EventType = 1619;
#[doc = "< A gamepad has been removed"]
pub const SDL_EventType_SDL_EVENT_GAMEPAD_REMOVED: SDL_EventType = 1620;
#[doc = "< The gamepad mapping was updated"]
pub const SDL_EventType_SDL_EVENT_GAMEPAD_REMAPPED: SDL_EventType = 1621;
#[doc = "< Gamepad touchpad was touched"]
pub const SDL_EventType_SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN: SDL_EventType = 1622;
#[doc = "< Gamepad touchpad finger was moved"]
pub const SDL_EventType_SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION: SDL_EventType = 1623;
#[doc = "< Gamepad touchpad finger was lifted"]
pub const SDL_EventType_SDL_EVENT_GAMEPAD_TOUCHPAD_UP: SDL_EventType = 1624;
#[doc = "< Gamepad sensor was updated"]
pub const SDL_EventType_SDL_EVENT_GAMEPAD_SENSOR_UPDATE: SDL_EventType = 1625;
#[doc = "< Gamepad update is complete"]
pub const SDL_EventType_SDL_EVENT_GAMEPAD_UPDATE_COMPLETE: SDL_EventType = 1626;
#[doc = "< Gamepad Steam handle has changed"]
pub const SDL_EventType_SDL_EVENT_GAMEPAD_STEAM_HANDLE_UPDATED: SDL_EventType = 1627;
pub const SDL_EventType_SDL_EVENT_FINGER_DOWN: SDL_EventType = 1792;
pub const SDL_EventType_SDL_EVENT_FINGER_UP: SDL_EventType = 1793;
pub const SDL_EventType_SDL_EVENT_FINGER_MOTION: SDL_EventType = 1794;
pub const SDL_EventType_SDL_EVENT_FINGER_CANCELED: SDL_EventType = 1795;
#[doc = "< The clipboard or primary selection changed"]
pub const SDL_EventType_SDL_EVENT_CLIPBOARD_UPDATE: SDL_EventType = 2304;
#[doc = "< The system requests a file open"]
pub const SDL_EventType_SDL_EVENT_DROP_FILE: SDL_EventType = 4096;
#[doc = "< text/plain drag-and-drop event"]
pub const SDL_EventType_SDL_EVENT_DROP_TEXT: SDL_EventType = 4097;
#[doc = "< A new set of drops is beginning (NULL filename)"]
pub const SDL_EventType_SDL_EVENT_DROP_BEGIN: SDL_EventType = 4098;
#[doc = "< Current set of drops is now complete (NULL filename)"]
pub const SDL_EventType_SDL_EVENT_DROP_COMPLETE: SDL_EventType = 4099;
#[doc = "< Position while moving over the window"]
pub const SDL_EventType_SDL_EVENT_DROP_POSITION: SDL_EventType = 4100;
#[doc = "< A new audio device is available"]
pub const SDL_EventType_SDL_EVENT_AUDIO_DEVICE_ADDED: SDL_EventType = 4352;
#[doc = "< An audio device has been removed."]
pub const SDL_EventType_SDL_EVENT_AUDIO_DEVICE_REMOVED: SDL_EventType = 4353;
#[doc = "< An audio device's format has been changed by the system."]
pub const SDL_EventType_SDL_EVENT_AUDIO_DEVICE_FORMAT_CHANGED: SDL_EventType = 4354;
#[doc = "< A sensor was updated"]
pub const SDL_EventType_SDL_EVENT_SENSOR_UPDATE: SDL_EventType = 4608;
#[doc = "< Pressure-sensitive pen has become available"]
pub const SDL_EventType_SDL_EVENT_PEN_PROXIMITY_IN: SDL_EventType = 4864;
#[doc = "< Pressure-sensitive pen has become unavailable"]
pub const SDL_EventType_SDL_EVENT_PEN_PROXIMITY_OUT: SDL_EventType = 4865;
#[doc = "< Pressure-sensitive pen touched drawing surface"]
pub const SDL_EventType_SDL_EVENT_PEN_DOWN: SDL_EventType = 4866;
#[doc = "< Pressure-sensitive pen stopped touching drawing surface"]
pub const SDL_EventType_SDL_EVENT_PEN_UP: SDL_EventType = 4867;
#[doc = "< Pressure-sensitive pen button pressed"]
pub const SDL_EventType_SDL_EVENT_PEN_BUTTON_DOWN: SDL_EventType = 4868;
#[doc = "< Pressure-sensitive pen button released"]
pub const SDL_EventType_SDL_EVENT_PEN_BUTTON_UP: SDL_EventType = 4869;
#[doc = "< Pressure-sensitive pen is moving on the tablet"]
pub const SDL_EventType_SDL_EVENT_PEN_MOTION: SDL_EventType = 4870;
#[doc = "< Pressure-sensitive pen angle/pressure/etc changed"]
pub const SDL_EventType_SDL_EVENT_PEN_AXIS: SDL_EventType = 4871;
#[doc = "< A new camera device is available"]
pub const SDL_EventType_SDL_EVENT_CAMERA_DEVICE_ADDED: SDL_EventType = 5120;
#[doc = "< A camera device has been removed."]
pub const SDL_EventType_SDL_EVENT_CAMERA_DEVICE_REMOVED: SDL_EventType = 5121;
#[doc = "< A camera device has been approved for use by the user."]
pub const SDL_EventType_SDL_EVENT_CAMERA_DEVICE_APPROVED: SDL_EventType = 5122;
#[doc = "< A camera device has been denied for use by the user."]
pub const SDL_EventType_SDL_EVENT_CAMERA_DEVICE_DENIED: SDL_EventType = 5123;
#[doc = "< The render targets have been reset and their contents need to be updated"]
pub const SDL_EventType_SDL_EVENT_RENDER_TARGETS_RESET: SDL_EventType = 8192;
#[doc = "< The device has been reset and all textures need to be recreated"]
pub const SDL_EventType_SDL_EVENT_RENDER_DEVICE_RESET: SDL_EventType = 8193;
#[doc = "< The device has been lost and can't be recovered."]
pub const SDL_EventType_SDL_EVENT_RENDER_DEVICE_LOST: SDL_EventType = 8194;
pub const SDL_EventType_SDL_EVENT_PRIVATE0: SDL_EventType = 16384;
pub const SDL_EventType_SDL_EVENT_PRIVATE1: SDL_EventType = 16385;
pub const SDL_EventType_SDL_EVENT_PRIVATE2: SDL_EventType = 16386;
pub const SDL_EventType_SDL_EVENT_PRIVATE3: SDL_EventType = 16387;
#[doc = "< Signals the end of an event poll cycle"]
pub const SDL_EventType_SDL_EVENT_POLL_SENTINEL: SDL_EventType = 32512;
#[doc = " Events SDL_EVENT_USER through SDL_EVENT_LAST are for your use,\n  and should be allocated with SDL_RegisterEvents()"]
pub const SDL_EventType_SDL_EVENT_USER: SDL_EventType = 32768;
#[doc = "  This last event is only for bounding internal arrays"]
pub const SDL_EventType_SDL_EVENT_LAST: SDL_EventType = 65535;
#[doc = "  This last event is only for bounding internal arrays"]
pub const SDL_EventType_SDL_EVENT_ENUM_PADDING: SDL_EventType = 2147483647;
#[doc = " The types of events that can be delivered.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_EventType = ::core::ffi::c_uint;
#[doc = " Fields shared by every event\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_CommonEvent {
    #[doc = "< Event type, shared with all events, Uint32 to cover user events which are not in the SDL_EventType enumeration"]
    pub type_: Uint32,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_CommonEvent"][::core::mem::size_of::<SDL_CommonEvent>() - 16usize];
    ["Alignment of SDL_CommonEvent"][::core::mem::align_of::<SDL_CommonEvent>() - 8usize];
    ["Offset of field: SDL_CommonEvent::type_"]
        [::core::mem::offset_of!(SDL_CommonEvent, type_) - 0usize];
    ["Offset of field: SDL_CommonEvent::reserved"]
        [::core::mem::offset_of!(SDL_CommonEvent, reserved) - 4usize];
    ["Offset of field: SDL_CommonEvent::timestamp"]
        [::core::mem::offset_of!(SDL_CommonEvent, timestamp) - 8usize];
};
#[doc = " Display state change event data (event.display.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_DisplayEvent {
    #[doc = "< SDL_DISPLAYEVENT_*"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The associated display"]
    pub displayID: SDL_DisplayID,
    #[doc = "< event dependent data"]
    pub data1: Sint32,
    #[doc = "< event dependent data"]
    pub data2: Sint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_DisplayEvent"][::core::mem::size_of::<SDL_DisplayEvent>() - 32usize];
    ["Alignment of SDL_DisplayEvent"][::core::mem::align_of::<SDL_DisplayEvent>() - 8usize];
    ["Offset of field: SDL_DisplayEvent::type_"]
        [::core::mem::offset_of!(SDL_DisplayEvent, type_) - 0usize];
    ["Offset of field: SDL_DisplayEvent::reserved"]
        [::core::mem::offset_of!(SDL_DisplayEvent, reserved) - 4usize];
    ["Offset of field: SDL_DisplayEvent::timestamp"]
        [::core::mem::offset_of!(SDL_DisplayEvent, timestamp) - 8usize];
    ["Offset of field: SDL_DisplayEvent::displayID"]
        [::core::mem::offset_of!(SDL_DisplayEvent, displayID) - 16usize];
    ["Offset of field: SDL_DisplayEvent::data1"]
        [::core::mem::offset_of!(SDL_DisplayEvent, data1) - 20usize];
    ["Offset of field: SDL_DisplayEvent::data2"]
        [::core::mem::offset_of!(SDL_DisplayEvent, data2) - 24usize];
};
#[doc = " Window state change event data (event.window.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_WindowEvent {
    #[doc = "< SDL_EVENT_WINDOW_*"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The associated window"]
    pub windowID: SDL_WindowID,
    #[doc = "< event dependent data"]
    pub data1: Sint32,
    #[doc = "< event dependent data"]
    pub data2: Sint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_WindowEvent"][::core::mem::size_of::<SDL_WindowEvent>() - 32usize];
    ["Alignment of SDL_WindowEvent"][::core::mem::align_of::<SDL_WindowEvent>() - 8usize];
    ["Offset of field: SDL_WindowEvent::type_"]
        [::core::mem::offset_of!(SDL_WindowEvent, type_) - 0usize];
    ["Offset of field: SDL_WindowEvent::reserved"]
        [::core::mem::offset_of!(SDL_WindowEvent, reserved) - 4usize];
    ["Offset of field: SDL_WindowEvent::timestamp"]
        [::core::mem::offset_of!(SDL_WindowEvent, timestamp) - 8usize];
    ["Offset of field: SDL_WindowEvent::windowID"]
        [::core::mem::offset_of!(SDL_WindowEvent, windowID) - 16usize];
    ["Offset of field: SDL_WindowEvent::data1"]
        [::core::mem::offset_of!(SDL_WindowEvent, data1) - 20usize];
    ["Offset of field: SDL_WindowEvent::data2"]
        [::core::mem::offset_of!(SDL_WindowEvent, data2) - 24usize];
};
#[doc = " Keyboard device event structure (event.kdevice.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_KeyboardDeviceEvent {
    #[doc = "< SDL_EVENT_KEYBOARD_ADDED or SDL_EVENT_KEYBOARD_REMOVED"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The keyboard instance id"]
    pub which: SDL_KeyboardID,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_KeyboardDeviceEvent"]
        [::core::mem::size_of::<SDL_KeyboardDeviceEvent>() - 24usize];
    ["Alignment of SDL_KeyboardDeviceEvent"]
        [::core::mem::align_of::<SDL_KeyboardDeviceEvent>() - 8usize];
    ["Offset of field: SDL_KeyboardDeviceEvent::type_"]
        [::core::mem::offset_of!(SDL_KeyboardDeviceEvent, type_) - 0usize];
    ["Offset of field: SDL_KeyboardDeviceEvent::reserved"]
        [::core::mem::offset_of!(SDL_KeyboardDeviceEvent, reserved) - 4usize];
    ["Offset of field: SDL_KeyboardDeviceEvent::timestamp"]
        [::core::mem::offset_of!(SDL_KeyboardDeviceEvent, timestamp) - 8usize];
    ["Offset of field: SDL_KeyboardDeviceEvent::which"]
        [::core::mem::offset_of!(SDL_KeyboardDeviceEvent, which) - 16usize];
};
#[doc = " Keyboard button event structure (event.key.*)\n\n The `key` is the base SDL_Keycode generated by pressing the `scancode`\n using the current keyboard layout, applying any options specified in\n SDL_HINT_KEYCODE_OPTIONS. You can get the SDL_Keycode corresponding to the\n event scancode and modifiers directly from the keyboard layout, bypassing\n SDL_HINT_KEYCODE_OPTIONS, by calling SDL_GetKeyFromScancode().\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_GetKeyFromScancode\n \\sa SDL_HINT_KEYCODE_OPTIONS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_KeyboardEvent {
    #[doc = "< SDL_EVENT_KEY_DOWN or SDL_EVENT_KEY_UP"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The keyboard instance id, or 0 if unknown or virtual"]
    pub which: SDL_KeyboardID,
    #[doc = "< SDL physical key code"]
    pub scancode: SDL_Scancode,
    #[doc = "< SDL virtual key code"]
    pub key: SDL_Keycode,
    #[doc = "< current key modifiers"]
    pub mod_: SDL_Keymod,
    #[doc = "< The platform dependent scancode for this event"]
    pub raw: Uint16,
    #[doc = "< true if the key is pressed"]
    pub down: bool,
    #[doc = "< true if this is a key repeat"]
    pub repeat: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_KeyboardEvent"][::core::mem::size_of::<SDL_KeyboardEvent>() - 40usize];
    ["Alignment of SDL_KeyboardEvent"][::core::mem::align_of::<SDL_KeyboardEvent>() - 8usize];
    ["Offset of field: SDL_KeyboardEvent::type_"]
        [::core::mem::offset_of!(SDL_KeyboardEvent, type_) - 0usize];
    ["Offset of field: SDL_KeyboardEvent::reserved"]
        [::core::mem::offset_of!(SDL_KeyboardEvent, reserved) - 4usize];
    ["Offset of field: SDL_KeyboardEvent::timestamp"]
        [::core::mem::offset_of!(SDL_KeyboardEvent, timestamp) - 8usize];
    ["Offset of field: SDL_KeyboardEvent::windowID"]
        [::core::mem::offset_of!(SDL_KeyboardEvent, windowID) - 16usize];
    ["Offset of field: SDL_KeyboardEvent::which"]
        [::core::mem::offset_of!(SDL_KeyboardEvent, which) - 20usize];
    ["Offset of field: SDL_KeyboardEvent::scancode"]
        [::core::mem::offset_of!(SDL_KeyboardEvent, scancode) - 24usize];
    ["Offset of field: SDL_KeyboardEvent::key"]
        [::core::mem::offset_of!(SDL_KeyboardEvent, key) - 28usize];
    ["Offset of field: SDL_KeyboardEvent::mod_"]
        [::core::mem::offset_of!(SDL_KeyboardEvent, mod_) - 32usize];
    ["Offset of field: SDL_KeyboardEvent::raw"]
        [::core::mem::offset_of!(SDL_KeyboardEvent, raw) - 34usize];
    ["Offset of field: SDL_KeyboardEvent::down"]
        [::core::mem::offset_of!(SDL_KeyboardEvent, down) - 36usize];
    ["Offset of field: SDL_KeyboardEvent::repeat"]
        [::core::mem::offset_of!(SDL_KeyboardEvent, repeat) - 37usize];
};
#[doc = " Keyboard text editing event structure (event.edit.*)\n\n The start cursor is the position, in UTF-8 characters, where new typing\n will be inserted into the editing text. The length is the number of UTF-8\n characters that will be replaced by new typing.\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_TextEditingEvent {
    #[doc = "< SDL_EVENT_TEXT_EDITING"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The editing text"]
    pub text: *const ::core::ffi::c_char,
    #[doc = "< The start cursor of selected editing text, or -1 if not set"]
    pub start: Sint32,
    #[doc = "< The length of selected editing text, or -1 if not set"]
    pub length: Sint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_TextEditingEvent"][::core::mem::size_of::<SDL_TextEditingEvent>() - 40usize];
    ["Alignment of SDL_TextEditingEvent"][::core::mem::align_of::<SDL_TextEditingEvent>() - 8usize];
    ["Offset of field: SDL_TextEditingEvent::type_"]
        [::core::mem::offset_of!(SDL_TextEditingEvent, type_) - 0usize];
    ["Offset of field: SDL_TextEditingEvent::reserved"]
        [::core::mem::offset_of!(SDL_TextEditingEvent, reserved) - 4usize];
    ["Offset of field: SDL_TextEditingEvent::timestamp"]
        [::core::mem::offset_of!(SDL_TextEditingEvent, timestamp) - 8usize];
    ["Offset of field: SDL_TextEditingEvent::windowID"]
        [::core::mem::offset_of!(SDL_TextEditingEvent, windowID) - 16usize];
    ["Offset of field: SDL_TextEditingEvent::text"]
        [::core::mem::offset_of!(SDL_TextEditingEvent, text) - 24usize];
    ["Offset of field: SDL_TextEditingEvent::start"]
        [::core::mem::offset_of!(SDL_TextEditingEvent, start) - 32usize];
    ["Offset of field: SDL_TextEditingEvent::length"]
        [::core::mem::offset_of!(SDL_TextEditingEvent, length) - 36usize];
};
#[doc = " Keyboard IME candidates event structure (event.edit_candidates.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_TextEditingCandidatesEvent {
    #[doc = "< SDL_EVENT_TEXT_EDITING_CANDIDATES"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The list of candidates, or NULL if there are no candidates available"]
    pub candidates: *const *const ::core::ffi::c_char,
    #[doc = "< The number of strings in `candidates`"]
    pub num_candidates: Sint32,
    #[doc = "< The index of the selected candidate, or -1 if no candidate is selected"]
    pub selected_candidate: Sint32,
    #[doc = "< true if the list is horizontal, false if it's vertical"]
    pub horizontal: bool,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_TextEditingCandidatesEvent"]
        [::core::mem::size_of::<SDL_TextEditingCandidatesEvent>() - 48usize];
    ["Alignment of SDL_TextEditingCandidatesEvent"]
        [::core::mem::align_of::<SDL_TextEditingCandidatesEvent>() - 8usize];
    ["Offset of field: SDL_TextEditingCandidatesEvent::type_"]
        [::core::mem::offset_of!(SDL_TextEditingCandidatesEvent, type_) - 0usize];
    ["Offset of field: SDL_TextEditingCandidatesEvent::reserved"]
        [::core::mem::offset_of!(SDL_TextEditingCandidatesEvent, reserved) - 4usize];
    ["Offset of field: SDL_TextEditingCandidatesEvent::timestamp"]
        [::core::mem::offset_of!(SDL_TextEditingCandidatesEvent, timestamp) - 8usize];
    ["Offset of field: SDL_TextEditingCandidatesEvent::windowID"]
        [::core::mem::offset_of!(SDL_TextEditingCandidatesEvent, windowID) - 16usize];
    ["Offset of field: SDL_TextEditingCandidatesEvent::candidates"]
        [::core::mem::offset_of!(SDL_TextEditingCandidatesEvent, candidates) - 24usize];
    ["Offset of field: SDL_TextEditingCandidatesEvent::num_candidates"]
        [::core::mem::offset_of!(SDL_TextEditingCandidatesEvent, num_candidates) - 32usize];
    ["Offset of field: SDL_TextEditingCandidatesEvent::selected_candidate"]
        [::core::mem::offset_of!(SDL_TextEditingCandidatesEvent, selected_candidate) - 36usize];
    ["Offset of field: SDL_TextEditingCandidatesEvent::horizontal"]
        [::core::mem::offset_of!(SDL_TextEditingCandidatesEvent, horizontal) - 40usize];
    ["Offset of field: SDL_TextEditingCandidatesEvent::padding1"]
        [::core::mem::offset_of!(SDL_TextEditingCandidatesEvent, padding1) - 41usize];
    ["Offset of field: SDL_TextEditingCandidatesEvent::padding2"]
        [::core::mem::offset_of!(SDL_TextEditingCandidatesEvent, padding2) - 42usize];
    ["Offset of field: SDL_TextEditingCandidatesEvent::padding3"]
        [::core::mem::offset_of!(SDL_TextEditingCandidatesEvent, padding3) - 43usize];
};
#[doc = " Keyboard text input event structure (event.text.*)\n\n This event will never be delivered unless text input is enabled by calling\n SDL_StartTextInput(). Text input is disabled by default!\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_StartTextInput\n \\sa SDL_StopTextInput"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_TextInputEvent {
    #[doc = "< SDL_EVENT_TEXT_INPUT"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The input text, UTF-8 encoded"]
    pub text: *const ::core::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_TextInputEvent"][::core::mem::size_of::<SDL_TextInputEvent>() - 32usize];
    ["Alignment of SDL_TextInputEvent"][::core::mem::align_of::<SDL_TextInputEvent>() - 8usize];
    ["Offset of field: SDL_TextInputEvent::type_"]
        [::core::mem::offset_of!(SDL_TextInputEvent, type_) - 0usize];
    ["Offset of field: SDL_TextInputEvent::reserved"]
        [::core::mem::offset_of!(SDL_TextInputEvent, reserved) - 4usize];
    ["Offset of field: SDL_TextInputEvent::timestamp"]
        [::core::mem::offset_of!(SDL_TextInputEvent, timestamp) - 8usize];
    ["Offset of field: SDL_TextInputEvent::windowID"]
        [::core::mem::offset_of!(SDL_TextInputEvent, windowID) - 16usize];
    ["Offset of field: SDL_TextInputEvent::text"]
        [::core::mem::offset_of!(SDL_TextInputEvent, text) - 24usize];
};
#[doc = " Mouse device event structure (event.mdevice.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MouseDeviceEvent {
    #[doc = "< SDL_EVENT_MOUSE_ADDED or SDL_EVENT_MOUSE_REMOVED"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The mouse instance id"]
    pub which: SDL_MouseID,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_MouseDeviceEvent"][::core::mem::size_of::<SDL_MouseDeviceEvent>() - 24usize];
    ["Alignment of SDL_MouseDeviceEvent"][::core::mem::align_of::<SDL_MouseDeviceEvent>() - 8usize];
    ["Offset of field: SDL_MouseDeviceEvent::type_"]
        [::core::mem::offset_of!(SDL_MouseDeviceEvent, type_) - 0usize];
    ["Offset of field: SDL_MouseDeviceEvent::reserved"]
        [::core::mem::offset_of!(SDL_MouseDeviceEvent, reserved) - 4usize];
    ["Offset of field: SDL_MouseDeviceEvent::timestamp"]
        [::core::mem::offset_of!(SDL_MouseDeviceEvent, timestamp) - 8usize];
    ["Offset of field: SDL_MouseDeviceEvent::which"]
        [::core::mem::offset_of!(SDL_MouseDeviceEvent, which) - 16usize];
};
#[doc = " Mouse motion event structure (event.motion.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MouseMotionEvent {
    #[doc = "< SDL_EVENT_MOUSE_MOTION"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The mouse instance id in relative mode, SDL_TOUCH_MOUSEID for touch events, or 0"]
    pub which: SDL_MouseID,
    #[doc = "< The current button state"]
    pub state: SDL_MouseButtonFlags,
    #[doc = "< X coordinate, relative to window"]
    pub x: f32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: f32,
    #[doc = "< The relative motion in the X direction"]
    pub xrel: f32,
    #[doc = "< The relative motion in the Y direction"]
    pub yrel: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_MouseMotionEvent"][::core::mem::size_of::<SDL_MouseMotionEvent>() - 48usize];
    ["Alignment of SDL_MouseMotionEvent"][::core::mem::align_of::<SDL_MouseMotionEvent>() - 8usize];
    ["Offset of field: SDL_MouseMotionEvent::type_"]
        [::core::mem::offset_of!(SDL_MouseMotionEvent, type_) - 0usize];
    ["Offset of field: SDL_MouseMotionEvent::reserved"]
        [::core::mem::offset_of!(SDL_MouseMotionEvent, reserved) - 4usize];
    ["Offset of field: SDL_MouseMotionEvent::timestamp"]
        [::core::mem::offset_of!(SDL_MouseMotionEvent, timestamp) - 8usize];
    ["Offset of field: SDL_MouseMotionEvent::windowID"]
        [::core::mem::offset_of!(SDL_MouseMotionEvent, windowID) - 16usize];
    ["Offset of field: SDL_MouseMotionEvent::which"]
        [::core::mem::offset_of!(SDL_MouseMotionEvent, which) - 20usize];
    ["Offset of field: SDL_MouseMotionEvent::state"]
        [::core::mem::offset_of!(SDL_MouseMotionEvent, state) - 24usize];
    ["Offset of field: SDL_MouseMotionEvent::x"]
        [::core::mem::offset_of!(SDL_MouseMotionEvent, x) - 28usize];
    ["Offset of field: SDL_MouseMotionEvent::y"]
        [::core::mem::offset_of!(SDL_MouseMotionEvent, y) - 32usize];
    ["Offset of field: SDL_MouseMotionEvent::xrel"]
        [::core::mem::offset_of!(SDL_MouseMotionEvent, xrel) - 36usize];
    ["Offset of field: SDL_MouseMotionEvent::yrel"]
        [::core::mem::offset_of!(SDL_MouseMotionEvent, yrel) - 40usize];
};
#[doc = " Mouse button event structure (event.button.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MouseButtonEvent {
    #[doc = "< SDL_EVENT_MOUSE_BUTTON_DOWN or SDL_EVENT_MOUSE_BUTTON_UP"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The mouse instance id in relative mode, SDL_TOUCH_MOUSEID for touch events, or 0"]
    pub which: SDL_MouseID,
    #[doc = "< The mouse button index"]
    pub button: Uint8,
    #[doc = "< true if the button is pressed"]
    pub down: bool,
    #[doc = "< 1 for single-click, 2 for double-click, etc."]
    pub clicks: Uint8,
    pub padding: Uint8,
    #[doc = "< X coordinate, relative to window"]
    pub x: f32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_MouseButtonEvent"][::core::mem::size_of::<SDL_MouseButtonEvent>() - 40usize];
    ["Alignment of SDL_MouseButtonEvent"][::core::mem::align_of::<SDL_MouseButtonEvent>() - 8usize];
    ["Offset of field: SDL_MouseButtonEvent::type_"]
        [::core::mem::offset_of!(SDL_MouseButtonEvent, type_) - 0usize];
    ["Offset of field: SDL_MouseButtonEvent::reserved"]
        [::core::mem::offset_of!(SDL_MouseButtonEvent, reserved) - 4usize];
    ["Offset of field: SDL_MouseButtonEvent::timestamp"]
        [::core::mem::offset_of!(SDL_MouseButtonEvent, timestamp) - 8usize];
    ["Offset of field: SDL_MouseButtonEvent::windowID"]
        [::core::mem::offset_of!(SDL_MouseButtonEvent, windowID) - 16usize];
    ["Offset of field: SDL_MouseButtonEvent::which"]
        [::core::mem::offset_of!(SDL_MouseButtonEvent, which) - 20usize];
    ["Offset of field: SDL_MouseButtonEvent::button"]
        [::core::mem::offset_of!(SDL_MouseButtonEvent, button) - 24usize];
    ["Offset of field: SDL_MouseButtonEvent::down"]
        [::core::mem::offset_of!(SDL_MouseButtonEvent, down) - 25usize];
    ["Offset of field: SDL_MouseButtonEvent::clicks"]
        [::core::mem::offset_of!(SDL_MouseButtonEvent, clicks) - 26usize];
    ["Offset of field: SDL_MouseButtonEvent::padding"]
        [::core::mem::offset_of!(SDL_MouseButtonEvent, padding) - 27usize];
    ["Offset of field: SDL_MouseButtonEvent::x"]
        [::core::mem::offset_of!(SDL_MouseButtonEvent, x) - 28usize];
    ["Offset of field: SDL_MouseButtonEvent::y"]
        [::core::mem::offset_of!(SDL_MouseButtonEvent, y) - 32usize];
};
#[doc = " Mouse wheel event structure (event.wheel.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MouseWheelEvent {
    #[doc = "< SDL_EVENT_MOUSE_WHEEL"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The mouse instance id in relative mode or 0"]
    pub which: SDL_MouseID,
    #[doc = "< The amount scrolled horizontally, positive to the right and negative to the left"]
    pub x: f32,
    #[doc = "< The amount scrolled vertically, positive away from the user and negative toward the user"]
    pub y: f32,
    #[doc = "< Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back"]
    pub direction: SDL_MouseWheelDirection,
    #[doc = "< X coordinate, relative to window"]
    pub mouse_x: f32,
    #[doc = "< Y coordinate, relative to window"]
    pub mouse_y: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_MouseWheelEvent"][::core::mem::size_of::<SDL_MouseWheelEvent>() - 48usize];
    ["Alignment of SDL_MouseWheelEvent"][::core::mem::align_of::<SDL_MouseWheelEvent>() - 8usize];
    ["Offset of field: SDL_MouseWheelEvent::type_"]
        [::core::mem::offset_of!(SDL_MouseWheelEvent, type_) - 0usize];
    ["Offset of field: SDL_MouseWheelEvent::reserved"]
        [::core::mem::offset_of!(SDL_MouseWheelEvent, reserved) - 4usize];
    ["Offset of field: SDL_MouseWheelEvent::timestamp"]
        [::core::mem::offset_of!(SDL_MouseWheelEvent, timestamp) - 8usize];
    ["Offset of field: SDL_MouseWheelEvent::windowID"]
        [::core::mem::offset_of!(SDL_MouseWheelEvent, windowID) - 16usize];
    ["Offset of field: SDL_MouseWheelEvent::which"]
        [::core::mem::offset_of!(SDL_MouseWheelEvent, which) - 20usize];
    ["Offset of field: SDL_MouseWheelEvent::x"]
        [::core::mem::offset_of!(SDL_MouseWheelEvent, x) - 24usize];
    ["Offset of field: SDL_MouseWheelEvent::y"]
        [::core::mem::offset_of!(SDL_MouseWheelEvent, y) - 28usize];
    ["Offset of field: SDL_MouseWheelEvent::direction"]
        [::core::mem::offset_of!(SDL_MouseWheelEvent, direction) - 32usize];
    ["Offset of field: SDL_MouseWheelEvent::mouse_x"]
        [::core::mem::offset_of!(SDL_MouseWheelEvent, mouse_x) - 36usize];
    ["Offset of field: SDL_MouseWheelEvent::mouse_y"]
        [::core::mem::offset_of!(SDL_MouseWheelEvent, mouse_y) - 40usize];
};
#[doc = " Joystick axis motion event structure (event.jaxis.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyAxisEvent {
    #[doc = "< SDL_EVENT_JOYSTICK_AXIS_MOTION"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick axis index"]
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The axis value (range: -32768 to 32767)"]
    pub value: Sint16,
    pub padding4: Uint16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_JoyAxisEvent"][::core::mem::size_of::<SDL_JoyAxisEvent>() - 32usize];
    ["Alignment of SDL_JoyAxisEvent"][::core::mem::align_of::<SDL_JoyAxisEvent>() - 8usize];
    ["Offset of field: SDL_JoyAxisEvent::type_"]
        [::core::mem::offset_of!(SDL_JoyAxisEvent, type_) - 0usize];
    ["Offset of field: SDL_JoyAxisEvent::reserved"]
        [::core::mem::offset_of!(SDL_JoyAxisEvent, reserved) - 4usize];
    ["Offset of field: SDL_JoyAxisEvent::timestamp"]
        [::core::mem::offset_of!(SDL_JoyAxisEvent, timestamp) - 8usize];
    ["Offset of field: SDL_JoyAxisEvent::which"]
        [::core::mem::offset_of!(SDL_JoyAxisEvent, which) - 16usize];
    ["Offset of field: SDL_JoyAxisEvent::axis"]
        [::core::mem::offset_of!(SDL_JoyAxisEvent, axis) - 20usize];
    ["Offset of field: SDL_JoyAxisEvent::padding1"]
        [::core::mem::offset_of!(SDL_JoyAxisEvent, padding1) - 21usize];
    ["Offset of field: SDL_JoyAxisEvent::padding2"]
        [::core::mem::offset_of!(SDL_JoyAxisEvent, padding2) - 22usize];
    ["Offset of field: SDL_JoyAxisEvent::padding3"]
        [::core::mem::offset_of!(SDL_JoyAxisEvent, padding3) - 23usize];
    ["Offset of field: SDL_JoyAxisEvent::value"]
        [::core::mem::offset_of!(SDL_JoyAxisEvent, value) - 24usize];
    ["Offset of field: SDL_JoyAxisEvent::padding4"]
        [::core::mem::offset_of!(SDL_JoyAxisEvent, padding4) - 26usize];
};
#[doc = " Joystick trackball motion event structure (event.jball.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyBallEvent {
    #[doc = "< SDL_EVENT_JOYSTICK_BALL_MOTION"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick trackball index"]
    pub ball: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The relative motion in the X direction"]
    pub xrel: Sint16,
    #[doc = "< The relative motion in the Y direction"]
    pub yrel: Sint16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_JoyBallEvent"][::core::mem::size_of::<SDL_JoyBallEvent>() - 32usize];
    ["Alignment of SDL_JoyBallEvent"][::core::mem::align_of::<SDL_JoyBallEvent>() - 8usize];
    ["Offset of field: SDL_JoyBallEvent::type_"]
        [::core::mem::offset_of!(SDL_JoyBallEvent, type_) - 0usize];
    ["Offset of field: SDL_JoyBallEvent::reserved"]
        [::core::mem::offset_of!(SDL_JoyBallEvent, reserved) - 4usize];
    ["Offset of field: SDL_JoyBallEvent::timestamp"]
        [::core::mem::offset_of!(SDL_JoyBallEvent, timestamp) - 8usize];
    ["Offset of field: SDL_JoyBallEvent::which"]
        [::core::mem::offset_of!(SDL_JoyBallEvent, which) - 16usize];
    ["Offset of field: SDL_JoyBallEvent::ball"]
        [::core::mem::offset_of!(SDL_JoyBallEvent, ball) - 20usize];
    ["Offset of field: SDL_JoyBallEvent::padding1"]
        [::core::mem::offset_of!(SDL_JoyBallEvent, padding1) - 21usize];
    ["Offset of field: SDL_JoyBallEvent::padding2"]
        [::core::mem::offset_of!(SDL_JoyBallEvent, padding2) - 22usize];
    ["Offset of field: SDL_JoyBallEvent::padding3"]
        [::core::mem::offset_of!(SDL_JoyBallEvent, padding3) - 23usize];
    ["Offset of field: SDL_JoyBallEvent::xrel"]
        [::core::mem::offset_of!(SDL_JoyBallEvent, xrel) - 24usize];
    ["Offset of field: SDL_JoyBallEvent::yrel"]
        [::core::mem::offset_of!(SDL_JoyBallEvent, yrel) - 26usize];
};
#[doc = " Joystick hat position change event structure (event.jhat.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyHatEvent {
    #[doc = "< SDL_EVENT_JOYSTICK_HAT_MOTION"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick hat index"]
    pub hat: Uint8,
    #[doc = "< The hat position value.\n   \\sa SDL_HAT_LEFTUP SDL_HAT_UP SDL_HAT_RIGHTUP\n   \\sa SDL_HAT_LEFT SDL_HAT_CENTERED SDL_HAT_RIGHT\n   \\sa SDL_HAT_LEFTDOWN SDL_HAT_DOWN SDL_HAT_RIGHTDOWN\n\n   Note that zero means the POV is centered."]
    pub value: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_JoyHatEvent"][::core::mem::size_of::<SDL_JoyHatEvent>() - 24usize];
    ["Alignment of SDL_JoyHatEvent"][::core::mem::align_of::<SDL_JoyHatEvent>() - 8usize];
    ["Offset of field: SDL_JoyHatEvent::type_"]
        [::core::mem::offset_of!(SDL_JoyHatEvent, type_) - 0usize];
    ["Offset of field: SDL_JoyHatEvent::reserved"]
        [::core::mem::offset_of!(SDL_JoyHatEvent, reserved) - 4usize];
    ["Offset of field: SDL_JoyHatEvent::timestamp"]
        [::core::mem::offset_of!(SDL_JoyHatEvent, timestamp) - 8usize];
    ["Offset of field: SDL_JoyHatEvent::which"]
        [::core::mem::offset_of!(SDL_JoyHatEvent, which) - 16usize];
    ["Offset of field: SDL_JoyHatEvent::hat"]
        [::core::mem::offset_of!(SDL_JoyHatEvent, hat) - 20usize];
    ["Offset of field: SDL_JoyHatEvent::value"]
        [::core::mem::offset_of!(SDL_JoyHatEvent, value) - 21usize];
    ["Offset of field: SDL_JoyHatEvent::padding1"]
        [::core::mem::offset_of!(SDL_JoyHatEvent, padding1) - 22usize];
    ["Offset of field: SDL_JoyHatEvent::padding2"]
        [::core::mem::offset_of!(SDL_JoyHatEvent, padding2) - 23usize];
};
#[doc = " Joystick button event structure (event.jbutton.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyButtonEvent {
    #[doc = "< SDL_EVENT_JOYSTICK_BUTTON_DOWN or SDL_EVENT_JOYSTICK_BUTTON_UP"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick button index"]
    pub button: Uint8,
    #[doc = "< true if the button is pressed"]
    pub down: bool,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_JoyButtonEvent"][::core::mem::size_of::<SDL_JoyButtonEvent>() - 24usize];
    ["Alignment of SDL_JoyButtonEvent"][::core::mem::align_of::<SDL_JoyButtonEvent>() - 8usize];
    ["Offset of field: SDL_JoyButtonEvent::type_"]
        [::core::mem::offset_of!(SDL_JoyButtonEvent, type_) - 0usize];
    ["Offset of field: SDL_JoyButtonEvent::reserved"]
        [::core::mem::offset_of!(SDL_JoyButtonEvent, reserved) - 4usize];
    ["Offset of field: SDL_JoyButtonEvent::timestamp"]
        [::core::mem::offset_of!(SDL_JoyButtonEvent, timestamp) - 8usize];
    ["Offset of field: SDL_JoyButtonEvent::which"]
        [::core::mem::offset_of!(SDL_JoyButtonEvent, which) - 16usize];
    ["Offset of field: SDL_JoyButtonEvent::button"]
        [::core::mem::offset_of!(SDL_JoyButtonEvent, button) - 20usize];
    ["Offset of field: SDL_JoyButtonEvent::down"]
        [::core::mem::offset_of!(SDL_JoyButtonEvent, down) - 21usize];
    ["Offset of field: SDL_JoyButtonEvent::padding1"]
        [::core::mem::offset_of!(SDL_JoyButtonEvent, padding1) - 22usize];
    ["Offset of field: SDL_JoyButtonEvent::padding2"]
        [::core::mem::offset_of!(SDL_JoyButtonEvent, padding2) - 23usize];
};
#[doc = " Joystick device event structure (event.jdevice.*)\n\n SDL will send JOYSTICK_ADDED events for devices that are already plugged in\n during SDL_Init.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_GamepadDeviceEvent"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyDeviceEvent {
    #[doc = "< SDL_EVENT_JOYSTICK_ADDED or SDL_EVENT_JOYSTICK_REMOVED or SDL_EVENT_JOYSTICK_UPDATE_COMPLETE"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_JoyDeviceEvent"][::core::mem::size_of::<SDL_JoyDeviceEvent>() - 24usize];
    ["Alignment of SDL_JoyDeviceEvent"][::core::mem::align_of::<SDL_JoyDeviceEvent>() - 8usize];
    ["Offset of field: SDL_JoyDeviceEvent::type_"]
        [::core::mem::offset_of!(SDL_JoyDeviceEvent, type_) - 0usize];
    ["Offset of field: SDL_JoyDeviceEvent::reserved"]
        [::core::mem::offset_of!(SDL_JoyDeviceEvent, reserved) - 4usize];
    ["Offset of field: SDL_JoyDeviceEvent::timestamp"]
        [::core::mem::offset_of!(SDL_JoyDeviceEvent, timestamp) - 8usize];
    ["Offset of field: SDL_JoyDeviceEvent::which"]
        [::core::mem::offset_of!(SDL_JoyDeviceEvent, which) - 16usize];
};
#[doc = " Joystick battery level change event structure (event.jbattery.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyBatteryEvent {
    #[doc = "< SDL_EVENT_JOYSTICK_BATTERY_UPDATED"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick battery state"]
    pub state: SDL_PowerState,
    #[doc = "< The joystick battery percent charge remaining"]
    pub percent: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_JoyBatteryEvent"][::core::mem::size_of::<SDL_JoyBatteryEvent>() - 32usize];
    ["Alignment of SDL_JoyBatteryEvent"][::core::mem::align_of::<SDL_JoyBatteryEvent>() - 8usize];
    ["Offset of field: SDL_JoyBatteryEvent::type_"]
        [::core::mem::offset_of!(SDL_JoyBatteryEvent, type_) - 0usize];
    ["Offset of field: SDL_JoyBatteryEvent::reserved"]
        [::core::mem::offset_of!(SDL_JoyBatteryEvent, reserved) - 4usize];
    ["Offset of field: SDL_JoyBatteryEvent::timestamp"]
        [::core::mem::offset_of!(SDL_JoyBatteryEvent, timestamp) - 8usize];
    ["Offset of field: SDL_JoyBatteryEvent::which"]
        [::core::mem::offset_of!(SDL_JoyBatteryEvent, which) - 16usize];
    ["Offset of field: SDL_JoyBatteryEvent::state"]
        [::core::mem::offset_of!(SDL_JoyBatteryEvent, state) - 20usize];
    ["Offset of field: SDL_JoyBatteryEvent::percent"]
        [::core::mem::offset_of!(SDL_JoyBatteryEvent, percent) - 24usize];
};
#[doc = " Gamepad axis motion event structure (event.gaxis.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_GamepadAxisEvent {
    #[doc = "< SDL_EVENT_GAMEPAD_AXIS_MOTION"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The gamepad axis (SDL_GamepadAxis)"]
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The axis value (range: -32768 to 32767)"]
    pub value: Sint16,
    pub padding4: Uint16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_GamepadAxisEvent"][::core::mem::size_of::<SDL_GamepadAxisEvent>() - 32usize];
    ["Alignment of SDL_GamepadAxisEvent"][::core::mem::align_of::<SDL_GamepadAxisEvent>() - 8usize];
    ["Offset of field: SDL_GamepadAxisEvent::type_"]
        [::core::mem::offset_of!(SDL_GamepadAxisEvent, type_) - 0usize];
    ["Offset of field: SDL_GamepadAxisEvent::reserved"]
        [::core::mem::offset_of!(SDL_GamepadAxisEvent, reserved) - 4usize];
    ["Offset of field: SDL_GamepadAxisEvent::timestamp"]
        [::core::mem::offset_of!(SDL_GamepadAxisEvent, timestamp) - 8usize];
    ["Offset of field: SDL_GamepadAxisEvent::which"]
        [::core::mem::offset_of!(SDL_GamepadAxisEvent, which) - 16usize];
    ["Offset of field: SDL_GamepadAxisEvent::axis"]
        [::core::mem::offset_of!(SDL_GamepadAxisEvent, axis) - 20usize];
    ["Offset of field: SDL_GamepadAxisEvent::padding1"]
        [::core::mem::offset_of!(SDL_GamepadAxisEvent, padding1) - 21usize];
    ["Offset of field: SDL_GamepadAxisEvent::padding2"]
        [::core::mem::offset_of!(SDL_GamepadAxisEvent, padding2) - 22usize];
    ["Offset of field: SDL_GamepadAxisEvent::padding3"]
        [::core::mem::offset_of!(SDL_GamepadAxisEvent, padding3) - 23usize];
    ["Offset of field: SDL_GamepadAxisEvent::value"]
        [::core::mem::offset_of!(SDL_GamepadAxisEvent, value) - 24usize];
    ["Offset of field: SDL_GamepadAxisEvent::padding4"]
        [::core::mem::offset_of!(SDL_GamepadAxisEvent, padding4) - 26usize];
};
#[doc = " Gamepad button event structure (event.gbutton.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_GamepadButtonEvent {
    #[doc = "< SDL_EVENT_GAMEPAD_BUTTON_DOWN or SDL_EVENT_GAMEPAD_BUTTON_UP"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The gamepad button (SDL_GamepadButton)"]
    pub button: Uint8,
    #[doc = "< true if the button is pressed"]
    pub down: bool,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_GamepadButtonEvent"][::core::mem::size_of::<SDL_GamepadButtonEvent>() - 24usize];
    ["Alignment of SDL_GamepadButtonEvent"]
        [::core::mem::align_of::<SDL_GamepadButtonEvent>() - 8usize];
    ["Offset of field: SDL_GamepadButtonEvent::type_"]
        [::core::mem::offset_of!(SDL_GamepadButtonEvent, type_) - 0usize];
    ["Offset of field: SDL_GamepadButtonEvent::reserved"]
        [::core::mem::offset_of!(SDL_GamepadButtonEvent, reserved) - 4usize];
    ["Offset of field: SDL_GamepadButtonEvent::timestamp"]
        [::core::mem::offset_of!(SDL_GamepadButtonEvent, timestamp) - 8usize];
    ["Offset of field: SDL_GamepadButtonEvent::which"]
        [::core::mem::offset_of!(SDL_GamepadButtonEvent, which) - 16usize];
    ["Offset of field: SDL_GamepadButtonEvent::button"]
        [::core::mem::offset_of!(SDL_GamepadButtonEvent, button) - 20usize];
    ["Offset of field: SDL_GamepadButtonEvent::down"]
        [::core::mem::offset_of!(SDL_GamepadButtonEvent, down) - 21usize];
    ["Offset of field: SDL_GamepadButtonEvent::padding1"]
        [::core::mem::offset_of!(SDL_GamepadButtonEvent, padding1) - 22usize];
    ["Offset of field: SDL_GamepadButtonEvent::padding2"]
        [::core::mem::offset_of!(SDL_GamepadButtonEvent, padding2) - 23usize];
};
#[doc = " Gamepad device event structure (event.gdevice.*)\n\n Joysticks that are supported gamepads receive both an SDL_JoyDeviceEvent\n and an SDL_GamepadDeviceEvent.\n\n SDL will send GAMEPAD_ADDED events for joysticks that are already plugged\n in during SDL_Init() and are recognized as gamepads. It will also send\n events for joysticks that get gamepad mappings at runtime.\n\n \\since This struct is available since SDL 3.2.0.\n\n \\sa SDL_JoyDeviceEvent"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_GamepadDeviceEvent {
    #[doc = "< SDL_EVENT_GAMEPAD_ADDED, SDL_EVENT_GAMEPAD_REMOVED, or SDL_EVENT_GAMEPAD_REMAPPED, SDL_EVENT_GAMEPAD_UPDATE_COMPLETE or SDL_EVENT_GAMEPAD_STEAM_HANDLE_UPDATED"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_GamepadDeviceEvent"][::core::mem::size_of::<SDL_GamepadDeviceEvent>() - 24usize];
    ["Alignment of SDL_GamepadDeviceEvent"]
        [::core::mem::align_of::<SDL_GamepadDeviceEvent>() - 8usize];
    ["Offset of field: SDL_GamepadDeviceEvent::type_"]
        [::core::mem::offset_of!(SDL_GamepadDeviceEvent, type_) - 0usize];
    ["Offset of field: SDL_GamepadDeviceEvent::reserved"]
        [::core::mem::offset_of!(SDL_GamepadDeviceEvent, reserved) - 4usize];
    ["Offset of field: SDL_GamepadDeviceEvent::timestamp"]
        [::core::mem::offset_of!(SDL_GamepadDeviceEvent, timestamp) - 8usize];
    ["Offset of field: SDL_GamepadDeviceEvent::which"]
        [::core::mem::offset_of!(SDL_GamepadDeviceEvent, which) - 16usize];
};
#[doc = " Gamepad touchpad event structure (event.gtouchpad.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_GamepadTouchpadEvent {
    #[doc = "< SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN or SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION or SDL_EVENT_GAMEPAD_TOUCHPAD_UP"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The index of the touchpad"]
    pub touchpad: Sint32,
    #[doc = "< The index of the finger on the touchpad"]
    pub finger: Sint32,
    #[doc = "< Normalized in the range 0...1 with 0 being on the left"]
    pub x: f32,
    #[doc = "< Normalized in the range 0...1 with 0 being at the top"]
    pub y: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub pressure: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_GamepadTouchpadEvent"]
        [::core::mem::size_of::<SDL_GamepadTouchpadEvent>() - 40usize];
    ["Alignment of SDL_GamepadTouchpadEvent"]
        [::core::mem::align_of::<SDL_GamepadTouchpadEvent>() - 8usize];
    ["Offset of field: SDL_GamepadTouchpadEvent::type_"]
        [::core::mem::offset_of!(SDL_GamepadTouchpadEvent, type_) - 0usize];
    ["Offset of field: SDL_GamepadTouchpadEvent::reserved"]
        [::core::mem::offset_of!(SDL_GamepadTouchpadEvent, reserved) - 4usize];
    ["Offset of field: SDL_GamepadTouchpadEvent::timestamp"]
        [::core::mem::offset_of!(SDL_GamepadTouchpadEvent, timestamp) - 8usize];
    ["Offset of field: SDL_GamepadTouchpadEvent::which"]
        [::core::mem::offset_of!(SDL_GamepadTouchpadEvent, which) - 16usize];
    ["Offset of field: SDL_GamepadTouchpadEvent::touchpad"]
        [::core::mem::offset_of!(SDL_GamepadTouchpadEvent, touchpad) - 20usize];
    ["Offset of field: SDL_GamepadTouchpadEvent::finger"]
        [::core::mem::offset_of!(SDL_GamepadTouchpadEvent, finger) - 24usize];
    ["Offset of field: SDL_GamepadTouchpadEvent::x"]
        [::core::mem::offset_of!(SDL_GamepadTouchpadEvent, x) - 28usize];
    ["Offset of field: SDL_GamepadTouchpadEvent::y"]
        [::core::mem::offset_of!(SDL_GamepadTouchpadEvent, y) - 32usize];
    ["Offset of field: SDL_GamepadTouchpadEvent::pressure"]
        [::core::mem::offset_of!(SDL_GamepadTouchpadEvent, pressure) - 36usize];
};
#[doc = " Gamepad sensor event structure (event.gsensor.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_GamepadSensorEvent {
    #[doc = "< SDL_EVENT_GAMEPAD_SENSOR_UPDATE"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The type of the sensor, one of the values of SDL_SensorType"]
    pub sensor: Sint32,
    #[doc = "< Up to 3 values from the sensor, as defined in SDL_sensor.h"]
    pub data: [f32; 3usize],
    #[doc = "< The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock"]
    pub sensor_timestamp: Uint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_GamepadSensorEvent"][::core::mem::size_of::<SDL_GamepadSensorEvent>() - 48usize];
    ["Alignment of SDL_GamepadSensorEvent"]
        [::core::mem::align_of::<SDL_GamepadSensorEvent>() - 8usize];
    ["Offset of field: SDL_GamepadSensorEvent::type_"]
        [::core::mem::offset_of!(SDL_GamepadSensorEvent, type_) - 0usize];
    ["Offset of field: SDL_GamepadSensorEvent::reserved"]
        [::core::mem::offset_of!(SDL_GamepadSensorEvent, reserved) - 4usize];
    ["Offset of field: SDL_GamepadSensorEvent::timestamp"]
        [::core::mem::offset_of!(SDL_GamepadSensorEvent, timestamp) - 8usize];
    ["Offset of field: SDL_GamepadSensorEvent::which"]
        [::core::mem::offset_of!(SDL_GamepadSensorEvent, which) - 16usize];
    ["Offset of field: SDL_GamepadSensorEvent::sensor"]
        [::core::mem::offset_of!(SDL_GamepadSensorEvent, sensor) - 20usize];
    ["Offset of field: SDL_GamepadSensorEvent::data"]
        [::core::mem::offset_of!(SDL_GamepadSensorEvent, data) - 24usize];
    ["Offset of field: SDL_GamepadSensorEvent::sensor_timestamp"]
        [::core::mem::offset_of!(SDL_GamepadSensorEvent, sensor_timestamp) - 40usize];
};
#[doc = " Audio device event structure (event.adevice.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AudioDeviceEvent {
    #[doc = "< SDL_EVENT_AUDIO_DEVICE_ADDED, or SDL_EVENT_AUDIO_DEVICE_REMOVED, or SDL_EVENT_AUDIO_DEVICE_FORMAT_CHANGED"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< SDL_AudioDeviceID for the device being added or removed or changing"]
    pub which: SDL_AudioDeviceID,
    #[doc = "< false if a playback device, true if a recording device."]
    pub recording: bool,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_AudioDeviceEvent"][::core::mem::size_of::<SDL_AudioDeviceEvent>() - 24usize];
    ["Alignment of SDL_AudioDeviceEvent"][::core::mem::align_of::<SDL_AudioDeviceEvent>() - 8usize];
    ["Offset of field: SDL_AudioDeviceEvent::type_"]
        [::core::mem::offset_of!(SDL_AudioDeviceEvent, type_) - 0usize];
    ["Offset of field: SDL_AudioDeviceEvent::reserved"]
        [::core::mem::offset_of!(SDL_AudioDeviceEvent, reserved) - 4usize];
    ["Offset of field: SDL_AudioDeviceEvent::timestamp"]
        [::core::mem::offset_of!(SDL_AudioDeviceEvent, timestamp) - 8usize];
    ["Offset of field: SDL_AudioDeviceEvent::which"]
        [::core::mem::offset_of!(SDL_AudioDeviceEvent, which) - 16usize];
    ["Offset of field: SDL_AudioDeviceEvent::recording"]
        [::core::mem::offset_of!(SDL_AudioDeviceEvent, recording) - 20usize];
    ["Offset of field: SDL_AudioDeviceEvent::padding1"]
        [::core::mem::offset_of!(SDL_AudioDeviceEvent, padding1) - 21usize];
    ["Offset of field: SDL_AudioDeviceEvent::padding2"]
        [::core::mem::offset_of!(SDL_AudioDeviceEvent, padding2) - 22usize];
    ["Offset of field: SDL_AudioDeviceEvent::padding3"]
        [::core::mem::offset_of!(SDL_AudioDeviceEvent, padding3) - 23usize];
};
#[doc = " Camera device event structure (event.cdevice.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_CameraDeviceEvent {
    #[doc = "< SDL_EVENT_CAMERA_DEVICE_ADDED, SDL_EVENT_CAMERA_DEVICE_REMOVED, SDL_EVENT_CAMERA_DEVICE_APPROVED, SDL_EVENT_CAMERA_DEVICE_DENIED"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< SDL_CameraID for the device being added or removed or changing"]
    pub which: SDL_CameraID,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_CameraDeviceEvent"][::core::mem::size_of::<SDL_CameraDeviceEvent>() - 24usize];
    ["Alignment of SDL_CameraDeviceEvent"]
        [::core::mem::align_of::<SDL_CameraDeviceEvent>() - 8usize];
    ["Offset of field: SDL_CameraDeviceEvent::type_"]
        [::core::mem::offset_of!(SDL_CameraDeviceEvent, type_) - 0usize];
    ["Offset of field: SDL_CameraDeviceEvent::reserved"]
        [::core::mem::offset_of!(SDL_CameraDeviceEvent, reserved) - 4usize];
    ["Offset of field: SDL_CameraDeviceEvent::timestamp"]
        [::core::mem::offset_of!(SDL_CameraDeviceEvent, timestamp) - 8usize];
    ["Offset of field: SDL_CameraDeviceEvent::which"]
        [::core::mem::offset_of!(SDL_CameraDeviceEvent, which) - 16usize];
};
#[doc = " Renderer event structure (event.render.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RenderEvent {
    #[doc = "< SDL_EVENT_RENDER_TARGETS_RESET, SDL_EVENT_RENDER_DEVICE_RESET, SDL_EVENT_RENDER_DEVICE_LOST"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window containing the renderer in question."]
    pub windowID: SDL_WindowID,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_RenderEvent"][::core::mem::size_of::<SDL_RenderEvent>() - 24usize];
    ["Alignment of SDL_RenderEvent"][::core::mem::align_of::<SDL_RenderEvent>() - 8usize];
    ["Offset of field: SDL_RenderEvent::type_"]
        [::core::mem::offset_of!(SDL_RenderEvent, type_) - 0usize];
    ["Offset of field: SDL_RenderEvent::reserved"]
        [::core::mem::offset_of!(SDL_RenderEvent, reserved) - 4usize];
    ["Offset of field: SDL_RenderEvent::timestamp"]
        [::core::mem::offset_of!(SDL_RenderEvent, timestamp) - 8usize];
    ["Offset of field: SDL_RenderEvent::windowID"]
        [::core::mem::offset_of!(SDL_RenderEvent, windowID) - 16usize];
};
#[doc = " Touch finger event structure (event.tfinger.*)\n\n Coordinates in this event are normalized. `x` and `y` are normalized to a\n range between 0.0f and 1.0f, relative to the window, so (0,0) is the top\n left and (1,1) is the bottom right. Delta coordinates `dx` and `dy` are\n normalized in the ranges of -1.0f (traversed all the way from the bottom or\n right to all the way up or left) to 1.0f (traversed all the way from the\n top or left to all the way down or right).\n\n Note that while the coordinates are _normalized_, they are not _clamped_,\n which means in some circumstances you can get a value outside of this\n range. For example, a renderer using logical presentation might give a\n negative value when the touch is in the letterboxing. Some platforms might\n report a touch outside of the window, which will also be outside of the\n range.\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_TouchFingerEvent {
    #[doc = "< SDL_EVENT_FINGER_DOWN, SDL_EVENT_FINGER_UP, SDL_EVENT_FINGER_MOTION, or SDL_EVENT_FINGER_CANCELED"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The touch device id"]
    pub touchID: SDL_TouchID,
    pub fingerID: SDL_FingerID,
    #[doc = "< Normalized in the range 0...1"]
    pub x: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub y: f32,
    #[doc = "< Normalized in the range -1...1"]
    pub dx: f32,
    #[doc = "< Normalized in the range -1...1"]
    pub dy: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub pressure: f32,
    #[doc = "< The window underneath the finger, if any"]
    pub windowID: SDL_WindowID,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_TouchFingerEvent"][::core::mem::size_of::<SDL_TouchFingerEvent>() - 56usize];
    ["Alignment of SDL_TouchFingerEvent"][::core::mem::align_of::<SDL_TouchFingerEvent>() - 8usize];
    ["Offset of field: SDL_TouchFingerEvent::type_"]
        [::core::mem::offset_of!(SDL_TouchFingerEvent, type_) - 0usize];
    ["Offset of field: SDL_TouchFingerEvent::reserved"]
        [::core::mem::offset_of!(SDL_TouchFingerEvent, reserved) - 4usize];
    ["Offset of field: SDL_TouchFingerEvent::timestamp"]
        [::core::mem::offset_of!(SDL_TouchFingerEvent, timestamp) - 8usize];
    ["Offset of field: SDL_TouchFingerEvent::touchID"]
        [::core::mem::offset_of!(SDL_TouchFingerEvent, touchID) - 16usize];
    ["Offset of field: SDL_TouchFingerEvent::fingerID"]
        [::core::mem::offset_of!(SDL_TouchFingerEvent, fingerID) - 24usize];
    ["Offset of field: SDL_TouchFingerEvent::x"]
        [::core::mem::offset_of!(SDL_TouchFingerEvent, x) - 32usize];
    ["Offset of field: SDL_TouchFingerEvent::y"]
        [::core::mem::offset_of!(SDL_TouchFingerEvent, y) - 36usize];
    ["Offset of field: SDL_TouchFingerEvent::dx"]
        [::core::mem::offset_of!(SDL_TouchFingerEvent, dx) - 40usize];
    ["Offset of field: SDL_TouchFingerEvent::dy"]
        [::core::mem::offset_of!(SDL_TouchFingerEvent, dy) - 44usize];
    ["Offset of field: SDL_TouchFingerEvent::pressure"]
        [::core::mem::offset_of!(SDL_TouchFingerEvent, pressure) - 48usize];
    ["Offset of field: SDL_TouchFingerEvent::windowID"]
        [::core::mem::offset_of!(SDL_TouchFingerEvent, windowID) - 52usize];
};
#[doc = " Pressure-sensitive pen proximity event structure (event.pmotion.*)\n\n When a pen becomes visible to the system (it is close enough to a tablet,\n etc), SDL will send an SDL_EVENT_PEN_PROXIMITY_IN event with the new pen's\n ID. This ID is valid until the pen leaves proximity again (has been removed\n from the tablet's area, the tablet has been unplugged, etc). If the same\n pen reenters proximity again, it will be given a new ID.\n\n Note that \"proximity\" means \"close enough for the tablet to know the tool\n is there.\" The pen touching and lifting off from the tablet while not\n leaving the area are handled by SDL_EVENT_PEN_DOWN and SDL_EVENT_PEN_UP.\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_PenProximityEvent {
    #[doc = "< SDL_EVENT_PEN_PROXIMITY_IN or SDL_EVENT_PEN_PROXIMITY_OUT"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with pen focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The pen instance id"]
    pub which: SDL_PenID,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_PenProximityEvent"][::core::mem::size_of::<SDL_PenProximityEvent>() - 24usize];
    ["Alignment of SDL_PenProximityEvent"]
        [::core::mem::align_of::<SDL_PenProximityEvent>() - 8usize];
    ["Offset of field: SDL_PenProximityEvent::type_"]
        [::core::mem::offset_of!(SDL_PenProximityEvent, type_) - 0usize];
    ["Offset of field: SDL_PenProximityEvent::reserved"]
        [::core::mem::offset_of!(SDL_PenProximityEvent, reserved) - 4usize];
    ["Offset of field: SDL_PenProximityEvent::timestamp"]
        [::core::mem::offset_of!(SDL_PenProximityEvent, timestamp) - 8usize];
    ["Offset of field: SDL_PenProximityEvent::windowID"]
        [::core::mem::offset_of!(SDL_PenProximityEvent, windowID) - 16usize];
    ["Offset of field: SDL_PenProximityEvent::which"]
        [::core::mem::offset_of!(SDL_PenProximityEvent, which) - 20usize];
};
#[doc = " Pressure-sensitive pen motion event structure (event.pmotion.*)\n\n Depending on the hardware, you may get motion events when the pen is not\n touching a tablet, for tracking a pen even when it isn't drawing. You\n should listen for SDL_EVENT_PEN_DOWN and SDL_EVENT_PEN_UP events, or check\n `pen_state & SDL_PEN_INPUT_DOWN` to decide if a pen is \"drawing\" when\n dealing with pen motion.\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_PenMotionEvent {
    #[doc = "< SDL_EVENT_PEN_MOTION"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with pen focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The pen instance id"]
    pub which: SDL_PenID,
    #[doc = "< Complete pen input state at time of event"]
    pub pen_state: SDL_PenInputFlags,
    #[doc = "< X coordinate, relative to window"]
    pub x: f32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_PenMotionEvent"][::core::mem::size_of::<SDL_PenMotionEvent>() - 40usize];
    ["Alignment of SDL_PenMotionEvent"][::core::mem::align_of::<SDL_PenMotionEvent>() - 8usize];
    ["Offset of field: SDL_PenMotionEvent::type_"]
        [::core::mem::offset_of!(SDL_PenMotionEvent, type_) - 0usize];
    ["Offset of field: SDL_PenMotionEvent::reserved"]
        [::core::mem::offset_of!(SDL_PenMotionEvent, reserved) - 4usize];
    ["Offset of field: SDL_PenMotionEvent::timestamp"]
        [::core::mem::offset_of!(SDL_PenMotionEvent, timestamp) - 8usize];
    ["Offset of field: SDL_PenMotionEvent::windowID"]
        [::core::mem::offset_of!(SDL_PenMotionEvent, windowID) - 16usize];
    ["Offset of field: SDL_PenMotionEvent::which"]
        [::core::mem::offset_of!(SDL_PenMotionEvent, which) - 20usize];
    ["Offset of field: SDL_PenMotionEvent::pen_state"]
        [::core::mem::offset_of!(SDL_PenMotionEvent, pen_state) - 24usize];
    ["Offset of field: SDL_PenMotionEvent::x"]
        [::core::mem::offset_of!(SDL_PenMotionEvent, x) - 28usize];
    ["Offset of field: SDL_PenMotionEvent::y"]
        [::core::mem::offset_of!(SDL_PenMotionEvent, y) - 32usize];
};
#[doc = " Pressure-sensitive pen touched event structure (event.ptouch.*)\n\n These events come when a pen touches a surface (a tablet, etc), or lifts\n off from one.\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_PenTouchEvent {
    #[doc = "< SDL_EVENT_PEN_DOWN or SDL_EVENT_PEN_UP"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with pen focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The pen instance id"]
    pub which: SDL_PenID,
    #[doc = "< Complete pen input state at time of event"]
    pub pen_state: SDL_PenInputFlags,
    #[doc = "< X coordinate, relative to window"]
    pub x: f32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: f32,
    #[doc = "< true if eraser end is used (not all pens support this)."]
    pub eraser: bool,
    #[doc = "< true if the pen is touching or false if the pen is lifted off"]
    pub down: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_PenTouchEvent"][::core::mem::size_of::<SDL_PenTouchEvent>() - 40usize];
    ["Alignment of SDL_PenTouchEvent"][::core::mem::align_of::<SDL_PenTouchEvent>() - 8usize];
    ["Offset of field: SDL_PenTouchEvent::type_"]
        [::core::mem::offset_of!(SDL_PenTouchEvent, type_) - 0usize];
    ["Offset of field: SDL_PenTouchEvent::reserved"]
        [::core::mem::offset_of!(SDL_PenTouchEvent, reserved) - 4usize];
    ["Offset of field: SDL_PenTouchEvent::timestamp"]
        [::core::mem::offset_of!(SDL_PenTouchEvent, timestamp) - 8usize];
    ["Offset of field: SDL_PenTouchEvent::windowID"]
        [::core::mem::offset_of!(SDL_PenTouchEvent, windowID) - 16usize];
    ["Offset of field: SDL_PenTouchEvent::which"]
        [::core::mem::offset_of!(SDL_PenTouchEvent, which) - 20usize];
    ["Offset of field: SDL_PenTouchEvent::pen_state"]
        [::core::mem::offset_of!(SDL_PenTouchEvent, pen_state) - 24usize];
    ["Offset of field: SDL_PenTouchEvent::x"]
        [::core::mem::offset_of!(SDL_PenTouchEvent, x) - 28usize];
    ["Offset of field: SDL_PenTouchEvent::y"]
        [::core::mem::offset_of!(SDL_PenTouchEvent, y) - 32usize];
    ["Offset of field: SDL_PenTouchEvent::eraser"]
        [::core::mem::offset_of!(SDL_PenTouchEvent, eraser) - 36usize];
    ["Offset of field: SDL_PenTouchEvent::down"]
        [::core::mem::offset_of!(SDL_PenTouchEvent, down) - 37usize];
};
#[doc = " Pressure-sensitive pen button event structure (event.pbutton.*)\n\n This is for buttons on the pen itself that the user might click. The pen\n itself pressing down to draw triggers a SDL_EVENT_PEN_DOWN event instead.\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_PenButtonEvent {
    #[doc = "< SDL_EVENT_PEN_BUTTON_DOWN or SDL_EVENT_PEN_BUTTON_UP"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The pen instance id"]
    pub which: SDL_PenID,
    #[doc = "< Complete pen input state at time of event"]
    pub pen_state: SDL_PenInputFlags,
    #[doc = "< X coordinate, relative to window"]
    pub x: f32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: f32,
    #[doc = "< The pen button index (first button is 1)."]
    pub button: Uint8,
    #[doc = "< true if the button is pressed"]
    pub down: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_PenButtonEvent"][::core::mem::size_of::<SDL_PenButtonEvent>() - 40usize];
    ["Alignment of SDL_PenButtonEvent"][::core::mem::align_of::<SDL_PenButtonEvent>() - 8usize];
    ["Offset of field: SDL_PenButtonEvent::type_"]
        [::core::mem::offset_of!(SDL_PenButtonEvent, type_) - 0usize];
    ["Offset of field: SDL_PenButtonEvent::reserved"]
        [::core::mem::offset_of!(SDL_PenButtonEvent, reserved) - 4usize];
    ["Offset of field: SDL_PenButtonEvent::timestamp"]
        [::core::mem::offset_of!(SDL_PenButtonEvent, timestamp) - 8usize];
    ["Offset of field: SDL_PenButtonEvent::windowID"]
        [::core::mem::offset_of!(SDL_PenButtonEvent, windowID) - 16usize];
    ["Offset of field: SDL_PenButtonEvent::which"]
        [::core::mem::offset_of!(SDL_PenButtonEvent, which) - 20usize];
    ["Offset of field: SDL_PenButtonEvent::pen_state"]
        [::core::mem::offset_of!(SDL_PenButtonEvent, pen_state) - 24usize];
    ["Offset of field: SDL_PenButtonEvent::x"]
        [::core::mem::offset_of!(SDL_PenButtonEvent, x) - 28usize];
    ["Offset of field: SDL_PenButtonEvent::y"]
        [::core::mem::offset_of!(SDL_PenButtonEvent, y) - 32usize];
    ["Offset of field: SDL_PenButtonEvent::button"]
        [::core::mem::offset_of!(SDL_PenButtonEvent, button) - 36usize];
    ["Offset of field: SDL_PenButtonEvent::down"]
        [::core::mem::offset_of!(SDL_PenButtonEvent, down) - 37usize];
};
#[doc = " Pressure-sensitive pen pressure / angle event structure (event.paxis.*)\n\n You might get some of these events even if the pen isn't touching the\n tablet.\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_PenAxisEvent {
    #[doc = "< SDL_EVENT_PEN_AXIS"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with pen focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The pen instance id"]
    pub which: SDL_PenID,
    #[doc = "< Complete pen input state at time of event"]
    pub pen_state: SDL_PenInputFlags,
    #[doc = "< X coordinate, relative to window"]
    pub x: f32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: f32,
    #[doc = "< Axis that has changed"]
    pub axis: SDL_PenAxis,
    #[doc = "< New value of axis"]
    pub value: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_PenAxisEvent"][::core::mem::size_of::<SDL_PenAxisEvent>() - 48usize];
    ["Alignment of SDL_PenAxisEvent"][::core::mem::align_of::<SDL_PenAxisEvent>() - 8usize];
    ["Offset of field: SDL_PenAxisEvent::type_"]
        [::core::mem::offset_of!(SDL_PenAxisEvent, type_) - 0usize];
    ["Offset of field: SDL_PenAxisEvent::reserved"]
        [::core::mem::offset_of!(SDL_PenAxisEvent, reserved) - 4usize];
    ["Offset of field: SDL_PenAxisEvent::timestamp"]
        [::core::mem::offset_of!(SDL_PenAxisEvent, timestamp) - 8usize];
    ["Offset of field: SDL_PenAxisEvent::windowID"]
        [::core::mem::offset_of!(SDL_PenAxisEvent, windowID) - 16usize];
    ["Offset of field: SDL_PenAxisEvent::which"]
        [::core::mem::offset_of!(SDL_PenAxisEvent, which) - 20usize];
    ["Offset of field: SDL_PenAxisEvent::pen_state"]
        [::core::mem::offset_of!(SDL_PenAxisEvent, pen_state) - 24usize];
    ["Offset of field: SDL_PenAxisEvent::x"]
        [::core::mem::offset_of!(SDL_PenAxisEvent, x) - 28usize];
    ["Offset of field: SDL_PenAxisEvent::y"]
        [::core::mem::offset_of!(SDL_PenAxisEvent, y) - 32usize];
    ["Offset of field: SDL_PenAxisEvent::axis"]
        [::core::mem::offset_of!(SDL_PenAxisEvent, axis) - 36usize];
    ["Offset of field: SDL_PenAxisEvent::value"]
        [::core::mem::offset_of!(SDL_PenAxisEvent, value) - 40usize];
};
#[doc = " An event used to drop text or request a file open by the system\n (event.drop.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_DropEvent {
    #[doc = "< SDL_EVENT_DROP_BEGIN or SDL_EVENT_DROP_FILE or SDL_EVENT_DROP_TEXT or SDL_EVENT_DROP_COMPLETE or SDL_EVENT_DROP_POSITION"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window that was dropped on, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< X coordinate, relative to window (not on begin)"]
    pub x: f32,
    #[doc = "< Y coordinate, relative to window (not on begin)"]
    pub y: f32,
    #[doc = "< The source app that sent this drop event, or NULL if that isn't available"]
    pub source: *const ::core::ffi::c_char,
    #[doc = "< The text for SDL_EVENT_DROP_TEXT and the file name for SDL_EVENT_DROP_FILE, NULL for other events"]
    pub data: *const ::core::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_DropEvent"][::core::mem::size_of::<SDL_DropEvent>() - 48usize];
    ["Alignment of SDL_DropEvent"][::core::mem::align_of::<SDL_DropEvent>() - 8usize];
    ["Offset of field: SDL_DropEvent::type_"]
        [::core::mem::offset_of!(SDL_DropEvent, type_) - 0usize];
    ["Offset of field: SDL_DropEvent::reserved"]
        [::core::mem::offset_of!(SDL_DropEvent, reserved) - 4usize];
    ["Offset of field: SDL_DropEvent::timestamp"]
        [::core::mem::offset_of!(SDL_DropEvent, timestamp) - 8usize];
    ["Offset of field: SDL_DropEvent::windowID"]
        [::core::mem::offset_of!(SDL_DropEvent, windowID) - 16usize];
    ["Offset of field: SDL_DropEvent::x"][::core::mem::offset_of!(SDL_DropEvent, x) - 20usize];
    ["Offset of field: SDL_DropEvent::y"][::core::mem::offset_of!(SDL_DropEvent, y) - 24usize];
    ["Offset of field: SDL_DropEvent::source"]
        [::core::mem::offset_of!(SDL_DropEvent, source) - 32usize];
    ["Offset of field: SDL_DropEvent::data"]
        [::core::mem::offset_of!(SDL_DropEvent, data) - 40usize];
};
#[doc = " An event triggered when the clipboard contents have changed\n (event.clipboard.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_ClipboardEvent {
    #[doc = "< SDL_EVENT_CLIPBOARD_UPDATE"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< are we owning the clipboard (internal update)"]
    pub owner: bool,
    #[doc = "< number of mime types"]
    pub num_mime_types: Sint32,
    #[doc = "< current mime types"]
    pub mime_types: *mut *const ::core::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_ClipboardEvent"][::core::mem::size_of::<SDL_ClipboardEvent>() - 32usize];
    ["Alignment of SDL_ClipboardEvent"][::core::mem::align_of::<SDL_ClipboardEvent>() - 8usize];
    ["Offset of field: SDL_ClipboardEvent::type_"]
        [::core::mem::offset_of!(SDL_ClipboardEvent, type_) - 0usize];
    ["Offset of field: SDL_ClipboardEvent::reserved"]
        [::core::mem::offset_of!(SDL_ClipboardEvent, reserved) - 4usize];
    ["Offset of field: SDL_ClipboardEvent::timestamp"]
        [::core::mem::offset_of!(SDL_ClipboardEvent, timestamp) - 8usize];
    ["Offset of field: SDL_ClipboardEvent::owner"]
        [::core::mem::offset_of!(SDL_ClipboardEvent, owner) - 16usize];
    ["Offset of field: SDL_ClipboardEvent::num_mime_types"]
        [::core::mem::offset_of!(SDL_ClipboardEvent, num_mime_types) - 20usize];
    ["Offset of field: SDL_ClipboardEvent::mime_types"]
        [::core::mem::offset_of!(SDL_ClipboardEvent, mime_types) - 24usize];
};
#[doc = " Sensor event structure (event.sensor.*)\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_SensorEvent {
    #[doc = "< SDL_EVENT_SENSOR_UPDATE"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The instance ID of the sensor"]
    pub which: SDL_SensorID,
    #[doc = "< Up to 6 values from the sensor - additional values can be queried using SDL_GetSensorData()"]
    pub data: [f32; 6usize],
    #[doc = "< The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock"]
    pub sensor_timestamp: Uint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_SensorEvent"][::core::mem::size_of::<SDL_SensorEvent>() - 56usize];
    ["Alignment of SDL_SensorEvent"][::core::mem::align_of::<SDL_SensorEvent>() - 8usize];
    ["Offset of field: SDL_SensorEvent::type_"]
        [::core::mem::offset_of!(SDL_SensorEvent, type_) - 0usize];
    ["Offset of field: SDL_SensorEvent::reserved"]
        [::core::mem::offset_of!(SDL_SensorEvent, reserved) - 4usize];
    ["Offset of field: SDL_SensorEvent::timestamp"]
        [::core::mem::offset_of!(SDL_SensorEvent, timestamp) - 8usize];
    ["Offset of field: SDL_SensorEvent::which"]
        [::core::mem::offset_of!(SDL_SensorEvent, which) - 16usize];
    ["Offset of field: SDL_SensorEvent::data"]
        [::core::mem::offset_of!(SDL_SensorEvent, data) - 20usize];
    ["Offset of field: SDL_SensorEvent::sensor_timestamp"]
        [::core::mem::offset_of!(SDL_SensorEvent, sensor_timestamp) - 48usize];
};
#[doc = " The \"quit requested\" event\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_QuitEvent {
    #[doc = "< SDL_EVENT_QUIT"]
    pub type_: SDL_EventType,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_QuitEvent"][::core::mem::size_of::<SDL_QuitEvent>() - 16usize];
    ["Alignment of SDL_QuitEvent"][::core::mem::align_of::<SDL_QuitEvent>() - 8usize];
    ["Offset of field: SDL_QuitEvent::type_"]
        [::core::mem::offset_of!(SDL_QuitEvent, type_) - 0usize];
    ["Offset of field: SDL_QuitEvent::reserved"]
        [::core::mem::offset_of!(SDL_QuitEvent, reserved) - 4usize];
    ["Offset of field: SDL_QuitEvent::timestamp"]
        [::core::mem::offset_of!(SDL_QuitEvent, timestamp) - 8usize];
};
#[doc = " A user-defined event type (event.user.*)\n\n This event is unique; it is never created by SDL, but only by the\n application. The event can be pushed onto the event queue using\n SDL_PushEvent(). The contents of the structure members are completely up to\n the programmer; the only requirement is that '''type''' is a value obtained\n from SDL_RegisterEvents().\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_UserEvent {
    #[doc = "< SDL_EVENT_USER through SDL_EVENT_LAST-1, Uint32 because these are not in the SDL_EventType enumeration"]
    pub type_: Uint32,
    pub reserved: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The associated window if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< User defined event code"]
    pub code: Sint32,
    #[doc = "< User defined data pointer"]
    pub data1: *mut ::core::ffi::c_void,
    #[doc = "< User defined data pointer"]
    pub data2: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_UserEvent"][::core::mem::size_of::<SDL_UserEvent>() - 40usize];
    ["Alignment of SDL_UserEvent"][::core::mem::align_of::<SDL_UserEvent>() - 8usize];
    ["Offset of field: SDL_UserEvent::type_"]
        [::core::mem::offset_of!(SDL_UserEvent, type_) - 0usize];
    ["Offset of field: SDL_UserEvent::reserved"]
        [::core::mem::offset_of!(SDL_UserEvent, reserved) - 4usize];
    ["Offset of field: SDL_UserEvent::timestamp"]
        [::core::mem::offset_of!(SDL_UserEvent, timestamp) - 8usize];
    ["Offset of field: SDL_UserEvent::windowID"]
        [::core::mem::offset_of!(SDL_UserEvent, windowID) - 16usize];
    ["Offset of field: SDL_UserEvent::code"]
        [::core::mem::offset_of!(SDL_UserEvent, code) - 20usize];
    ["Offset of field: SDL_UserEvent::data1"]
        [::core::mem::offset_of!(SDL_UserEvent, data1) - 24usize];
    ["Offset of field: SDL_UserEvent::data2"]
        [::core::mem::offset_of!(SDL_UserEvent, data2) - 32usize];
};
#[doc = " The structure for all events in SDL.\n\n The SDL_Event structure is the core of all event handling in SDL. SDL_Event\n is a union of all event structures used in SDL.\n\n \\since This struct is available since SDL 3.2.0."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_Event {
    #[doc = "< Event type, shared with all events, Uint32 to cover user events which are not in the SDL_EventType enumeration"]
    pub type_: Uint32,
    #[doc = "< Common event data"]
    pub common: SDL_CommonEvent,
    #[doc = "< Display event data"]
    pub display: SDL_DisplayEvent,
    #[doc = "< Window event data"]
    pub window: SDL_WindowEvent,
    #[doc = "< Keyboard device change event data"]
    pub kdevice: SDL_KeyboardDeviceEvent,
    #[doc = "< Keyboard event data"]
    pub key: SDL_KeyboardEvent,
    #[doc = "< Text editing event data"]
    pub edit: SDL_TextEditingEvent,
    #[doc = "< Text editing candidates event data"]
    pub edit_candidates: SDL_TextEditingCandidatesEvent,
    #[doc = "< Text input event data"]
    pub text: SDL_TextInputEvent,
    #[doc = "< Mouse device change event data"]
    pub mdevice: SDL_MouseDeviceEvent,
    #[doc = "< Mouse motion event data"]
    pub motion: SDL_MouseMotionEvent,
    #[doc = "< Mouse button event data"]
    pub button: SDL_MouseButtonEvent,
    #[doc = "< Mouse wheel event data"]
    pub wheel: SDL_MouseWheelEvent,
    #[doc = "< Joystick device change event data"]
    pub jdevice: SDL_JoyDeviceEvent,
    #[doc = "< Joystick axis event data"]
    pub jaxis: SDL_JoyAxisEvent,
    #[doc = "< Joystick ball event data"]
    pub jball: SDL_JoyBallEvent,
    #[doc = "< Joystick hat event data"]
    pub jhat: SDL_JoyHatEvent,
    #[doc = "< Joystick button event data"]
    pub jbutton: SDL_JoyButtonEvent,
    #[doc = "< Joystick battery event data"]
    pub jbattery: SDL_JoyBatteryEvent,
    #[doc = "< Gamepad device event data"]
    pub gdevice: SDL_GamepadDeviceEvent,
    #[doc = "< Gamepad axis event data"]
    pub gaxis: SDL_GamepadAxisEvent,
    #[doc = "< Gamepad button event data"]
    pub gbutton: SDL_GamepadButtonEvent,
    #[doc = "< Gamepad touchpad event data"]
    pub gtouchpad: SDL_GamepadTouchpadEvent,
    #[doc = "< Gamepad sensor event data"]
    pub gsensor: SDL_GamepadSensorEvent,
    #[doc = "< Audio device event data"]
    pub adevice: SDL_AudioDeviceEvent,
    #[doc = "< Camera device event data"]
    pub cdevice: SDL_CameraDeviceEvent,
    #[doc = "< Sensor event data"]
    pub sensor: SDL_SensorEvent,
    #[doc = "< Quit request event data"]
    pub quit: SDL_QuitEvent,
    #[doc = "< Custom event data"]
    pub user: SDL_UserEvent,
    #[doc = "< Touch finger event data"]
    pub tfinger: SDL_TouchFingerEvent,
    #[doc = "< Pen proximity event data"]
    pub pproximity: SDL_PenProximityEvent,
    #[doc = "< Pen tip touching event data"]
    pub ptouch: SDL_PenTouchEvent,
    #[doc = "< Pen motion event data"]
    pub pmotion: SDL_PenMotionEvent,
    #[doc = "< Pen button event data"]
    pub pbutton: SDL_PenButtonEvent,
    #[doc = "< Pen axis event data"]
    pub paxis: SDL_PenAxisEvent,
    #[doc = "< Render event data"]
    pub render: SDL_RenderEvent,
    #[doc = "< Drag and drop event data"]
    pub drop: SDL_DropEvent,
    #[doc = "< Clipboard event data"]
    pub clipboard: SDL_ClipboardEvent,
    pub padding: [Uint8; 128usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDL_Event"][::core::mem::size_of::<SDL_Event>() - 128usize];
    ["Alignment of SDL_Event"][::core::mem::align_of::<SDL_Event>() - 8usize];
    ["Offset of field: SDL_Event::type_"][::core::mem::offset_of!(SDL_Event, type_) - 0usize];
    ["Offset of field: SDL_Event::common"][::core::mem::offset_of!(SDL_Event, common) - 0usize];
    ["Offset of field: SDL_Event::display"][::core::mem::offset_of!(SDL_Event, display) - 0usize];
    ["Offset of field: SDL_Event::window"][::core::mem::offset_of!(SDL_Event, window) - 0usize];
    ["Offset of field: SDL_Event::kdevice"][::core::mem::offset_of!(SDL_Event, kdevice) - 0usize];
    ["Offset of field: SDL_Event::key"][::core::mem::offset_of!(SDL_Event, key) - 0usize];
    ["Offset of field: SDL_Event::edit"][::core::mem::offset_of!(SDL_Event, edit) - 0usize];
    ["Offset of field: SDL_Event::edit_candidates"]
        [::core::mem::offset_of!(SDL_Event, edit_candidates) - 0usize];
    ["Offset of field: SDL_Event::text"][::core::mem::offset_of!(SDL_Event, text) - 0usize];
    ["Offset of field: SDL_Event::mdevice"][::core::mem::offset_of!(SDL_Event, mdevice) - 0usize];
    ["Offset of field: SDL_Event::motion"][::core::mem::offset_of!(SDL_Event, motion) - 0usize];
    ["Offset of field: SDL_Event::button"][::core::mem::offset_of!(SDL_Event, button) - 0usize];
    ["Offset of field: SDL_Event::wheel"][::core::mem::offset_of!(SDL_Event, wheel) - 0usize];
    ["Offset of field: SDL_Event::jdevice"][::core::mem::offset_of!(SDL_Event, jdevice) - 0usize];
    ["Offset of field: SDL_Event::jaxis"][::core::mem::offset_of!(SDL_Event, jaxis) - 0usize];
    ["Offset of field: SDL_Event::jball"][::core::mem::offset_of!(SDL_Event, jball) - 0usize];
    ["Offset of field: SDL_Event::jhat"][::core::mem::offset_of!(SDL_Event, jhat) - 0usize];
    ["Offset of field: SDL_Event::jbutton"][::core::mem::offset_of!(SDL_Event, jbutton) - 0usize];
    ["Offset of field: SDL_Event::jbattery"][::core::mem::offset_of!(SDL_Event, jbattery) - 0usize];
    ["Offset of field: SDL_Event::gdevice"][::core::mem::offset_of!(SDL_Event, gdevice) - 0usize];
    ["Offset of field: SDL_Event::gaxis"][::core::mem::offset_of!(SDL_Event, gaxis) - 0usize];
    ["Offset of field: SDL_Event::gbutton"][::core::mem::offset_of!(SDL_Event, gbutton) - 0usize];
    ["Offset of field: SDL_Event::gtouchpad"]
        [::core::mem::offset_of!(SDL_Event, gtouchpad) - 0usize];
    ["Offset of field: SDL_Event::gsensor"][::core::mem::offset_of!(SDL_Event, gsensor) - 0usize];
    ["Offset of field: SDL_Event::adevice"][::core::mem::offset_of!(SDL_Event, adevice) - 0usize];
    ["Offset of field: SDL_Event::cdevice"][::core::mem::offset_of!(SDL_Event, cdevice) - 0usize];
    ["Offset of field: SDL_Event::sensor"][::core::mem::offset_of!(SDL_Event, sensor) - 0usize];
    ["Offset of field: SDL_Event::quit"][::core::mem::offset_of!(SDL_Event, quit) - 0usize];
    ["Offset of field: SDL_Event::user"][::core::mem::offset_of!(SDL_Event, user) - 0usize];
    ["Offset of field: SDL_Event::tfinger"][::core::mem::offset_of!(SDL_Event, tfinger) - 0usize];
    ["Offset of field: SDL_Event::pproximity"]
        [::core::mem::offset_of!(SDL_Event, pproximity) - 0usize];
    ["Offset of field: SDL_Event::ptouch"][::core::mem::offset_of!(SDL_Event, ptouch) - 0usize];
    ["Offset of field: SDL_Event::pmotion"][::core::mem::offset_of!(SDL_Event, pmotion) - 0usize];
    ["Offset of field: SDL_Event::pbutton"][::core::mem::offset_of!(SDL_Event, pbutton) - 0usize];
    ["Offset of field: SDL_Event::paxis"][::core::mem::offset_of!(SDL_Event, paxis) - 0usize];
    ["Offset of field: SDL_Event::render"][::core::mem::offset_of!(SDL_Event, render) - 0usize];
    ["Offset of field: SDL_Event::drop"][::core::mem::offset_of!(SDL_Event, drop) - 0usize];
    ["Offset of field: SDL_Event::clipboard"]
        [::core::mem::offset_of!(SDL_Event, clipboard) - 0usize];
    ["Offset of field: SDL_Event::padding"][::core::mem::offset_of!(SDL_Event, padding) - 0usize];
};
unsafe extern "C" {
    #[doc = " Pump the event loop, gathering events from the input devices.\n\n This function updates the event queue and internal input device state.\n\n SDL_PumpEvents() gathers all the pending input information from devices and\n places it in the event queue. Without calls to SDL_PumpEvents() no events\n would ever be placed on the queue. Often the need for calls to\n SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and\n SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not\n polling or waiting for events (e.g. you are filtering them), then you must\n call SDL_PumpEvents() to force an event queue update.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PollEvent\n \\sa SDL_WaitEvent"]
    pub fn SDL_PumpEvents();
}
#[doc = "< Add events to the back of the queue."]
pub const SDL_EventAction_SDL_ADDEVENT: SDL_EventAction = 0;
#[doc = "< Check but don't remove events from the queue front."]
pub const SDL_EventAction_SDL_PEEKEVENT: SDL_EventAction = 1;
#[doc = "< Retrieve/remove events from the front of the queue."]
pub const SDL_EventAction_SDL_GETEVENT: SDL_EventAction = 2;
#[doc = " The type of action to request from SDL_PeepEvents().\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_EventAction = ::core::ffi::c_uint;
unsafe extern "C" {
    #[doc = " Check the event queue for messages and optionally return them.\n\n `action` may be any of the following:\n\n - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the\n   event queue.\n - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,\n   within the specified minimum and maximum type, will be returned to the\n   caller and will _not_ be removed from the queue. If you pass NULL for\n   `events`, then `numevents` is ignored and the total number of matching\n   events will be returned.\n - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,\n   within the specified minimum and maximum type, will be returned to the\n   caller and will be removed from the queue.\n\n You may have to call SDL_PumpEvents() before calling this function.\n Otherwise, the events may not be ready to be filtered when you call\n SDL_PeepEvents().\n\n \\param events destination buffer for the retrieved events, may be NULL to\n               leave the events in the queue and return the number of events\n               that would have been stored.\n \\param numevents if action is SDL_ADDEVENT, the number of events to add\n                  back to the event queue; if action is SDL_PEEKEVENT or\n                  SDL_GETEVENT, the maximum number of events to retrieve.\n \\param action action to take; see [[#action|Remarks]] for details.\n \\param minType minimum value of the event type to be considered;\n                SDL_EVENT_FIRST is a safe choice.\n \\param maxType maximum value of the event type to be considered;\n                SDL_EVENT_LAST is a safe choice.\n \\returns the number of events actually stored or -1 on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PollEvent\n \\sa SDL_PumpEvents\n \\sa SDL_PushEvent"]
    pub fn SDL_PeepEvents(
        events: *mut SDL_Event,
        numevents: ::core::ffi::c_int,
        action: SDL_EventAction,
        minType: Uint32,
        maxType: Uint32,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Check for the existence of a certain event type in the event queue.\n\n If you need to check for a range of event types, use SDL_HasEvents()\n instead.\n\n \\param type the type of event to be queried; see SDL_EventType for details.\n \\returns true if events matching `type` are present, or false if events\n          matching `type` are not present.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_HasEvents"]
    pub fn SDL_HasEvent(type_: Uint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Check for the existence of certain event types in the event queue.\n\n If you need to check for a single event type, use SDL_HasEvent() instead.\n\n \\param minType the low end of event type to be queried, inclusive; see\n                SDL_EventType for details.\n \\param maxType the high end of event type to be queried, inclusive; see\n                SDL_EventType for details.\n \\returns true if events with type >= `minType` and <= `maxType` are\n          present, or false if not.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_HasEvents"]
    pub fn SDL_HasEvents(minType: Uint32, maxType: Uint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Clear events of a specific type from the event queue.\n\n This will unconditionally remove any events from the queue that match\n `type`. If you need to remove a range of event types, use SDL_FlushEvents()\n instead.\n\n It's also normal to just ignore events you don't care about in your event\n loop without calling this function.\n\n This function only affects currently queued events. If you want to make\n sure that all pending OS events are flushed, you can call SDL_PumpEvents()\n on the main thread immediately before the flush call.\n\n If you have user events with custom data that needs to be freed, you should\n use SDL_PeepEvents() to remove and clean up those events before calling\n this function.\n\n \\param type the type of event to be cleared; see SDL_EventType for details.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_FlushEvents"]
    pub fn SDL_FlushEvent(type_: Uint32);
}
unsafe extern "C" {
    #[doc = " Clear events of a range of types from the event queue.\n\n This will unconditionally remove any events from the queue that are in the\n range of `minType` to `maxType`, inclusive. If you need to remove a single\n event type, use SDL_FlushEvent() instead.\n\n It's also normal to just ignore events you don't care about in your event\n loop without calling this function.\n\n This function only affects currently queued events. If you want to make\n sure that all pending OS events are flushed, you can call SDL_PumpEvents()\n on the main thread immediately before the flush call.\n\n \\param minType the low end of event type to be cleared, inclusive; see\n                SDL_EventType for details.\n \\param maxType the high end of event type to be cleared, inclusive; see\n                SDL_EventType for details.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_FlushEvent"]
    pub fn SDL_FlushEvents(minType: Uint32, maxType: Uint32);
}
unsafe extern "C" {
    #[doc = " Poll for currently pending events.\n\n If `event` is not NULL, the next event is removed from the queue and stored\n in the SDL_Event structure pointed to by `event`. The 1 returned refers to\n this event, immediately stored in the SDL Event structure -- not an event\n to follow.\n\n If `event` is NULL, it simply returns 1 if there is an event in the queue,\n but will not remove it from the queue.\n\n As this function may implicitly call SDL_PumpEvents(), you can only call\n this function in the thread that set the video mode.\n\n SDL_PollEvent() is the favored way of receiving system events since it can\n be done from the main loop and does not suspend the main loop while waiting\n on an event to be posted.\n\n The common practice is to fully process the event queue once every frame,\n usually as a first step before updating the game's state:\n\n ```c\n while (game_is_still_running) {\n     SDL_Event event;\n     while (SDL_PollEvent(&event)) {  // poll until all events are handled!\n         // decide what to do with this event.\n     }\n\n     // update game state, draw the current frame\n }\n ```\n\n \\param event the SDL_Event structure to be filled with the next event from\n              the queue, or NULL.\n \\returns true if this got an event or false if there are none available.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PushEvent\n \\sa SDL_WaitEvent\n \\sa SDL_WaitEventTimeout"]
    pub fn SDL_PollEvent(event: *mut SDL_Event) -> bool;
}
unsafe extern "C" {
    #[doc = " Wait indefinitely for the next available event.\n\n If `event` is not NULL, the next event is removed from the queue and stored\n in the SDL_Event structure pointed to by `event`.\n\n As this function may implicitly call SDL_PumpEvents(), you can only call\n this function in the thread that initialized the video subsystem.\n\n \\param event the SDL_Event structure to be filled in with the next event\n              from the queue, or NULL.\n \\returns true on success or false if there was an error while waiting for\n          events; call SDL_GetError() for more information.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PollEvent\n \\sa SDL_PushEvent\n \\sa SDL_WaitEventTimeout"]
    pub fn SDL_WaitEvent(event: *mut SDL_Event) -> bool;
}
unsafe extern "C" {
    #[doc = " Wait until the specified timeout (in milliseconds) for the next available\n event.\n\n If `event` is not NULL, the next event is removed from the queue and stored\n in the SDL_Event structure pointed to by `event`.\n\n As this function may implicitly call SDL_PumpEvents(), you can only call\n this function in the thread that initialized the video subsystem.\n\n The timeout is not guaranteed, the actual wait time could be longer due to\n system scheduling.\n\n \\param event the SDL_Event structure to be filled in with the next event\n              from the queue, or NULL.\n \\param timeoutMS the maximum number of milliseconds to wait for the next\n                  available event.\n \\returns true if this got an event or false if the timeout elapsed without\n          any events available.\n\n \\threadsafety This function should only be called on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PollEvent\n \\sa SDL_PushEvent\n \\sa SDL_WaitEvent"]
    pub fn SDL_WaitEventTimeout(event: *mut SDL_Event, timeoutMS: Sint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Add an event to the event queue.\n\n The event queue can actually be used as a two way communication channel.\n Not only can events be read from the queue, but the user can also push\n their own events onto it. `event` is a pointer to the event structure you\n wish to push onto the queue. The event is copied into the queue, and the\n caller may dispose of the memory pointed to after SDL_PushEvent() returns.\n\n Note: Pushing device input events onto the queue doesn't modify the state\n of the device within SDL.\n\n Note: Events pushed onto the queue with SDL_PushEvent() get passed through\n the event filter but events added with SDL_PeepEvents() do not.\n\n For pushing application-specific events, please use SDL_RegisterEvents() to\n get an event type that does not conflict with other code that also wants\n its own custom event types.\n\n \\param event the SDL_Event to be added to the queue.\n \\returns true on success, false if the event was filtered or on failure;\n          call SDL_GetError() for more information. A common reason for\n          error is the event queue being full.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PeepEvents\n \\sa SDL_PollEvent\n \\sa SDL_RegisterEvents"]
    pub fn SDL_PushEvent(event: *mut SDL_Event) -> bool;
}
#[doc = " A function pointer used for callbacks that watch the event queue.\n\n \\param userdata what was passed as `userdata` to SDL_SetEventFilter() or\n                 SDL_AddEventWatch, etc.\n \\param event the event that triggered the callback.\n \\returns true to permit event to be added to the queue, and false to\n          disallow it. When used with SDL_AddEventWatch, the return value is\n          ignored.\n\n \\threadsafety SDL may call this callback at any time from any thread; the\n               application is responsible for locking resources the callback\n               touches that need to be protected.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_SetEventFilter\n \\sa SDL_AddEventWatch"]
pub type SDL_EventFilter = ::core::option::Option<
    unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void, event: *mut SDL_Event) -> bool,
>;
unsafe extern "C" {
    #[doc = " Set up a filter to process all events before they are added to the internal\n event queue.\n\n If you just want to see events without modifying them or preventing them\n from being queued, you should use SDL_AddEventWatch() instead.\n\n If the filter function returns true when called, then the event will be\n added to the internal queue. If it returns false, then the event will be\n dropped from the queue, but the internal state will still be updated. This\n allows selective filtering of dynamically arriving events.\n\n **WARNING**: Be very careful of what you do in the event filter function,\n as it may run in a different thread!\n\n On platforms that support it, if the quit event is generated by an\n interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the\n application at the next event poll.\n\n Note: Disabled events never make it to the event filter function; see\n SDL_SetEventEnabled().\n\n Note: Events pushed onto the queue with SDL_PushEvent() get passed through\n the event filter, but events pushed onto the queue with SDL_PeepEvents() do\n not.\n\n \\param filter an SDL_EventFilter function to call when an event happens.\n \\param userdata a pointer that is passed to `filter`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AddEventWatch\n \\sa SDL_SetEventEnabled\n \\sa SDL_GetEventFilter\n \\sa SDL_PeepEvents\n \\sa SDL_PushEvent"]
    pub fn SDL_SetEventFilter(filter: SDL_EventFilter, userdata: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = " Query the current event filter.\n\n This function can be used to \"chain\" filters, by saving the existing filter\n before replacing it with a function that will call that saved filter.\n\n \\param filter the current callback function will be stored here.\n \\param userdata the pointer that is passed to the current event filter will\n                 be stored here.\n \\returns true on success or false if there is no event filter set.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetEventFilter"]
    pub fn SDL_GetEventFilter(
        filter: *mut SDL_EventFilter,
        userdata: *mut *mut ::core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Add a callback to be triggered when an event is added to the event queue.\n\n `filter` will be called when an event happens, and its return value is\n ignored.\n\n **WARNING**: Be very careful of what you do in the event filter function,\n as it may run in a different thread!\n\n If the quit event is generated by a signal (e.g. SIGINT), it will bypass\n the internal queue and be delivered to the watch callback immediately, and\n arrive at the next event poll.\n\n Note: the callback is called for events posted by the user through\n SDL_PushEvent(), but not for disabled events, nor for events by a filter\n callback set with SDL_SetEventFilter(), nor for events posted by the user\n through SDL_PeepEvents().\n\n \\param filter an SDL_EventFilter function to call when an event happens.\n \\param userdata a pointer that is passed to `filter`.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_RemoveEventWatch\n \\sa SDL_SetEventFilter"]
    pub fn SDL_AddEventWatch(filter: SDL_EventFilter, userdata: *mut ::core::ffi::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " Remove an event watch callback added with SDL_AddEventWatch().\n\n This function takes the same input as SDL_AddEventWatch() to identify and\n delete the corresponding callback.\n\n \\param filter the function originally passed to SDL_AddEventWatch().\n \\param userdata the pointer originally passed to SDL_AddEventWatch().\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AddEventWatch"]
    pub fn SDL_RemoveEventWatch(filter: SDL_EventFilter, userdata: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = " Run a specific filter function on the current event queue, removing any\n events for which the filter returns false.\n\n See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),\n this function does not change the filter permanently, it only uses the\n supplied filter until this function returns.\n\n \\param filter the SDL_EventFilter function to call when an event happens.\n \\param userdata a pointer that is passed to `filter`.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetEventFilter\n \\sa SDL_SetEventFilter"]
    pub fn SDL_FilterEvents(filter: SDL_EventFilter, userdata: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = " Set the state of processing events by type.\n\n \\param type the type of event; see SDL_EventType for details.\n \\param enabled whether to process the event or not.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_EventEnabled"]
    pub fn SDL_SetEventEnabled(type_: Uint32, enabled: bool);
}
unsafe extern "C" {
    #[doc = " Query the state of processing events by type.\n\n \\param type the type of event; see SDL_EventType for details.\n \\returns true if the event is being processed, false otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetEventEnabled"]
    pub fn SDL_EventEnabled(type_: Uint32) -> bool;
}
unsafe extern "C" {
    #[doc = " Allocate a set of user-defined events, and return the beginning event\n number for that set of events.\n\n \\param numevents the number of events to be allocated.\n \\returns the beginning event number, or 0 if numevents is invalid or if\n          there are not enough user-defined events left.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PushEvent"]
    pub fn SDL_RegisterEvents(numevents: ::core::ffi::c_int) -> Uint32;
}
unsafe extern "C" {
    #[doc = " Get window associated with an event.\n\n \\param event an event containing a `windowID`.\n \\returns the associated window on success or NULL if there is none.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_PollEvent\n \\sa SDL_WaitEvent\n \\sa SDL_WaitEventTimeout"]
    pub fn SDL_GetWindowFromEvent(event: *const SDL_Event) -> *mut SDL_Window;
}
#[doc = " Initialization flags for SDL_Init and/or SDL_InitSubSystem\n\n These are the flags which may be passed to SDL_Init(). You should specify\n the subsystems which you will be using in your application.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_Init\n \\sa SDL_Quit\n \\sa SDL_InitSubSystem\n \\sa SDL_QuitSubSystem\n \\sa SDL_WasInit"]
pub type SDL_InitFlags = Uint32;
#[doc = "< Value that requests that the app continue from the main callbacks."]
pub const SDL_AppResult_SDL_APP_CONTINUE: SDL_AppResult = 0;
#[doc = "< Value that requests termination with success from the main callbacks."]
pub const SDL_AppResult_SDL_APP_SUCCESS: SDL_AppResult = 1;
#[doc = "< Value that requests termination with error from the main callbacks."]
pub const SDL_AppResult_SDL_APP_FAILURE: SDL_AppResult = 2;
#[doc = " Return values for optional main callbacks.\n\n Returning SDL_APP_SUCCESS or SDL_APP_FAILURE from SDL_AppInit,\n SDL_AppEvent, or SDL_AppIterate will terminate the program and report\n success/failure to the operating system. What that means is\n platform-dependent. On Unix, for example, on success, the process error\n code will be zero, and on failure it will be 1. This interface doesn't\n allow you to return specific exit codes, just whether there was an error\n generally or not.\n\n Returning SDL_APP_CONTINUE from these functions will let the app continue\n to run.\n\n See\n [Main callbacks in SDL3](https://wiki.libsdl.org/SDL3/README/main-functions#main-callbacks-in-sdl3)\n for complete details.\n\n \\since This enum is available since SDL 3.2.0."]
pub type SDL_AppResult = ::core::ffi::c_uint;
#[doc = " Function pointer typedef for SDL_AppInit.\n\n These are used by SDL_EnterAppMainCallbacks. This mechanism operates behind\n the scenes for apps using the optional main callbacks. Apps that want to\n use this should just implement SDL_AppInit directly.\n\n \\param appstate a place where the app can optionally store a pointer for\n                 future use.\n \\param argc the standard ANSI C main's argc; number of elements in `argv`.\n \\param argv the standard ANSI C main's argv; array of command line\n             arguments.\n \\returns SDL_APP_FAILURE to terminate with an error, SDL_APP_SUCCESS to\n          terminate with success, SDL_APP_CONTINUE to continue.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_AppInit_func = ::core::option::Option<
    unsafe extern "C" fn(
        appstate: *mut *mut ::core::ffi::c_void,
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    ) -> SDL_AppResult,
>;
#[doc = " Function pointer typedef for SDL_AppIterate.\n\n These are used by SDL_EnterAppMainCallbacks. This mechanism operates behind\n the scenes for apps using the optional main callbacks. Apps that want to\n use this should just implement SDL_AppIterate directly.\n\n \\param appstate an optional pointer, provided by the app in SDL_AppInit.\n \\returns SDL_APP_FAILURE to terminate with an error, SDL_APP_SUCCESS to\n          terminate with success, SDL_APP_CONTINUE to continue.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_AppIterate_func = ::core::option::Option<
    unsafe extern "C" fn(appstate: *mut ::core::ffi::c_void) -> SDL_AppResult,
>;
#[doc = " Function pointer typedef for SDL_AppEvent.\n\n These are used by SDL_EnterAppMainCallbacks. This mechanism operates behind\n the scenes for apps using the optional main callbacks. Apps that want to\n use this should just implement SDL_AppEvent directly.\n\n \\param appstate an optional pointer, provided by the app in SDL_AppInit.\n \\param event the new event for the app to examine.\n \\returns SDL_APP_FAILURE to terminate with an error, SDL_APP_SUCCESS to\n          terminate with success, SDL_APP_CONTINUE to continue.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_AppEvent_func = ::core::option::Option<
    unsafe extern "C" fn(
        appstate: *mut ::core::ffi::c_void,
        event: *mut SDL_Event,
    ) -> SDL_AppResult,
>;
#[doc = " Function pointer typedef for SDL_AppQuit.\n\n These are used by SDL_EnterAppMainCallbacks. This mechanism operates behind\n the scenes for apps using the optional main callbacks. Apps that want to\n use this should just implement SDL_AppEvent directly.\n\n \\param appstate an optional pointer, provided by the app in SDL_AppInit.\n \\param result the result code that terminated the app (success or failure).\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_AppQuit_func = ::core::option::Option<
    unsafe extern "C" fn(appstate: *mut ::core::ffi::c_void, result: SDL_AppResult),
>;
unsafe extern "C" {
    #[doc = " Initialize the SDL library.\n\n SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the\n two may be used interchangeably. Though for readability of your code\n SDL_InitSubSystem() might be preferred.\n\n The file I/O (for example: SDL_IOFromFile) and threading (SDL_CreateThread)\n subsystems are initialized by default. Message boxes\n (SDL_ShowSimpleMessageBox) also attempt to work without initializing the\n video subsystem, in hopes of being useful in showing an error dialog when\n SDL_Init fails. You must specifically initialize other subsystems if you\n use them in your application.\n\n Logging (such as SDL_Log) works without initialization, too.\n\n `flags` may be any of the following OR'd together:\n\n - `SDL_INIT_AUDIO`: audio subsystem; automatically initializes the events\n   subsystem\n - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events\n   subsystem, should be initialized on the main thread.\n - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the\n   events subsystem\n - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem\n - `SDL_INIT_GAMEPAD`: gamepad subsystem; automatically initializes the\n   joystick subsystem\n - `SDL_INIT_EVENTS`: events subsystem\n - `SDL_INIT_SENSOR`: sensor subsystem; automatically initializes the events\n   subsystem\n - `SDL_INIT_CAMERA`: camera subsystem; automatically initializes the events\n   subsystem\n\n Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()\n for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or\n call SDL_Quit() to force shutdown). If a subsystem is already loaded then\n this call will increase the ref-count and return.\n\n Consider reporting some basic metadata about your application before\n calling SDL_Init, using either SDL_SetAppMetadata() or\n SDL_SetAppMetadataProperty().\n\n \\param flags subsystem initialization flags.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAppMetadata\n \\sa SDL_SetAppMetadataProperty\n \\sa SDL_InitSubSystem\n \\sa SDL_Quit\n \\sa SDL_SetMainReady\n \\sa SDL_WasInit"]
    pub fn SDL_Init(flags: SDL_InitFlags) -> bool;
}
unsafe extern "C" {
    #[doc = " Compatibility function to initialize the SDL library.\n\n This function and SDL_Init() are interchangeable.\n\n \\param flags any of the flags used by SDL_Init(); see SDL_Init for details.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_Init\n \\sa SDL_Quit\n \\sa SDL_QuitSubSystem"]
    pub fn SDL_InitSubSystem(flags: SDL_InitFlags) -> bool;
}
unsafe extern "C" {
    #[doc = " Shut down specific SDL subsystems.\n\n You still need to call SDL_Quit() even if you close all open subsystems\n with SDL_QuitSubSystem().\n\n \\param flags any of the flags used by SDL_Init(); see SDL_Init for details.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_InitSubSystem\n \\sa SDL_Quit"]
    pub fn SDL_QuitSubSystem(flags: SDL_InitFlags);
}
unsafe extern "C" {
    #[doc = " Get a mask of the specified subsystems which are currently initialized.\n\n \\param flags any of the flags used by SDL_Init(); see SDL_Init for details.\n \\returns a mask of all initialized subsystems if `flags` is 0, otherwise it\n          returns the initialization status of the specified subsystems.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_Init\n \\sa SDL_InitSubSystem"]
    pub fn SDL_WasInit(flags: SDL_InitFlags) -> SDL_InitFlags;
}
unsafe extern "C" {
    #[doc = " Clean up all initialized subsystems.\n\n You should call this function even if you have already shutdown each\n initialized subsystem with SDL_QuitSubSystem(). It is safe to call this\n function even in the case of errors in initialization.\n\n You can use this function with atexit() to ensure that it is run when your\n application is shutdown, but it is not wise to do this from a library or\n other dynamically loaded code.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_Init\n \\sa SDL_QuitSubSystem"]
    pub fn SDL_Quit();
}
unsafe extern "C" {
    #[doc = " Return whether this is the main thread.\n\n On Apple platforms, the main thread is the thread that runs your program's\n main() entry point. On other platforms, the main thread is the one that\n calls SDL_Init(SDL_INIT_VIDEO), which should usually be the one that runs\n your program's main() entry point. If you are using the main callbacks,\n SDL_AppInit(), SDL_AppIterate(), and SDL_AppQuit() are all called on the\n main thread.\n\n \\returns true if this thread is the main thread, or false otherwise.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_RunOnMainThread"]
    pub fn SDL_IsMainThread() -> bool;
}
#[doc = " Callback run on the main thread.\n\n \\param userdata an app-controlled pointer that is passed to the callback.\n\n \\since This datatype is available since SDL 3.2.0.\n\n \\sa SDL_RunOnMainThread"]
pub type SDL_MainThreadCallback =
    ::core::option::Option<unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = " Call a function on the main thread during event processing.\n\n If this is called on the main thread, the callback is executed immediately.\n If this is called on another thread, this callback is queued for execution\n on the main thread during event processing.\n\n Be careful of deadlocks when using this functionality. You should not have\n the main thread wait for the current thread while this function is being\n called with `wait_complete` true.\n\n \\param callback the callback to call on the main thread.\n \\param userdata a pointer that is passed to `callback`.\n \\param wait_complete true to wait for the callback to complete, false to\n                      return immediately.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_IsMainThread"]
    pub fn SDL_RunOnMainThread(
        callback: SDL_MainThreadCallback,
        userdata: *mut ::core::ffi::c_void,
        wait_complete: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Specify basic metadata about your app.\n\n You can optionally provide metadata about your app to SDL. This is not\n required, but strongly encouraged.\n\n There are several locations where SDL can make use of metadata (an \"About\"\n box in the macOS menu bar, the name of the app can be shown on some audio\n mixers, etc). Any piece of metadata can be left as NULL, if a specific\n detail doesn't make sense for the app.\n\n This function should be called as early as possible, before SDL_Init.\n Multiple calls to this function are allowed, but various state might not\n change once it has been set up with a previous call to this function.\n\n Passing a NULL removes any previous metadata.\n\n This is a simplified interface for the most important information. You can\n supply significantly more detailed metadata with\n SDL_SetAppMetadataProperty().\n\n \\param appname The name of the application (\"My Game 2: Bad Guy's\n                Revenge!\").\n \\param appversion The version of the application (\"1.0.0beta5\" or a git\n                   hash, or whatever makes sense).\n \\param appidentifier A unique string in reverse-domain format that\n                      identifies this app (\"com.example.mygame2\").\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAppMetadataProperty"]
    pub fn SDL_SetAppMetadata(
        appname: *const ::core::ffi::c_char,
        appversion: *const ::core::ffi::c_char,
        appidentifier: *const ::core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Specify metadata about your app through a set of properties.\n\n You can optionally provide metadata about your app to SDL. This is not\n required, but strongly encouraged.\n\n There are several locations where SDL can make use of metadata (an \"About\"\n box in the macOS menu bar, the name of the app can be shown on some audio\n mixers, etc). Any piece of metadata can be left out, if a specific detail\n doesn't make sense for the app.\n\n This function should be called as early as possible, before SDL_Init.\n Multiple calls to this function are allowed, but various state might not\n change once it has been set up with a previous call to this function.\n\n Once set, this metadata can be read using SDL_GetAppMetadataProperty().\n\n These are the supported properties:\n\n - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the\n   application, like \"My Game 2: Bad Guy's Revenge!\". This will show up\n   anywhere the OS shows the name of the application separately from window\n   titles, such as volume control applets, etc. This defaults to \"SDL\n   Application\".\n - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is\n   running; there are no rules on format, so \"1.0.3beta2\" and \"April 22nd,\n   2024\" and a git hash are all valid options. This has no default.\n - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that\n   identifies this app. This must be in reverse-domain format, like\n   \"com.example.mygame2\". This string is used by desktop compositors to\n   identify and group windows together, as well as match applications with\n   associated desktop settings and icons. If you plan to package your\n   application in a container such as Flatpak, the app ID should match the\n   name of your Flatpak container as well. This has no default.\n - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the\n   creator/developer/maker of this app, like \"MojoWorkshop, LLC\"\n - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright\n   notice, like \"Copyright (c) 2024 MojoWorkshop, LLC\" or whatnot. Keep this\n   to one line, don't paste a copy of a whole software license in here. This\n   has no default.\n - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a\n   product page, or a storefront, or even a GitHub repository, for user's\n   further information This has no default.\n - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.\n   Currently this string can be \"game\" for a video game, \"mediaplayer\" for a\n   media player, or generically \"application\" if nothing else applies.\n   Future versions of SDL might add new types. This defaults to\n   \"application\".\n\n \\param name the name of the metadata property to set.\n \\param value the value of the property, or NULL to remove that property.\n \\returns true on success or false on failure; call SDL_GetError() for more\n          information.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_GetAppMetadataProperty\n \\sa SDL_SetAppMetadata"]
    pub fn SDL_SetAppMetadataProperty(
        name: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get metadata about your app.\n\n This returns metadata previously set using SDL_SetAppMetadata() or\n SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list\n of available properties and their meanings.\n\n \\param name the name of the metadata property to get.\n \\returns the current value of the metadata property, or the default if it\n          is not set, NULL for properties with no default.\n\n \\threadsafety It is safe to call this function from any thread, although\n               the string returned is not protected and could potentially be\n               freed if you call SDL_SetAppMetadataProperty() to set that\n               property from another thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_SetAppMetadata\n \\sa SDL_SetAppMetadataProperty"]
    pub fn SDL_GetAppMetadataProperty(
        name: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " App-implemented initial entry point for SDL_MAIN_USE_CALLBACKS apps.\n\n Apps implement this function when using SDL_MAIN_USE_CALLBACKS. If using a\n standard \"main\" function, you should not supply this.\n\n This function is called by SDL once, at startup. The function should\n initialize whatever is necessary, possibly create windows and open audio\n devices, etc. The `argc` and `argv` parameters work like they would with a\n standard \"main\" function.\n\n This function should not go into an infinite mainloop; it should do any\n one-time setup it requires and then return.\n\n The app may optionally assign a pointer to `*appstate`. This pointer will\n be provided on every future call to the other entry points, to allow\n application state to be preserved between functions without the app needing\n to use a global variable. If this isn't set, the pointer will be NULL in\n future entry points.\n\n If this function returns SDL_APP_CONTINUE, the app will proceed to normal\n operation, and will begin receiving repeated calls to SDL_AppIterate and\n SDL_AppEvent for the life of the program. If this function returns\n SDL_APP_FAILURE, SDL will call SDL_AppQuit and terminate the process with\n an exit code that reports an error to the platform. If it returns\n SDL_APP_SUCCESS, SDL calls SDL_AppQuit and terminates with an exit code\n that reports success to the platform.\n\n This function is called by SDL on the main thread.\n\n \\param appstate a place where the app can optionally store a pointer for\n                 future use.\n \\param argc the standard ANSI C main's argc; number of elements in `argv`.\n \\param argv the standard ANSI C main's argv; array of command line\n             arguments.\n \\returns SDL_APP_FAILURE to terminate with an error, SDL_APP_SUCCESS to\n          terminate with success, SDL_APP_CONTINUE to continue.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AppIterate\n \\sa SDL_AppEvent\n \\sa SDL_AppQuit"]
    pub fn SDL_AppInit(
        appstate: *mut *mut ::core::ffi::c_void,
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    ) -> SDL_AppResult;
}
unsafe extern "C" {
    #[doc = " App-implemented iteration entry point for SDL_MAIN_USE_CALLBACKS apps.\n\n Apps implement this function when using SDL_MAIN_USE_CALLBACKS. If using a\n standard \"main\" function, you should not supply this.\n\n This function is called repeatedly by SDL after SDL_AppInit returns 0. The\n function should operate as a single iteration the program's primary loop;\n it should update whatever state it needs and draw a new frame of video,\n usually.\n\n On some platforms, this function will be called at the refresh rate of the\n display (which might change during the life of your app!). There are no\n promises made about what frequency this function might run at. You should\n use SDL's timer functions if you need to see how much time has passed since\n the last iteration.\n\n There is no need to process the SDL event queue during this function; SDL\n will send events as they arrive in SDL_AppEvent, and in most cases the\n event queue will be empty when this function runs anyhow.\n\n This function should not go into an infinite mainloop; it should do one\n iteration of whatever the program does and return.\n\n The `appstate` parameter is an optional pointer provided by the app during\n SDL_AppInit(). If the app never provided a pointer, this will be NULL.\n\n If this function returns SDL_APP_CONTINUE, the app will continue normal\n operation, receiving repeated calls to SDL_AppIterate and SDL_AppEvent for\n the life of the program. If this function returns SDL_APP_FAILURE, SDL will\n call SDL_AppQuit and terminate the process with an exit code that reports\n an error to the platform. If it returns SDL_APP_SUCCESS, SDL calls\n SDL_AppQuit and terminates with an exit code that reports success to the\n platform.\n\n This function is called by SDL on the main thread.\n\n \\param appstate an optional pointer, provided by the app in SDL_AppInit.\n \\returns SDL_APP_FAILURE to terminate with an error, SDL_APP_SUCCESS to\n          terminate with success, SDL_APP_CONTINUE to continue.\n\n \\threadsafety This function may get called concurrently with SDL_AppEvent()\n               for events not pushed on the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AppInit\n \\sa SDL_AppEvent"]
    pub fn SDL_AppIterate(appstate: *mut ::core::ffi::c_void) -> SDL_AppResult;
}
unsafe extern "C" {
    #[doc = " App-implemented event entry point for SDL_MAIN_USE_CALLBACKS apps.\n\n Apps implement this function when using SDL_MAIN_USE_CALLBACKS. If using a\n standard \"main\" function, you should not supply this.\n\n This function is called as needed by SDL after SDL_AppInit returns\n SDL_APP_CONTINUE. It is called once for each new event.\n\n There is (currently) no guarantee about what thread this will be called\n from; whatever thread pushes an event onto SDL's queue will trigger this\n function. SDL is responsible for pumping the event queue between each call\n to SDL_AppIterate, so in normal operation one should only get events in a\n serial fashion, but be careful if you have a thread that explicitly calls\n SDL_PushEvent. SDL itself will push events to the queue on the main thread.\n\n Events sent to this function are not owned by the app; if you need to save\n the data, you should copy it.\n\n This function should not go into an infinite mainloop; it should handle the\n provided event appropriately and return.\n\n The `appstate` parameter is an optional pointer provided by the app during\n SDL_AppInit(). If the app never provided a pointer, this will be NULL.\n\n If this function returns SDL_APP_CONTINUE, the app will continue normal\n operation, receiving repeated calls to SDL_AppIterate and SDL_AppEvent for\n the life of the program. If this function returns SDL_APP_FAILURE, SDL will\n call SDL_AppQuit and terminate the process with an exit code that reports\n an error to the platform. If it returns SDL_APP_SUCCESS, SDL calls\n SDL_AppQuit and terminates with an exit code that reports success to the\n platform.\n\n \\param appstate an optional pointer, provided by the app in SDL_AppInit.\n \\param event the new event for the app to examine.\n \\returns SDL_APP_FAILURE to terminate with an error, SDL_APP_SUCCESS to\n          terminate with success, SDL_APP_CONTINUE to continue.\n\n \\threadsafety This function may get called concurrently with\n               SDL_AppIterate() or SDL_AppQuit() for events not pushed from\n               the main thread.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AppInit\n \\sa SDL_AppIterate"]
    pub fn SDL_AppEvent(appstate: *mut ::core::ffi::c_void, event: *mut SDL_Event)
        -> SDL_AppResult;
}
unsafe extern "C" {
    #[doc = " App-implemented deinit entry point for SDL_MAIN_USE_CALLBACKS apps.\n\n Apps implement this function when using SDL_MAIN_USE_CALLBACKS. If using a\n standard \"main\" function, you should not supply this.\n\n This function is called once by SDL before terminating the program.\n\n This function will be called no matter what, even if SDL_AppInit requests\n termination.\n\n This function should not go into an infinite mainloop; it should\n deinitialize any resources necessary, perform whatever shutdown activities,\n and return.\n\n You do not need to call SDL_Quit() in this function, as SDL will call it\n after this function returns and before the process terminates, but it is\n safe to do so.\n\n The `appstate` parameter is an optional pointer provided by the app during\n SDL_AppInit(). If the app never provided a pointer, this will be NULL. This\n function call is the last time this pointer will be provided, so any\n resources to it should be cleaned up here.\n\n This function is called by SDL on the main thread.\n\n \\param appstate an optional pointer, provided by the app in SDL_AppInit.\n \\param result the result code that terminated the app (success or failure).\n\n \\threadsafety SDL_AppEvent() may get called concurrently with this function\n               if other threads that push events are still active.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_AppInit"]
    pub fn SDL_AppQuit(appstate: *mut ::core::ffi::c_void, result: SDL_AppResult);
}
#[doc = " The prototype for the application's main() function\n\n \\param argc an ANSI-C style main function's argc.\n \\param argv an ANSI-C style main function's argv.\n \\returns an ANSI-C main return code; generally 0 is considered successful\n          program completion, and small non-zero values are considered\n          errors.\n\n \\since This datatype is available since SDL 3.2.0."]
pub type SDL_main_func = ::core::option::Option<
    unsafe extern "C" fn(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
unsafe extern "C" {
    #[doc = " An app-supplied function for program entry.\n\n Apps do not directly create this function; they should create a standard\n ANSI-C `main` function instead. If SDL needs to insert some startup code\n before `main` runs, or the platform doesn't actually _use_ a function\n called \"main\", SDL will do some macro magic to redefine `main` to\n `SDL_main` and provide its own `main`.\n\n Apps should include `SDL_main.h` in the same file as their `main` function,\n and they should not use that symbol for anything else in that file, as it\n might get redefined.\n\n This function is only provided by the app if it isn't using\n SDL_MAIN_USE_CALLBACKS.\n\n Program startup is a surprisingly complex topic. Please see\n [README/main-functions](README/main-functions), (or\n docs/README-main-functions.md in the source tree) for a more detailed\n explanation.\n\n \\param argc an ANSI-C style main function's argc.\n \\param argv an ANSI-C style main function's argv.\n \\returns an ANSI-C main return code; generally 0 is considered successful\n          program completion, and small non-zero values are considered\n          errors.\n\n \\threadsafety This is the program entry point.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_main(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Circumvent failure of SDL_Init() when not using SDL_main() as an entry\n point.\n\n This function is defined in SDL_main.h, along with the preprocessor rule to\n redefine main() as SDL_main(). Thus to ensure that your main() function\n will not be changed it is necessary to define SDL_MAIN_HANDLED before\n including SDL.h.\n\n \\since This function is available since SDL 3.2.0.\n\n \\sa SDL_Init"]
    pub fn SDL_SetMainReady();
}
unsafe extern "C" {
    #[doc = " Initializes and launches an SDL application, by doing platform-specific\n initialization before calling your mainFunction and cleanups after it\n returns, if that is needed for a specific platform, otherwise it just calls\n mainFunction.\n\n You can use this if you want to use your own main() implementation without\n using SDL_main (like when using SDL_MAIN_HANDLED). When using this, you do\n *not* need SDL_SetMainReady().\n\n \\param argc the argc parameter from the application's main() function, or 0\n             if the platform's main-equivalent has no argc.\n \\param argv the argv parameter from the application's main() function, or\n             NULL if the platform's main-equivalent has no argv.\n \\param mainFunction your SDL app's C-style main(). NOT the function you're\n                     calling this from! Its name doesn't matter; it doesn't\n                     literally have to be `main`.\n \\param reserved should be NULL (reserved for future use, will probably be\n                 platform-specific then).\n \\returns the return value from mainFunction: 0 on success, otherwise\n          failure; SDL_GetError() might have more information on the\n          failure.\n\n \\threadsafety Generally this is called once, near startup, from the\n               process's initial thread.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_RunApp(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
        mainFunction: SDL_main_func,
        reserved: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.\n\n Generally, you should not call this function directly. This only exists to\n hand off work into SDL as soon as possible, where it has a lot more control\n and functionality available, and make the inline code in SDL_main.h as\n small as possible.\n\n Not all platforms use this, it's actual use is hidden in a magic\n header-only library, and you should not call this directly unless you\n _really_ know what you're doing.\n\n \\param argc standard Unix main argc.\n \\param argv standard Unix main argv.\n \\param appinit the application's SDL_AppInit function.\n \\param appiter the application's SDL_AppIterate function.\n \\param appevent the application's SDL_AppEvent function.\n \\param appquit the application's SDL_AppQuit function.\n \\returns standard Unix main return value.\n\n \\threadsafety It is not safe to call this anywhere except as the only\n               function call in SDL_main.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_EnterAppMainCallbacks(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
        appinit: SDL_AppInit_func,
        appiter: SDL_AppIterate_func,
        appevent: SDL_AppEvent_func,
        appquit: SDL_AppQuit_func,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Callback from the application to let the suspend continue.\n\n This function is only needed for Xbox GDK support; all other platforms will\n do nothing and set an \"unsupported\" error message.\n\n \\since This function is available since SDL 3.2.0."]
    pub fn SDL_GDKSuspendComplete();
}
unsafe extern "C" {
    pub fn main(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::core::ffi::c_uint,
    pub fp_offset: ::core::ffi::c_uint,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::core::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::core::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::core::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::core::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::core::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::core::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
